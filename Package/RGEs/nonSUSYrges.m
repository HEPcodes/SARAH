(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Block[{$Path={ToFileName[{$sarahPackageDir,"RGEs"}]}},
<<nonSUSYrges_aux.m;
<<nonSUSYrges_beta.m;
];

CalcRGEsNonSUSY[TwoLoop_,ReadLists_,VarGens_, NoMatMul_,Simp_, Force_,IgnoreAt2L_,WriteRunning_,ComplexScalarCouplings_]:=Block[{i,j,t,pos},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"CalcRGEsNonSUSY\",\nInitializationCell->True]\)";
SA`Doc`Info = "This is the main file to calcualte the one- and two-loop RGEs for a generic quantum field theory models based on generic formula given in literature (by Machacek & Vaughn; Luo & Ming-Xing; Schienbein, Staub, Steudtner & Svirinia; Sperling, Stockinger & Voigt; Fonseca, Malinsky, & Staub). \n
This routine creates the necessary directories and calls the functions for the different parts of the calculation.";
SA`Doc`Input={"TwoL"->"Include two-loop RGEs?","ReadLists"->"Read results from previous calculation?","VarGens"->"A list with particles whose generations shall be treated as variable", "NoMatMul"->"Don't use matrix multiplication to represent the results, but write everything as sums","Simp"->"Simplify the results?","Force"->"Enforce matrix notation even for parameters with three indices","IgnoreAt2L"->"A list if couplings which shall be ignored at the two-loop level","WriteRunning"->"Write a file (RunRGEs.m) to run the RGEs within Mathematica","ComplexScalarCouplings"->"Treat the scalar couplings as complex parameter"};
SA`Doc`GenerateEntry[];

(*
Print["------------------------------------"];
Print["Calculate non-supersymmetric RGEs   "];
Print["------------------------------------"];*)

Print[StyleForm["Calculate non-supersymmetric RGEs","Section",FontSize->12]];
TimeStartedRGEs=TimeUsed[];
$sarahCurrentRGEDir=ToFileName[{$sarahCurrentOutputMainDir,"RGEs"}];
If[FileExistsQ[$sarahCurrentOutputMainDir]=!=True,    CreateDirectory[$sarahCurrentOutputMainDir];];
If[FileExistsQ[$sarahCurrentRGEDir]=!=True,        CreateDirectory[$sarahCurrentRGEDir];     ];
      
If[ReadLists==False,
SA`SubIgnore2L=Table[IgnoreAt2L[[i]]->0,{i,1,Length[IgnoreAt2L]}];
If[NoMatMul,MakeMatrixMul=False;,MakeMatrixMul=True; sumRGE[a_,b_,c_]=sumRGE[a];];

ParticlesBefore=Particles[RGEs];

PARTsave[S]=PART[S];
PARTsave[F]=PART[F];


PART[F]=Sort[DeleteCases[FFields,0,3]/. conj[x_]->x];
PART[S]=SplitComplexScalars[DeleteCases[SFields,0,3]];
PART[Sc]=PART[S][[1]];
PART[Sr]=PART[S][[2]];
PART[S]=getFullNS/@Sort[getBlank/@Join[PART[Sr],PART[Sc]]];

subRGE=subRGEDelta;
(* MakeMatrixMul=True; *)

LPName = Flatten[{PART[F],PART[S]}] /.A_[{b__}][{c__}]->A /. A_[{b__}]->A /. conj[x_]->x;
PARTALL[F]=Sort[PART[F]/. conj[x_]->x];

(*  LP=Join[PART[F],PART[S]]/. conj[x_]\[Rule]x; *)
LP=LPName;

Print["Initializing Invariants... "];

GenerateCouplingLists;
GenerateCouplingVariables[NoMatMul,Force,ComplexScalarCouplings];
InitGaugeGroupInfo[VarGens];

CheckForNecessarySuperpositions;

InitializeInvariants[TwoLoop];

SA`sub4Scalar  = Dispatch[SA`sub4Scalar];
SA`sub2Scalar = Dispatch[SA`sub2Scalar];

Print["Calculation of beta functions... "];

CalculateAllRGEsNonSUSY[TwoLoop,Simp];

(* ParticlesAfter=Particles[RGEs]; *)
(* Particles[RGEs]=ParticlesBefore; *)
Clear[kF];

PART[S]=PARTsave[S];
PART[F]=PARTsave[F];,
ReadBetaFunctionsNS;
];

If[WriteRunning,
CreateFileForRunning;
];
RGEsCalculated = True;
Print[""];
Print["Finished with the calculation of the RGEs. Time needed: ",TimeUsed []-TimeStartedRGEs,"s"];
Print["The results are saved in ",StyleForm[ToString[$sarahCurrentRGEDir],"Section",FontSize->10]];

SA`Doc`EndEntry[];
];

ReadBetaFunctionsNS:=Block[{},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"ReadBetaFunctionsNS\",\nInitializationCell->True]\)";
SA`Doc`Info = "Reads the results from a previous calculation";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

Print["Read Beta Functions"];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaLijkl.m"]],BetaLijkl=Get[ToFileName[$sarahCurrentRGEDir,"BetaLijkl.m"]]];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaYijk.m"]],BetaYijk=Get[ToFileName[$sarahCurrentRGEDir,"BetaYijk.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaTijk.m"]],BetaTijk=Get[ToFileName[$sarahCurrentRGEDir,"BetaTijk.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaBij.m"]],BetaBij=Get[ToFileName[$sarahCurrentRGEDir,"BetaBij.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaMuij.m"]],BetaMuij=Get[ToFileName[$sarahCurrentRGEDir,"BetaMuij.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaMuij.m"]],BetaMFij=Get[ToFileName[$sarahCurrentRGEDir,"BetaMuij.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaLi.m"]],BetaLi=Get[ToFileName[$sarahCurrentRGEDir,"BetaLi.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaGauge.m"]],BetaGauge=Get[ToFileName[$sarahCurrentRGEDir,"BetaGauge.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaVEV.m"]],BetaVEV=Get[ToFileName[$sarahCurrentRGEDir,"BetaVEV.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"GSij.m"]],Gij=Get[ToFileName[$sarahCurrentRGEDir,"GSij.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"GFij.m"]],Gij=Get[ToFileName[$sarahCurrentRGEDir,"GFij.m"]];];

If[ThreeIndexParametersInvolved===True,
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaLijkl3I.m"]],BetaLijkl3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaLijkl3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaYijk3I.m"]],BetaYijk3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaYijk3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaTijk3I.m"]],BetaTijk3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaTijk3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaBij3I.m"]],BetaBij3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaBij3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaMuij3I.m"]],BetaMuij3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaMuij3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaMuij3I.m"]],BetaMFij3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaMuij3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaLi3I.m"]],BetaLi3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaLi3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaGauge3I.m"]],BetaGauge3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaGauge3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"BetaVEV3I.m"]],BetaVEV3I=Get[ToFileName[$sarahCurrentRGEDir,"BetaVEV3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"GSij3I.m"]],Gij3I=Get[ToFileName[$sarahCurrentRGEDir,"GSij3I.m"]];];
If[FileExistsQ[ToFileName[$sarahCurrentRGEDir,"GFij3I.m"]],Gij3I=Get[ToFileName[$sarahCurrentRGEDir,"GFij3I.m"]];];
];

SA`Doc`EndEntry[];
];

SplitComplexScalars[list_]:=Block[{i,j,temp,name,real,im,tempR},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"SplitComplexScalars\",\nInitializationCell->True]\)";
SA`Doc`Info = "The generic expressions for non-SUSY RGEs are given for real scalars. Therefore, it is necessary to split all complex scalars in the given model into real components. This function does this splitting and generates substitutions rules for that.";
SA`Doc`Input={"list"->"List of complex scalars"};
SA`Doc`GenerateEntry[];

subComplexScalarsSum={};
subComplexScalarsList={};
SFieldsSplitted={};
subExchangeScalarRI={};
subRealSplitted={};
temp={};
tempR={};
For[i=1,i<=Length[list],
name = list[[i]] /. A_[{b__}][{c__}]->A /. A_[{b__}]->A;
real=ToExpression["r"<>ToString[name]];
im=ToExpression["i"<>ToString[name]];
getFullSF[im]=(getFullSF[name] /.name->im);
getFullSF[real]=(getFullSF[name] /. name->real);
getGenAux[im]=getGenALL[name];
getGenAux[real]=getGenALL[name];
For[j=1,j<=Length[Gauge],
SA`DynL[im,Gauge[[j,3]]]=SA`DynL[name,Gauge[[j,3]]];
SA`DynL[real,Gauge[[j,3]]]=SA`DynL[name,Gauge[[j,3]]];
SA`Dynkin[im,Gauge[[j,3]]]=SA`Dynkin[name,Gauge[[j,3]]];
SA`Dynkin[real,Gauge[[j,3]]]=SA`Dynkin[name,Gauge[[j,3]]];
SA`Casimir[im,Gauge[[j,3]]]=SA`Casimir[name,Gauge[[j,3]]];
SA`Casimir[real,Gauge[[j,3]]]=SA`Casimir[name,Gauge[[j,3]]];
SA`DynL[im[{a__}],Gauge[[j,3]]]=SA`DynL[name,Gauge[[j,3]]];
SA`DynL[real[{a__}],Gauge[[j,3]]]=SA`DynL[name,Gauge[[j,3]]];
SA`Dynkin[im[{a__}],Gauge[[j,3]]]=SA`Dynkin[name,Gauge[[j,3]]];
SA`Dynkin[real[{a__}],Gauge[[j,3]]]=SA`Dynkin[name,Gauge[[j,3]]];
SA`Casimir[im[{a__}],Gauge[[j,3]]]=SA`Casimir[name,Gauge[[j,3]]];
SA`Casimir[real[{a__}],Gauge[[j,3]]]=SA`Casimir[name,Gauge[[j,3]]];
SA`Dynkin[im[{a__}][{b__}],Gauge[[j,3]]]=SA`Dynkin[name,Gauge[[j,3]]];
SA`Dynkin[real[{a__}][{b__}],Gauge[[j,3]]]=SA`Dynkin[name,Gauge[[j,3]]];
SA`Casimir[im[{a__}][{b__}],Gauge[[j,3]]]=SA`Casimir[name,Gauge[[j,3]]];
SA`Casimir[real[{a__}][{b__}],Gauge[[j,3]]]=SA`Casimir[name,Gauge[[j,3]]];
SA`DynL[im[{a__}][{b__}],Gauge[[j,3]]]=SA`DynL[name,Gauge[[j,3]]];
SA`DynL[real[{a__}][{b__}],Gauge[[j,3]]]=SA`DynL[name,Gauge[[j,3]]];
SA`MulFactor[im,Gauge[[j,3]]]=SA`MulFactor[name,Gauge[[j,3]]];
SA`MulFactor[real,Gauge[[j,3]]]=SA`MulFactor[name,Gauge[[j,3]]];
j++;];

If[FreeQ[RealScalarsMul,(list[[i]] /. A_[{b__}][{c__}]->A /. A_[{b__}]->A)],
SFieldsSplitted=Join[SFieldsSplitted,{list[[i]]/.name->real,list[[i]]/.name->im}];
temp=Join[temp,{list[[i]] /. name->real, list[[i]]/.name->im}];
subComplexScalarsSum = Join[subComplexScalarsSum,{name[a__][b__]-> 1/Sqrt[2](real[a][b] + I im[a][b]),name[a__]-> 1/Sqrt[2]( real[a] + I im[a]),name-> 1/Sqrt[2]( real + I im)}];
subComplexScalarsList = Join[subComplexScalarsList,{name[a__][b__]->{ real[a][b],  im[a][b]},name[a__]->{ real[a],  im[a]},name->{ real,  im}}];
subExchangeScalarRI=Join[subExchangeScalarRI,{real->im,im->real}];
subRealSplitted=Join[subRealSplitted,{conj[real[a__][b_]]->real[a][b],conj[im[a__][b_]]->im[a][b],conj[real[a_]]->real[a],conj[im[a__]]->im[a]}];,
SFieldsSplitted=Join[SFieldsSplitted,{list[[i]]/. name->real}];
tempR=Join[tempR,{list[[i]]/. name->real}];
subComplexScalarsSum = Join[subComplexScalarsSum,{name[a__][b__]-> (real[a][b] ),name[a__]->( real[a] ),name->( real )}];
subComplexScalarsList = Join[subComplexScalarsList,{name[a__][b__]->{ real[a][b], real[a][b]},name[a__]->{ real[a],real[a]},name->{ real,real}}];
subRealSplitted=Join[subRealSplitted,{conj[real[a__][b_]]->real[a][b],conj[real[a_]]->real[a]}];
];
i++;];
SA`Doc`Return[{Flatten[temp],tempR}];
];

SplitScalarCouplings[list_,ComplexScalarCouplings_]:=Block[{i,j,temp,fields,res={},resOne={},added=False,nonzero},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"SplitScalarCouplings\",\nInitializationCell->True]\)";
SA`Doc`Info = "This function calculations the interactions after the splitting of complex scalar into real components.";
SA`Doc`Input={"list"->"List of couplings involving complex scalars","ComplexScalarCouplings"->"Treat the scalar couplings as complex parameters"};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[list],
If[FreeQ[Take[list,{1,i-1}],list[[i,2]]/. InvMat[a__][__]->1 /. Delta[a__]->1 /.epsTensor[a__]->1],
added=False;,
added=True;
];
term=Expand[Times@@(list[[i,1]] /. subComplexScalarsSum /. conj[x_]->x)*list[[i,2]]];

(* If[Length[list[[i,1]]]===4, *)
If[list[[i,3]]===True,
(* If[(conj[Times@@list[[i,1]]] /. A_[{b__}][{c__}]\[Rule]A /. A_[{b__}]\[Rule]A) =!=(Times@@list[[i,1]] /. A_[{b__}][{c__}]\[Rule]A /. A_[{b__}]\[Rule]A), *)
If[ComplexScalarCouplings===True,
term=term+Expand[Times@@((conj/@list[[i,1]]) /. subComplexScalarsSum /.conj[InvMat[a_][b__]]->Conjugate[InvMat[a][b]]/. conj[x_]->x)*conj[list[[i,2]]]];,
term=term+Expand[Times@@((conj/@list[[i,1]]) /. subComplexScalarsSum /.conj[InvMat[a_][b__]]->Conjugate[InvMat[a][b]]/. conj[x_]->x)*(list[[i,2]]/. InvMat[a_][b__]->conj[InvMat[a][b]])];
If[OnlyDummy=!=True,Print["Note, the following parameter is treated as real in RGEs: ",If[Head[Expand[list[[i,2]]]]===Plus,Expand[list[[i,2]]][[1]],list[[i,2]]]/. {Delta[a__]->1,epsTensor[__]->1,x_?NumericQ->1}];];
(* ]; *)
];
];
invfields={};
For[j=1,j<=Length[list[[i,1]]],
invfields=Join[invfields,{list[[i,1,j]] /. subComplexScalarsList /. A_[{b__}][{c__}]->A /. A_[{b__}]->A}];
j++;];
invfields=Intersection[Flatten[invfields]];
invfields=Intersection[Sort/@Tuples[invfields,{Length[list[[i,1]]]}]  /. conj[x_]->x];
invfields=Intersection[Sort/@invfields];
nonzero=0;
For[j=1,j<=Length[invfields],
temp=term;
For[k=1,k<=Length[invfields[[j]]],
temp=DPRGE[temp,invfields[[j,k]],k];
k++;];
If[temp=!=0,
nonzero++;
res=Join[res,{{Sort[Table[If[FreeQ[FFields,invfields[[j,k]]]==False,FFields[[Position[FFields,invfields[[j,k]]][[1,1]]]] ,getFullSF[invfields[[j,k]]]] //.subGC[k]/. subIndFinal[k,k]/. conj[x_]->x,{k,1,Length[invfields[[j]]]}],((getTypeOld[#1]>getTypeOld[#2]) /. {NoField->1,S->1,F->2})&],{temp,1}}}];
If[added==False  (* && (nonzero>1 || Length[invfields[[j]]]=!=4 ) *),
added=True;
resOne=Join[resOne,{{Sort[Table[If[FreeQ[FFields,invfields[[j,k]]]==False,FFields[[Position[FFields,invfields[[j,k]]][[1,1]]]] ,getFullSF[invfields[[j,k]]]] //.subGC[k]/. subIndFinal[k,k]/. conj[x_]->x,{k,1,Length[invfields[[j]]]}],((getTypeOld[#1]>getTypeOld[#2]) /. {NoField->1,S->1,F->2})&],{temp,1}}}];
];
];
j++;];
i++;];
SA`Doc`Return[{res,resOne}];

];
DPRGE[term_,particle_,t_]:=Block[{part,i},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"DPRGE\",\nInitializationCell->True]\)";
SA`Doc`Info = "This function is used to extract the couplings from a Lagrangian term after the complex scalars are decomposed: it performs the partial derivative of a given term with respect to a given particle. This is iterated for all external fields.";
SA`Doc`Input={"term"->"The considered term","particle"->"The considered particle","t"->"The count of the particle"};
SA`Doc`GenerateEntry[];

If[FreeQ[FFields,particle]==False,part=FFields[[Position[FFields,particle][[1,1]]]] /. conj[x_]->x;,part=getFullSF[particle];];
If[AtomQ[RE[part]],
SA`Doc`Return[D[term,part]];,
SA`Doc`Return[Plus@@Table[D[term,part /. subGC[i]] /. subIndFinal[i,t],{i,1,genMax}]];
];
];

CalculateAllRGEsNonSUSY[TwoLoop_,Simp_]:=Block[{subindnames},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"CalculateAllRGEsNonSUSY\",\nInitializationCell->True]\)";
SA`Doc`Info = "This function is a wrapper to perform the calculations of all generic types of couplings.";
SA`Doc`Input={"TwoLoop"->"Include two loop?","Simp"->"Simplify expressions?"};
SA`Doc`GenerateEntry[];

subindnames=Flatten[Table[Reverse/@ReleaseHold[subIndizesFinal/. number1->i /. number2->i],{i,1,4}]];
CalcBetaFunctionsNonSUSY[GAUGE,SA`ListGC,"BetaGauge","BetaGauge3I",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[GSIJ,Table[{{PART[S][[i]]/.subGC[1],PART[S][[i]]/.subGC[2]},{makeDeltaNS[PART[S][[i]],{}],1}},{i,1,Length[PART[S]]}] /.subindnames,"Gammaij","Gammaij3I",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[GSijHat,Table[{{PART[S][[i]]/.subGC[1],PART[S][[i]]/.subGC[2]},{makeDeltaNS[PART[S][[i]],{}],1}},{i,1,Length[PART[S]]}] /.subindnames,"GammaijHat","Gammaij3IHat",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[GFIJ,Table[{{PART[F][[i]]/.subGC[1],PART[F][[i]]/.subGC[2]},{makeDeltaNS[PART[F][[i]],{}],1}},{i,1,Length[PART[F]]}] /.subindnames,"GijF","GijF3I",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[YIJK,lW3one /.subindnames ,"BetaYijk","BetaYijk3I",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[MFIJ,lW2one /.subindnames ,"BetaMuij","BetaMuij3I",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[LIJKL,lA4oneBeta /.subindnames,"BetaLijkl","BetaLijkl3I",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[TIJK,lA3oneBeta /.subindnames ,"BetaTijk","BetaTijk3I",TwoLoop,Simp];
CalcBetaFunctionsNonSUSY[MSIJ,lA2oneBeta /.subindnames,"BetaBij","BetaBij3I",TwoLoop,Simp];
If[SA`ListVEVi==={},
BetaVEV={};
BetaVEV3I={};,
CalcBetaFunctionsNonSUSY[VEVI,SA`ListVEVi  /.subGC[1]/.subindnames,"BetaVEV","BetaVEV3I",TwoLoop,Simp];
];

SA`Doc`EndEntry[];
];


(* ::Input::Initialization:: *)
GenerateCouplingVariables[NoMatMul_,Force_,ComplexScalarCouplings_]:=Block[{pos,i,j,k,subrule,per,free,added={},res,temp,tempS,indNr,indices,deltaInd,deltaInd2},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"GenerateCouplingVariables\",\nInitializationCell->True]\)";
SA`Doc`Info = "This routines generates functions (Lijkl, Yijk, Aijk, Bij, ..) to represent the different couplings. For instance, Yukawa-like can then called by Yijk[p1,p2,p3] where p1..p3 are the involved fields and the full expression is inserted. This is heavily used to implement the beta-function in a notation very similar to the generic notation used in literature. \n Some additional efforts are needed to bring the VEVs into the correct form and to associate them with the correct superfield. That's done at the end of this routine.";
SA`Doc`Input={"NoMatMul"->"Don't use matrix multiplication to represent the results, but write everything as sums","Force"->"Enforce matrix notation even for parameters with three indices","ComplexScalarCouplings"->"Treat scalar interactions as complex parameters?"};
SA`Doc`GenerateEntry[];

If[NoMatMul,MakeMatrixMul=False;,MakeMatrixMul=True;];

res=SplitScalarCouplings[SA`SSlist,ComplexScalarCouplings]; lA2=res[[1]];lA2one=res[[2]];
res=SplitScalarCouplings[SA`SSSlist,ComplexScalarCouplings];lA3=res[[1]];lA3one=res[[2]];
res=SplitScalarCouplings[SA`SSSSlist,ComplexScalarCouplings];lA4=res[[1]];lA4one=res[[2]];
res=SplitScalarCouplings[SA`FFSlist,ComplexScalarCouplings];lW3=res[[1]];lW3one=res[[2]];
res=SplitScalarCouplings[SA`FFlist,ComplexScalarCouplings];lW2=res[[1]];lW2one=res[[2]];

SA`subImagToReal=Join[Table[subComplexScalarsList[[i,2,1]]->subComplexScalarsList[[i,2,2]],{i,1,Length[subComplexScalarsList]}],Table[subComplexScalarsList[[i,2,2]]->subComplexScalarsList[[i,2,1]],{i,1,Length[subComplexScalarsList]}]];

subRuleTemp[x_]:=subGCRule[x] /. subGC[x] /. subIndFinal[x,x];
subForce={};

threeIndexParameter={};
For[i=1,i<=Length[lW3one],
If[FreeQ[lW3one[[i]],a_[gt1,gt2,gt3]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lW3one[[i,2,1]],x_[gt1,gt2,gt3]]}];]; 
If[FreeQ[lW3one[[i]],a_[gt1,gt3,gt2]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lW3one[[i,2,1]],x_[gt1,gt3,gt2]]}];]; 
If[FreeQ[lW3one[[i]],a_[gt2,gt1,gt3]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lW3one[[i,2,1]],x_[gt2,gt1,gt3]]}];]; 
If[FreeQ[lW3one[[i]],a_[gt2,gt3,gt1]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lW3one[[i,2,1]],x_[gt2,gt3,gt1]]}];]; 
If[FreeQ[lW3one[[i]],a_[gt3,gt2,gt1]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lW3one[[i,2,1]],x_[gt3,gt2,gt1]]}];]; 
If[FreeQ[lW3one[[i]],a_[gt3,gt1,gt2]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lW3one[[i,2,1]],x_[gt3,gt1,gt2]]}];]; 
i++;];

For[i=1,i<=Length[lA3one],
If[FreeQ[lA3one[[i]],a_[gt1,gt2,gt3]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lA3one[[i,2,1]],x_[gt1,gt2,gt3]]}];]; 
If[FreeQ[lA3one[[i]],a_[gt1,gt3,gt2]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lA3one[[i,2,1]],x_[gt1,gt3,gt2]]}];]; 
If[FreeQ[lA3one[[i]],a_[gt2,gt1,gt3]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lA3one[[i,2,1]],x_[gt2,gt1,gt3]]}];]; 
If[FreeQ[lA3one[[i]],a_[gt2,gt3,gt1]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lA3one[[i,2,1]],x_[gt2,gt3,gt1]]}];]; 
If[FreeQ[lA3one[[i]],a_[gt3,gt2,gt1]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lA3one[[i,2,1]],x_[gt3,gt2,gt1]]}];]; 
If[FreeQ[lA3one[[i]],a_[gt3,gt1,gt2]]==False,threeIndexParameter=Join[threeIndexParameter,{Cases[lA3one[[i,2,1]],x_[gt3,gt1,gt2]]}];]; 
i++;];
threeIndexParameter=Intersection[Flatten[threeIndexParameter] /. A_[b_,c_,d_]->A];
subThreeIndices  = {};

If[threeIndexParameter=!={},
MakeMatrixMul=False;
ThreeIndexParametersInvolved=True;
For[i=1,i<=Length[threeIndexParameter],
subThreeIndices  =Join[subThreeIndices ,{threeIndexParameter[[i]][b_,c_,s1_]-> Sum[threeIndexParameter[[i]][j][b,c] DeltaKronecker[j,s1],{j,1,getDimParameter[threeIndexParameter[[i]]][[3]]}]}];
For[j=1,j<= getDimParameter[threeIndexParameter[[i]]][[3]],
parameters = Join[parameters,{{threeIndexParameter[[i]][j],{generation,generation},{getDimParameter[threeIndexParameter[[i]]][[1]],getDimParameter[threeIndexParameter[[i]]][[2]]}}}];
j++;];
i++;];

If[Force==True,MakeMatrixMul=True;subForce = subThreeIndices;ThreeIndexParametersInvolved=False;];
If[NoMatMul==True,ThreeIndexParametersInvolved=False;subForce = {};];
];

subRule=Flatten[{subRuleTemp[1],subRuleTemp[2],subRuleTemp[3],subRuleTemp[4]}];

per=Permutations[{1,2,3,4}];

(*
For[j=1,j\[LessEqual]Length[per],
For[i=1,i\[LessEqual]Length[lA4],
Lijkl[lA4[[i,1,per[[j,1]]]]/.subRule,lA4[[i,1,per[[j,2]]]]/.subRule,lA4[[i,1,per[[j,3]]]]/.subRule,lA4[[i,1,per[[j,4]]]]/.subRule]=lA4[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]\[Rule]Conj[x] /. subForce  ;
i++;];
j++;];
*)

temp={};
For[i=1,i<=Length[lA4],
If[FreeQ[temp,lA4[[i,1]]],
temp=Join[temp,{lA4[[i]]}];,
pos=Position[temp,lA4[[i,1]]][[1,1]];
temp[[pos,2]]=temp[[pos,2]]+lA4[[i,2]];
];
i++;];
lA4=temp;

SetAttributes[Lijkl,Orderless];
For[i=1,i<=Length[lA4],
Lijkl[lA4[[i,1,1]]/.subRule,lA4[[i,1,2]]/.subRule,lA4[[i,1,3]]/.subRule,lA4[[i,1,4]]/.subRule]=lA4[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]->Conj[x] /. subForce  ;
i++;];

If[Length[lA4]==0,Lijkl[a___]=0];

(*
per=Permutations[{1,2,3}];
For[j=1,j\[LessEqual]Length[per],
For[i=1,i\[LessEqual]Length[lA3],
Aijk[lA3[[i,1,per[[j,1]]]]/.subRule,lA3[[i,1,per[[j,2]]]]/.subRule,lA3[[i,1,per[[j,3]]]]/.subRule]=lA3[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]\[Rule]Conj[x] /. subForce ;
i++;];
j++;];*)

temp={};
For[i=1,i<=Length[lA3],
If[FreeQ[temp,lA3[[i,1]]],
temp=Join[temp,{lA3[[i]]}];,
pos=Position[temp,lA3[[i,1]]][[1,1]];
temp[[pos,2]]=temp[[pos,2]]+lA3[[i,2]];
];
i++;];
lA3=temp;

SetAttributes[Aijk,Orderless];
For[i=1,i<=Length[lA3],
Aijk[lA3[[i,1,1]]/.subRule,lA3[[i,1,2]]/.subRule,lA3[[i,1,3]]/.subRule]= lA3[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]->Conj[x] /. subForce ;
i++;];

If[Length[lA3]==0,Aijk[a___]=0];

per=Permutations[{1,2}];

(*
For[j=1,j\[LessEqual]Length[per],
For[i=1,i\[LessEqual]Length[lW3],
If[FreeQ[SFields,getBlankSF[lW3[[i,1,3]]]],
(*Yijk[lW3[[i,1,per[[j,1]]]]/.subRule,lW3[[i,1,per[[j,2]]]]/.subRule,lW3[[i,1,3]]/.subRule]=  lW3[[i,2,1]]/\[ImaginaryI] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]\[Rule]Conj[x] /. subForce ;,*)
Yijk[lW3[[i,1,per[[j,1]]]]/.subRule,lW3[[i,1,per[[j,2]]]]/.subRule,lW3[[i,1,3]]/.subRule]=  lW3[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]\[Rule]Conj[x] /. subForce ;,
Yijk[lW3[[i,1,per[[j,1]]]]/.subRule,lW3[[i,1,per[[j,2]]]]/.subRule,lW3[[i,1,3]]/.subRule]=  lW3[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]\[Rule]Conj[x] /. subForce ;
];
i++;];
j++;];
*)

temp={};
For[i=1,i<=Length[lW3],
If[FreeQ[temp,lW3[[i,1]]],
temp=Join[temp,{lW3[[i]]}];,
pos=Position[temp,lW3[[i,1]]][[1,1]];
temp[[pos,2]]=temp[[pos,2]]+lW3[[i,2]];
];
i++;];
lW3=temp;

For[j=1,j<=Length[per],
For[i=1,i<=Length[lW3],
Yijk[lW3[[i,1,per[[j,1]]]]/.subRule,lW3[[i,1,per[[j,2]]]]/.subRule,lW3[[i,1,3]]/.subRule]=  lW3[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]->Conj[x] /. subForce ;
i++;];
j++;];


If[Length[lW3]==0,Yijk[a___]=0];


(*
For[i=1,i\[LessEqual]Length[lW2],
Muij[lW2[[i,1,per[[j,1]]]]/.subRule,lW2[[i,1,per[[j,2]]]]/.subRule]=lW2[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]\[Rule]Conj[x] /. subForce ;
i++;];
*)

SetAttributes[Muij,Orderless];
For[i=1,i<=Length[lW2],
Muij[lW2[[i,1,1]]/.subRule,lW2[[i,1,2]]/.subRule]=lW2[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]->Conj[x] /. subForce ;
i++;];

If[Length[lW2]==0,Muij[a___]=0];

(*
For[i=1,i\[LessEqual]Length[lA2],
Bij[lA2[[i,1,per[[j,1]]]]/.subRule,lA2[[i,1,per[[j,2]]]]/.subRule]=1/2 lA2[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]\[Rule]Conj[x] /. subForce ;
i++;];
j++;];
*)

temp={};
For[i=1,i<=Length[lA2],
If[FreeQ[temp,lA2[[i,1]]],
temp=Join[temp,{lA2[[i]]}];,
pos=Position[temp,lA2[[i,1]]][[1,1]];
temp[[pos,2]]=temp[[pos,2]]+lA2[[i,2]];
];
i++;];
lA2=temp;

SetAttributes[Bij,Orderless];
For[i=1,i<=Length[lA2],
Bij[lA2[[i,1,1]]/.subRule,lA2[[i,1,2]]/.subRule]=(* 1/2 *) lA2[[i,2,1]] /.Select[subAlways,FreeQ[#1,sum]&] /. conj[x_]->Conj[x] /. subForce ;
i++;];


If[Length[lA2]==0,Bij[a___]=0];


NeededAnaDimsForVEVs={};
listVEVi={};
SA`ListVEVi={};
Clear[VEVi];

(*
For[j=1,j\[LessEqual]Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[j]]][VEVs]]===List,
For[i=1,i\[LessEqual]Length[DEFINITION[NameOfStates[[j]]][VEVs]],
If[FreeQ[listVEVi,DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]] && DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]=!=0 && DEFINITION[NameOfStates[[j]]][VEVs][[i,2,2]]=!=0,
pos=Position[SFieldsMultiplets,DEFINITION[NameOfStates[[j]]][VEVs][[i,1]]];
tempS=(getBlankSF[Extract[SFields,pos[[1,1]]]]/. subComplexScalarsList);
If[Head[tempS]===List,
NeededAnaDimsForVEVs=Join[NeededAnaDimsForVEVs,{{tempS[[1]],DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]}}];,
NeededAnaDimsForVEVs=Join[NeededAnaDimsForVEVs,{{tempS,DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]}}];
];
sf=(RE[getFullSF[Extract[SFields,pos[[1,1]]]]]/. subComplexScalarsList);
If[Head[sf]===List,sf=sf[[1]];];
listVEVi = Join[listVEVi,{{sf  makeDelta[pos[[1,1]],1,2,{generation}],DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]}}];
SA`ListVEVi = Join[SA`ListVEVi,{{{sf}, {makeDelta[pos[[1,1]],1,2,{generation}] DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]],-1}}}];
VEVi[sf /. Delta[a__]\[Rule]1 /. RM[a__][b__]\[Rule]1 /. subGCRule[1]]=getFull[DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]] /. subGC[1];
];
i++;];
];
j++;];
*)
listsf={};
For[j=1,j<=Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[j]]][VEVs]]===List,
For[i=1,i<=Length[DEFINITION[NameOfStates[[j]]][VEVs]],
If[FreeQ[listVEVi,DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]] && DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]=!=0 && DEFINITION[NameOfStates[[j]]][VEVs][[i,2,2]]=!=0,
pos=Position[SFieldsMultiplets,DEFINITION[NameOfStates[[j]]][VEVs][[i,1]]];
If[Head[SFieldsMultiplets[[pos[[1,1]]]]]===List,
indNr=Position[SFieldsMultiplets[[pos[[1,1]]]],DEFINITION[NameOfStates[[j]]][VEVs][[i,1]]];
];
tempS=(getBlankSF[Extract[SFields,pos[[1,1]]]]/. subComplexScalarsList);
If[Head[tempS]===List,
NeededAnaDimsForVEVs=Join[NeededAnaDimsForVEVs,{{tempS[[1]],DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]}}];,
NeededAnaDimsForVEVs=Join[NeededAnaDimsForVEVs,{{tempS,DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]}}];
];
sf=(RE[getFullSF[Extract[SFields,pos[[1,1]]]]]/. subComplexScalarsList);
If[Head[sf]===List,sf=sf[[1]];];
indices=ListFields[[pos[[1,1]],2,1]];
indices=Select[indices,MemberQ[Gauge,#,2]&];
deltaInd=1;
deltaInd2=1;
For[k=1,k<=Length[indices],
deltaInd=deltaInd*Delta[indices[[k]]/.subGC[1],indNr[[1,k]]];
deltaInd2=deltaInd2*(Delta[indices[[k]]/.subGC[1],indices[[k]]/.subGC[2]]); 
k++;
];
listVEVi = Join[listVEVi,{{sf  deltaInd  deltaInd2 (*makeDelta[pos[[1,1]],1,2,{generation}]*) ,DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]}}];
SA`ListVEVi = Join[SA`ListVEVi,{{{sf}, {deltaInd deltaInd2 (* makeDelta[pos[[1,1]],1,2,{generation}]*) DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]],-1}}}];
If[FreeQ[listsf,sf],
VEVi[sf /. Delta[a__]->1 /. RM[a__][b__]->1 /. subGCRule[1]]=deltaInd getFull[DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]] /. subGC[1];,
pos=Position[listsf,sf][[1,1]];
VEVi[sf /. Delta[a__]->1 /. RM[a__][b__]->1 /. subGCRule[1]]=listsf[[pos]][[2]]+deltaInd getFull[DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]] /. subGC[1];
];
listsf=Join[listsf,{{sf,deltaInd getFull[DEFINITION[NameOfStates[[j]]][VEVs][[i,2,1]]] /. subGC[1]}}];
];
i++;];
];
j++;];

listQuad = Table[{},{Length[LP]}];
listQuad2 = Table[{},{Length[LP]}];
listQuad3 = Table[{},{Length[LP]}];
listTri = Table[{},{Length[LP]}];
listTri2 ={};
listBi = Table[{},{Length[LP]}];

For[i=1,i<=Length[lW2],
pos=Position[LP,getBlank[lW2[[i,1,1]]]]; listBi[[pos[[1,1]]]]=Join[listBi[[pos[[1,1]]]],{lW2[[i,1,2]]}];
pos=Position[LP,getBlank[lW2[[i,1,2]]]]; listBi[[pos[[1,1]]]]=Join[listBi[[pos[[1,1]]]],{lW2[[i,1,1]]}];
i++;];

For[i=1,i<=Length[lA2],
pos=Position[LP,getBlank[lA2[[i,1,1]]]]; listBi[[pos[[1,1]]]]=Join[listBi[[pos[[1,1]]]],{lA2[[i,1,2]]}];
pos=Position[LP,getBlank[lA2[[i,1,2]]]]; listBi[[pos[[1,1]]]]=Join[listBi[[pos[[1,1]]]],{lA2[[i,1,1]]}];
i++;];

For[i=1,i<=Length[lW3],
pos=Position[LP,getBlank[lW3[[i,1,1]]]];listTri[[pos[[1,1]]]]=Join[listTri[[pos[[1,1]]]],{lW3[[i,1,2]],lW3[[i,1,3]]}];
pos=Position[LP,getBlank[lW3[[i,1,2]]]];listTri[[pos[[1,1]]]]=Join[listTri[[pos[[1,1]]]],{lW3[[i,1,1]],lW3[[i,1,3]]}];
pos=Position[LP,getBlank[lW3[[i,1,3]]]];listTri[[pos[[1,1]]]]=Join[listTri[[pos[[1,1]]]],{lW3[[i,1,2]],lW3[[i,1,1]]}];
For[j=1,j<=3,
If[FreeQ[listTri2,C[getBlank[lW3[[i,1,j]]],getBlank[lW3[[i,1,Mod[j+1,3,1]]]]]],
listTri2 = Join[listTri2,{{C[getBlank[lW3[[i,1,j]]],getBlank[lW3[[i,1,Mod[j+1,3,1]]]]],{getBlank[lW3[[i,1,Mod[j+2,3,1]]]]}}}];,
pos=Position[listTri2,C[getBlank[lW3[[i,1,j]]],getBlank[lW3[[i,1,Mod[j+1,3,1]]]]]][[1,1]];
listTri2[[pos,2]]=Intersection[Join[listTri2[[pos,2]],{getBlank[lW3[[i,1,Mod[j+2,3,1]]]]}]];
];
j++;];
i++;];

For[i=1,i<=Length[lA3],
pos=Position[LP,getBlank[lA3[[i,1,1]]]];listTri[[pos[[1,1]]]]=Join[listTri[[pos[[1,1]]]],{lA3[[i,1,2]],lA3[[i,1,3]]}];
pos=Position[LP,getBlank[lA3[[i,1,2]]]];listTri[[pos[[1,1]]]]=Join[listTri[[pos[[1,1]]]],{lA3[[i,1,1]],lA3[[i,1,3]]}];
pos=Position[LP,getBlank[lA3[[i,1,3]]]];listTri[[pos[[1,1]]]]=Join[listTri[[pos[[1,1]]]],{lA3[[i,1,2]],lA3[[i,1,1]]}];
For[j=1,j<=3,
If[FreeQ[listTri2,C[getBlank[lA3[[i,1,j]]],getBlank[lA3[[i,1,Mod[j+1,3,1]]]]]],
listTri2 = Join[listTri2,{{C[getBlank[lA3[[i,1,j]]],getBlank[lA3[[i,1,Mod[j+1,3,1]]]]],{getBlank[lA3[[i,1,Mod[j+2,3,1]]]]}}}];,
pos=Position[listTri2,C[getBlank[lA3[[i,1,j]]],getBlank[lA3[[i,1,Mod[j+1,3,1]]]]]][[1,1]];
listTri2[[pos,2]]=Intersection[Join[listTri2[[pos,2]],{getBlank[lA3[[i,1,Mod[j+2,3,1]]]]}]];
];
j++;];
i++;];

For[i=1,i<=Length[lA4],
pos=Position[LP,getBlank[lA4[[i,1,1]]]];listQuad[[pos[[1,1]]]]=Join[listQuad[[pos[[1,1]]]],{lA4[[i,1,2]],lA4[[i,1,3]],lA4[[i,1,4]]}];
pos=Position[LP,getBlank[lA4[[i,1,2]]]];listQuad[[pos[[1,1]]]]=Join[listQuad[[pos[[1,1]]]],{lA4[[i,1,1]],lA4[[i,1,3]],lA4[[i,1,4]]}];
pos=Position[LP,getBlank[lA4[[i,1,3]]]];listQuad[[pos[[1,1]]]]=Join[listQuad[[pos[[1,1]]]],{lA4[[i,1,2]],lA4[[i,1,1]],lA4[[i,1,4]]}];
pos=Position[LP,getBlank[lA4[[i,1,3]]]];listQuad[[pos[[1,1]]]]=Join[listQuad[[pos[[1,1]]]],{lA4[[i,1,2]],lA4[[i,1,1]],lA4[[i,1,3]]}];


For[j=1,j<=4,
For[k=1,k<=4,
If[j!=k,
free=DeleteCases[DeleteCases[{1,2,3,4},j],k];
If[FreeQ[listQuad2,C[getBlank[lA4[[i,1,j]]],getBlank[lA4[[i,1,k]]]]],
listQuad2 = Join[listQuad2,{{C[getBlank[lA4[[i,1,j]]],getBlank[lA4[[i,1,k]]]],{getBlank[lA4[[i,1,free[[1]]]]],getBlank[lA4[[i,1,free[[2]]]]]}}}];,
pos=Position[listQuad2,C[getBlank[lA4[[i,1,j]]],getBlank[lA4[[i,1,k]]]]][[1,1]];
listQuad2[[pos,2]]=Intersection[Join[listQuad2[[pos,2]],{getBlank[lA4[[i,1,free[[1]]]]],getBlank[lA4[[i,1,free[[2]]]]]}]];
];
];
k++;];
j++;];

For[j=1,j<=4,
free=DeleteCases[{1,2,3,4},j];
If[FreeQ[listQuad3,C[getBlank[lA4[[i,1,free[[1]]]]],getBlank[lA4[[i,1,free[[2]]]]],getBlank[lA4[[i,1,free[[3]]]]]]],
listQuad3 = Join[listQuad3,{{C[getBlank[lA4[[i,1,free[[1]]]]],getBlank[lA4[[i,1,free[[2]]]]],getBlank[lA4[[i,1,free[[3]]]]]],{getBlank[lA4[[i,1,j]]]}}}];,
pos=Position[listQuad3,C[getBlank[lA4[[i,1,free[[1]]]]],getBlank[lA4[[i,1,free[[2]]]]],getBlank[lA4[[i,1,free[[3]]]]]]][[1,1]];
listQuad3[[pos,2]]=Intersection[Join[listQuad3[[pos,2]],{getBlank[lA4[[i,1,j]]]}]];
];
j++;];


i++;];

For[i=1,i<=Length[LP],
listBi[[i]]=Join[listBi[[i]],{LP[[i]]}];
listTri[[i]]=Join[listTri[[i]],{LP[[i]]}];
listQuad[[i]]=Join[listQuad[[i]],{LP[[i]]}];
i++;];

(*
For[i=1,i\[LessEqual]Length[LP],
listBi[[i]]=getFull/@Union[getBlank/@listBi[[i]]];
listTri[[i]]=getFull/@Union[getBlank/@listTri[[i]]];
listQuad[[i]]=getFull/@Union[getBlank/@listQuad[[i]]];
i++;];
*)
For[i=1,i<=Length[LP],
listBi[[i]]=Union[getBlank/@listBi[[i]]];
listTri[[i]]=Union[getBlank/@listTri[[i]]];
listQuad[[i]]=Union[getBlank/@listQuad[[i]]];
i++;];

listBi=listBi /. A_[{b__}][{c__}]->A /. A_[{b__}]->A;
listTri=listTri /. A_[{b__}][{c__}]->A /. A_[{b__}]->A;
listQuad=listQuad /. A_[{b__}][{c__}]->A /. A_[{b__}]->A;
listTri2=listTri2 /. A_[{b__}][{c__}]->A /. A_[{b__}]->A;

For[i=1,i<=Length[PART[S]],
Muij[a___,getFull[getBlank[PART[S][[i]]]] /. subGCRule[1],b___]=0;
Yijk[a___,getFull[getBlank[PART[S][[i]]]] /. subGCRule[1],b_]=0;
i++;];
For[i=1,i<=Length[PART[F]],
Bij[a___,getFull[getBlank[PART[F][[i]]]]  /. subGCRule[1],b___]=0;
Aijk[a___,getFull[getBlank[PART[F][[i]]]] /. subGCRule[1],b___]=0;
Lijkl[a___,getFull[getBlank[PART[F][[i]]]]/. subGCRule[1],b___]=0;
Yijk[a_,b_,getFull[getBlank[PART[F][[i]]]]/. subGCRule[1]]=0;
i++;];

SA`Doc`EndEntry[];
];

makeDeltaNS[particle_,skip_]:=Block[{i,j,k,res,temp,ind},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"makeDeltaNS\",\nInitializationCell->True]\)";
SA`Doc`Info = "This function returns a delta function for the gauge indices of a given field.";
SA`Doc`Input={"particle"->"The considered particle","skip"->"Indices which should not be included"};
SA`Doc`GenerateEntry[];

If[AtomQ[particle],SA`Doc`Return[1]];
ind=List@@particle;
If[Head[particle[[0]]]=!=Symbol,ind=Join[ind,List@@particle[[0]]];];
ind=DeleteCases[Intersection[Flatten[ind]],skip,3];
res=1;
For[i=1,i<=Length[ind],
(*If[ind[[i]]=!=generation,
res=res*Delta[ind[[i]]/.subGC[1]/.subIndFinal[1,1],ind[[i]]/.subGC[2]/.subIndFinal[2,2]];,
res=res*Kronecker[ind[[i]]/.subGC[1]/.subIndFinal[1,1],ind[[i]]/.subGC[2]/.subIndFinal[2,2]];
];*)
res=res*Delta[ind[[i]]/.subGC[1]/.subIndFinal[1,1],ind[[i]]/.subGC[2]/.subIndFinal[2,2]];
i++;];
SA`Doc`Return[res];
];


(* ::Input::Initialization:: *)
InitGaugeGroupInfo[varGens_]:=Block[{sumCS,sumCF,sumDS,sumDF,i,j,k,sumU1,delta,sum,gNr2,pos},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"InitGaugeGroupInfo\",\nInitializationCell->True]\)";
SA`Doc`Info = "This routine performs the group theory needed for the RGE calculation: generator functions 'tA', 'ThS' for fermions and scalars are initialised and all necessary combinations of Dynkin and Casimir indices showing up in the RGEs are calculated.";
SA`Doc`Input={"VarGens"->"A list of fields whose generations should be treated as variabel"};
SA`Doc`GenerateEntry[];

SA`ListGC={};
For[i=1,i<=Length[Gauge],
SA`ListGC=Join[SA`ListGC,{{{i,i},{Gauge[[i,4]],1}}}];
If[Gauge[[i,2]]=!=U[1],
SA`CheckU1[i]=0;
GUTren[i]=1;,
SA`CheckU1[i]=1;
];
For[j=1,j<=Length[Gauge],
If[Gauge[[i,2]]=!=U[1],
If[i===j,
SA`gCoup[i,j]=Gauge[[i,4]];,
SA`gCoup[i,j]=0;
];,
If[Gauge[[j,2]]=!=U[1]  || (NoU1Mixing===True && i!=j), 
SA`gCoup[i,j]=0;,
If[i===j,
SA`gCoup[i,j]=Gauge[[i,4]];,
SA`ListGC=Join[SA`ListGC,{{{i,j},{GaugesU1[i,j],1}}}];
SA`gCoup[i,j]=GaugesU1[i,j];
];
];
];
j++;];
i++;];

SA`CasimirRGE[a_[{b__}],gauge_]:=SA`CasimirRGE[a,gauge];
SA`CasimirRGE[a_[{b__}][{c__}],gauge_]:=SA`CasimirRGE[a,gauge];

Generator[SU[2],{1}][a__]=Sig[a]/2;  
For[i=1,i<=Length[Gauge],
For[j=1,j<=Length[PART[Sc]],
If[Gauge[[i,2]]===U[1],
sum =SA`DynL[getBlankSF[PART[Sc][[j]]],i]*Gauge[[i,4]]*GUTren[i];
For[gNr2=1,gNr2<=AnzahlGauge,
If[Gauge[[gNr2,2]]===U[1] && gNr2!= i && NoU1Mixing=!=True,
sum +=  SA`DynL[getBlankSF[PART[Sc][[j]]],gNr2]GaugesU1[gNr2,i]*GUTren[gNr2];
];
gNr2++;];
SA`CasimirRGE[getBlankSF[PART[Sc][[j]]],i]=sum^2; (* Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[Sc][[j]]],i]; *)
SA`DynkinRGE[getBlankSF[PART[Sc][[j]]],i]=sum^2; (* Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[Sc][[j]]],i]; *)
SA`CasimirRGE[getBlankSF[PART[Sc][[j+1]]],i]=sum^2; (* Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[Sc][[j+1]]],i]; *)
SA`DynkinRGE[getBlankSF[PART[Sc][[j+1]]],i]=sum^2; (* Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[Sc][[j+1]]],i]; *)


ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]= I  sum*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];
ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=- I  sum*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];
ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;,

SA`CasimirRGE[getBlankSF[PART[Sc][[j]]],i]=Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[Sc][[j]]],i];
SA`DynkinRGE[getBlankSF[PART[Sc][[j]]],i]=Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[Sc][[j]]],i];
SA`CasimirRGE[getBlankSF[PART[Sc][[j+1]]],i]=Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[Sc][[j+1]]],i];
SA`DynkinRGE[getBlankSF[PART[Sc][[j+1]]],i]=Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[Sc][[j+1]]],i];


If[Gauge[[i,5]]===False,
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=- 1/2 Gauge[[i,4]]*( Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]-conj[ Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];

ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]= I  1/2 Gauge[[i,4]]*( Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]+conj[ Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];

ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=-  I  1/2 Gauge[[i,4]]*( Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]+conj[ Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];

ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]= -  1/2 Gauge[[i,4]]*( Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]-conj[ Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sc][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];,

(* for broken groups *)
pos=Position[SFields,Select[subComplexScalarsList,FreeQ[#,PART[Sc][[j]]/.{A_[{a__}][{b__}]->A,A_[{a__}]->A}]==False&][[-1,1]]][[1,1]];
If[ GeneratorBrokenScalar[i,pos]===0,
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]= 0;
ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]= 0;,
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=- 1/2 Gauge[[i,4]]*( GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]-conj[ GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];

ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]= I  1/2 Gauge[[i,4]]*( GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]+conj[ GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];

ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=-  I  1/2 Gauge[[i,4]]*( GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]+conj[ GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];

ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]= -  1/2 Gauge[[i,4]]*( GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]-conj[ GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sc][[j]],Gauge[[i,3]]];
];
];
];
tA[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,a_,lor_]=0;
tA[i,a_, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,lor_]=0;
tA[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,a_,lor_]=0;
tA[i,a_, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,lor_]=0;
For[k=1,k<=Length[PART[Sc]],
If[k=!=j,
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[k]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[k]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[k+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[k+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
];
k=k+2];

For[k=1,k<=Length[PART[Sr]],
ThS[i, PART[Sc][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sr][[k]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sc][[j+1]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sr][[k]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sr][[k]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
ThS[i, PART[Sr][[k]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sc][[j+1]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
k++];


j=j+2;];
i++;];

For[i=1,i<=Length[Gauge],
For[j=1,j<=Length[PART[Sr]],
SA`CasimirRGE[getBlankSF[PART[Sr][[j]]],i]=Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[Sr][[j]]],i];
SA`DynkinRGE[getBlankSF[PART[Sr][[j]]],i]=Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[Sr][[j]]],i];


If[Gauge[[i,2]]===U[1],
ThS[i, PART[Sr][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sr][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;,
If[Gauge[[i,5]]===False,
ThS[i, PART[Sr][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sr][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=- 1/2 Gauge[[i,4]]( Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sr][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]-conj[ Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[Sr][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sr][[j]],Gauge[[i,3]]];,
pos=Position[SFields,Select[subComplexScalarsList,FreeQ[#,PART[Sr][[j]]/.{A_[{a__}][{b__}]->A,A_[{a__}]->A}]==False&][[-1,1]]][[1,1]];
If[GeneratorBrokenScalar[i,pos]===0,
ThS[i, PART[Sr][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sr][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;,
ThS[i, PART[Sr][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sr][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=- 1/2 Gauge[[i,4]] ( GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]-conj[ GeneratorBrokenScalar[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]])*makeDeltaNS[PART[Sr][[j]],Gauge[[i,3]]];
]];
];
tA[i, PART[Sr][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,a_,lor_]=0;
tA[i,a_, PART[Sr][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,lor_]=0;
For[k=1,k<=Length[PART[Sr]],
If[k=!=j,
ThS[i, PART[Sr][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[Sr][[k]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
];
k=k+1];
j=j+1;];

For[j=1,j<=Length[PART[F]],
If[Gauge[[i,2]]===U[1],
sum =SA`DynL[getBlankSF[PART[F][[j]]],i]*Gauge[[i,4]]*GUTren[i];
For[gNr2=1,gNr2<=AnzahlGauge,
If[Gauge[[gNr2,2]]===U[1] && gNr2!= i && NoU1Mixing=!=True,
sum +=  SA`DynL[getBlankSF[PART[F][[j]]],gNr2]GaugesU1[gNr2,i]*GUTren[gNr2];
];
gNr2++;];

SA`CasimirRGE[getBlankSF[PART[F][[j]]],i]=sum^2;(* Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[F][[j]]],i]; *)
SA`DynkinRGE[getBlankSF[PART[F][[j]]],i]=sum^2; (* Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[F][[j]]],i]; *)


tA[i, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[F][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=   sum*makeDeltaNS[PART[F][[j]],Gauge[[i,3]]]; 
(*
tA[i, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[F][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=   Gauge[[i,4]]* SA`DynL[getBlankSF[PART[F][[j]]],i]*GUTren[i]*makeDeltaNS[PART[F][[j]],Gauge[[i,3]]]; *),

SA`CasimirRGE[getBlankSF[PART[F][[j]]],i]=Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[F][[j]]],i];
SA`DynkinRGE[getBlankSF[PART[F][[j]]],i]=Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[F][[j]]],i];

If[Gauge[[i,5]]===False,
tA[i, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[F][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=    Gauge[[i,4]]* Generator[Gauge[[i,2]],SA`DynL[getBlankSF[PART[F][[j]]],i]][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]*makeDeltaNS[PART[F][[j]],Gauge[[i,3]]];,
pos=Position[FFields,PART[F][[j]]][[1,1]];
If[ GeneratorBrokenFermion[i,pos]===0,
tA[i, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[F][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=    0;,
tA[i, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[F][[j]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=    Gauge[[i,4]]* GeneratorBrokenFermion[i,pos][lor,Gauge[[i,3]]/.subGC[1] /. subIndFinal[1,1],Gauge[[i,3]]/.subGC[2]/. subIndFinal[2,2]]*makeDeltaNS[PART[F][[j]],Gauge[[i,3]]];
];
];
];
For[k=1,k<=Length[PART[F]],
ThS[i, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,a_,lor_]=0;
ThS[i,a_, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,lor_]=0;
If[k=!=j,
tA[i, PART[F][[j]]/. subGC[1]  /. subIndFinal[1,1] /. subRule ,PART[F][[k]]/. subGC[2]  /. subIndFinal[2,2] /. subRule,lor_]=0;
];
k++;];
j++;];


i++;];



For[i=1,i<=AnzahlGauge,
If[Gauge[[i,2]]=!=U[1],
SA`DynkinS[rep,i]=
Sum[If[FreeQ[varGens/. subComplexScalarsList,getBlankSF[PART[S][[n1]]]],1,nG[varGens[[Position[varGens/.subComplexScalarsList,getBlankSF[PART[S][[n1]]]][[1,1]]]]]/getGen[varGens[[Position[varGens/.subComplexScalarsList,getBlankSF[PART[S][[n1]]]][[1,1]]]]]]SA`MulFactor[getBlankSF[PART[S][[n1]]],i]Gauge[[i,4]]^2 SA`Dynkin[getBlankSF[PART[S][[n1]]],i],{n1,1,Length[PART[S]]}];
SA`CasimirS[rep,i]=
Sum[If[FreeQ[varGens/. subComplexScalarsList,getBlankSF[PART[S][[n1]]]],1,nG[varGens[[Position[varGens/.subComplexScalarsList,getBlankSF[PART[S][[n1]]]][[1,1]]]]]/getGen[varGens[[Position[varGens/.subComplexScalarsList,getBlankSF[PART[S][[n1]]]][[1,1]]]]]]SA`MulFactor[getBlankSF[PART[S][[n1]]],i]Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[S][[n1]]],i],{n1,1,Length[PART[S]]}];
SA`DynkinF[rep,i]=
Sum[If[FreeQ[varGens,getBlankSF[PART[F][[n1]]]],1,nG[getBlankSF[PART[F][[n1]]]]/getGen[getBlankSF[PART[F][[n1]]]]]SA`MulFactor[getBlankSF[PART[F][[n1]]],i]Gauge[[i,4]]^2SA`Dynkin[getBlankSF[PART[F][[n1]]],i],{n1,1,Length[PART[F]]}];
SA`CasimirF[rep,i]=
Sum[If[FreeQ[varGens,getBlankSF[PART[F][[n1]]]],1,nG[getBlankSF[PART[F][[n1]]]]/getGen[getBlankSF[PART[F][[n1]]]]]SA`MulFactor[getBlankSF[PART[F][[n1]]],i]Gauge[[i,4]]^2 SA`Casimir[getBlankSF[PART[F][[n1]]],i],{n1,1,Length[PART[F]]}];

For[j=1,j<=AnzahlGauge,
SA`CasimirDynkinS[rep,i,j]=
Sum[SA`MulFactor[getBlankSF[PART[S][[n1]]],i] Gauge[[i,4]]^2SA`Dynkin[getBlankSF[PART[S][[n1]]],i] SA`CasimirRGE[getBlankSF[PART[S][[n1]]],j],{n1,1,Length[PART[S]]}];
SA`CasimirDynkinF[rep,i,j]=
Sum[SA`MulFactor[getBlankSF[PART[F][[n1]]],i] Gauge[[i,4]]^2SA`Dynkin[getBlankSF[PART[F][[n1]]],i] SA`CasimirRGE[getBlankSF[PART[F][[n1]]],j],{n1,1,Length[PART[F]]}];
j++;];,

For[k=1,k<=AnzahlGauge,
If[Gauge[[k,2]]===U[1],
SA`DynkinS[rep,i,k]=
( Sum[If[FreeQ[varGens/. subComplexScalarsList,getBlankSF[PART[S][[n1]]]],1,nG[varGens[[Position[varGens/.subComplexScalarsList,getBlankSF[PART[S][[n1]]]][[1,1]]]]]/getGen[varGens[[Position[varGens/.subComplexScalarsList,getBlankSF[PART[S][[n1]]]][[1,1]]]]]] SA`MulFactor[getBlankSF[PART[S][[n1]]],i]Sum[SA`gCoup[gNr1,i] GUTren[gNr1] If[SA`CheckU1[gNr1]==1,SA`DynL[getBlankSF[PART[S][[n1]]],gNr1],0],{gNr1,1,AnzahlGauge}] Sum[SA`gCoup[gNr1,k]  GUTren[gNr1] If[SA`CheckU1[gNr1]==1,SA`DynL[getBlankSF[PART[S][[n1]]],gNr1],0],{gNr1,1,AnzahlGauge}],{n1,1,Length[PART[S]]}]);
SA`CasimirS[rep,i,k]=SA`DynkinS[rep,i,k];

SA`DynkinF[rep,i,k]=
Sum[If[FreeQ[varGens,getBlankSF[PART[F][[n1]]]],1,nG[getBlankSF[PART[F][[n1]]]]/getGen[getBlankSF[PART[F][[n1]]]]]SA`MulFactor[getBlankSF[PART[F][[n1]]],i]Sum[SA`gCoup[gNr1,i] GUTren[gNr1] If[SA`CheckU1[gNr1]==1,SA`DynL[getBlankSF[PART[F][[n1]]],gNr1],0],{gNr1,1,AnzahlGauge}] *Sum[SA`gCoup[gNr1,k] GUTren[gNr1] If[SA`CheckU1[gNr1]==1,SA`DynL[getBlankSF[PART[F][[n1]]],gNr1],0],{gNr1,1,AnzahlGauge}],{n1,1,Length[PART[F]]}];
SA`CasimirF[rep,i,k]=SA`DynkinF[rep,i,k];

If[i==k, (* Has to be improved to get the full kinetic mixing at 2-loop! *)
SA`DynkinS[rep,i]=SA`DynkinS[rep,i,k];
SA`DynkinF[rep,i]=SA`DynkinF[rep,i,k];
];
(*
For[j=1,j\[LessEqual]AnzahlGauge,
SA`CasimirDynkinS[rep,i,j,k]=
Sum[SA`MulFactor[getBlankSF[PART[S][[n1]]],i]Sum[SA`gCoup[i,gNr2]GUTren[gNr2]If[SA`CheckU1[gNr2]\[Equal]1,SA`DynL[getBlankSF[PART[S][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] Sum[SA`gCoup[gNr2,k]GUTren[k]If[SA`CheckU1[gNr2]\[Equal]1,SA`DynL[getBlankSF[PART[S][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] SA`CasimirRGE[getBlankSF[PART[S][[n1]]],j],{n1,1,Length[PART[S]]}];
SA`CasimirDynkinF[rep,i,j,k]=
Sum[SA`MulFactor[getBlankSF[PART[F][[n1]]],i]Sum[SA`gCoup[i,gNr2]GUTren[gNr2]If[SA`CheckU1[gNr2]\[Equal]1,SA`DynL[getBlankSF[PART[F][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] Sum[SA`gCoup[gNr2,k]GUTren[k]If[SA`CheckU1[gNr2]\[Equal]1,SA`DynL[getBlankSF[PART[F][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] SA`CasimirRGE[getBlankSF[PART[F][[n1]]],j],{n1,1,Length[PART[F]]}];
j++;];
*)
For[j=1,j<=AnzahlGauge,
SA`CasimirDynkinS[rep,i,j,k]=
Sum[SA`MulFactor[getBlankSF[PART[S][[n1]]],i]Sum[SA`gCoup[gNr2,i]GUTren[gNr2]If[SA`CheckU1[gNr2]==1,SA`DynL[getBlankSF[PART[S][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] Sum[SA`gCoup[gNr2,k]GUTren[gNr2]If[SA`CheckU1[gNr2]==1,SA`DynL[getBlankSF[PART[S][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] SA`CasimirRGE[getBlankSF[PART[S][[n1]]],j],{n1,1,Length[PART[S]]}];
SA`CasimirDynkinF[rep,i,j,k]=
Sum[SA`MulFactor[getBlankSF[PART[F][[n1]]],i]Sum[SA`gCoup[gNr2,i]GUTren[gNr2]If[SA`CheckU1[gNr2]==1,SA`DynL[getBlankSF[PART[F][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] Sum[SA`gCoup[gNr2,k]GUTren[gNr2]If[SA`CheckU1[gNr2]==1,SA`DynL[getBlankSF[PART[F][[n1]]],gNr2],0],{gNr2,1,AnzahlGauge}] SA`CasimirRGE[getBlankSF[PART[F][[n1]]],j],{n1,1,Length[PART[F]]}];
j++;];
];
k++;];

];
i++;];

For[i=1,i<=Length[PART[S]],
For[gNr1=1,gNr1<= AnzahlGauge,
For[gNr2=1,gNr2<=AnzahlGauge,
If[Gauge[[gNr1,2]]===U[1] && Gauge[[gNr2,2]]===U[1],
sum=0;
For[j=1,j<=Length[PART[F]],
sum+=SA`MulFactor[getBlankSF[PART[F][[j]]],gNr1]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[S][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[F][[j]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]SA`DynL[getBlankSF[PART[S][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]*SA`DynL[getBlankSF[PART[F][[j]]],n1],0],{n1,1,AnzahlGauge}];
j++;];
SA`CasimirSDynkinF[rep,getBlank[PART[S][[i]]],gNr1,gNr2]=sum /. SA`gCoup->0;

sum=0;
For[j=1,j<=Length[PART[S]],
sum+=SA`MulFactor[getBlankSF[PART[S][[j]]],gNr1]*
Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[S][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[S][[j]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]SA`DynL[getBlankSF[PART[S][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]*SA`DynL[getBlankSF[PART[S][[j]]],n1],0],{n1,1,AnzahlGauge}];
j++;];
SA`CasimirSDynkinS[rep,getBlank[PART[S][[i]]],gNr1,gNr2]=sum;,
SA`CasimirSDynkinF[rep,_,gNr1,gNr2]=0;
SA`CasimirFDynkinF[rep,_,gNr1,gNr2]=0;
SA`CasimirSDynkinS[rep,_,gNr1,gNr2]=0;
SA`CasimirFDynkinS[rep,_,gNr1,gNr2]=0;
];
gNr2++;];
gNr1++;];
i++;];

For[i=1,i<=Length[PART[F]],
For[gNr1=1,gNr1<= AnzahlGauge,
For[gNr2=1,gNr2<= AnzahlGauge,
If[Gauge[[gNr1,2]]===U[1] && Gauge[[gNr2,2]]===U[1],
sum=0;
For[j=1,j<=Length[PART[F]],
sum+=SA`MulFactor[getBlankSF[PART[F][[j]]],gNr1]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[F][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[F][[j]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]SA`DynL[getBlankSF[PART[F][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]*SA`DynL[getBlankSF[PART[F][[j]]],n1],0],{n1,1,AnzahlGauge}];
j++;];
SA`CasimirFDynkinF[rep,getBlank[PART[F][[i]]],gNr1,gNr2]=sum;

sum=0;
For[j=1,j<=Length[PART[S]],
sum+=SA`MulFactor[getBlankSF[PART[S][[j]]],gNr1]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[F][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr1]SA`DynL[getBlankSF[PART[S][[j]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]SA`DynL[getBlankSF[PART[F][[i]]],n1],0],{n1,1,AnzahlGauge}]*Sum[If[Gauge[[n1,2]]===U[1],GUTren[n1]SA`gCoup[n1,gNr2]*SA`DynL[getBlankSF[PART[S][[j]]],n1],0],{n1,1,AnzahlGauge}];
j++;];
SA`CasimirFDynkinS[rep,getBlank[PART[F][[i]]],gNr1,gNr2]=sum;
];
gNr2++;];
gNr1++;];
i++;];

(* Change to non SU(N) !! *)

For[k=1,k<=AnzahlGauge,
SA`Dynkin[k] = Gauge[[k,4]]^2 Gauge[[k,2,1]];
If[Gauge[[k,2]]=!=U[1],
SA`Casimir[k] = Gauge[[k,4]]^2 Gauge[[k,2,1]];
dimAdj[k] = Gauge[[k,2,1]]^2-1;,
SA`Casimir[k]=0;
dimAdj[k]=1;
];
gc[k]=Gauge[[k,4]];
k++;];

SA`Doc`EndEntry[];
];




(* ::Input::Initialization:: *)
CalcBetaFunctionsNonSUSY[type_,fields_,filename_,filename3I_,twoloop_,Simp_]:=Block[{i,ii,factor,res,subNonZero,coup,SaveArray={},SaveArray3I={},bfcalculated={}},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"CalcBetaFunctionsNonSUSY\",\nInitializationCell->True]\)";
SA`Doc`Info = "This routine combines the different information derived so far and calculates the full expressions for the beta-functions. This is done via the following steps: \n
1) The external fields are inserted in the generic beta-functions\ n
2) It is checked which combinaiton of external indices corresponds to a non-vanishing coupling. The numerical coefficient in front of the coupling fixes the normalisation of the beta-function \n
3) The chosen indices are inserted in the beta-function\n
4) 'Expand Term' is called to find all possible field combinations (i.e. this is equivalent to generating all possible Feynman diagrams) \n
5) 'CalcRGEValue' is used to simplify the expression by summing over internal indices, etc. \n
6) The results are stored in the given array as well as written to external files." ;
SA`Doc`Input={"type"->"The generic type of the coupling","fields"->"The external fields for all couplings","filename"->"The file name to save the results","filename3I"->"The file name to save the results using a second approach to treat parameters with three-indices","twoloop"->"Including two-loop?","Simp"->"Simplify the results?"};
SA`Doc`GenerateEntry[];

Clear[bF1L,bF2L];
kF=1/2; 

Switch[type,
LIJKL,  Print[StyleForm["Calculate Beta Functions for scalar 4-point interactions","Section",FontSize->12]];,
YIJK,  Print[StyleForm["Calculate Beta Functions for Yukawa-like interactions","Section",FontSize->12]];,
MFIJ, Print[StyleForm["Calculate Beta Functions for bilinear Fermion interactions","Section",FontSize->12]];,
TIJK, Print[StyleForm["Calculate Beta Functions for scalar 3-point interactions","Section",FontSize->12]];,
MSIJ, Print[StyleForm["Calculate Beta Functions for bilinear scalar interactions","Section",FontSize->12]];,
GAUGE, Print[StyleForm["Calculate Beta Functions for Gauge Couplings","Section",FontSize->12]];,
VEVI, Print[StyleForm["Calculate Beta Functions for VEVs","Section",FontSize->12]];,
GSIJ, Print[StyleForm["Calculate anomalous dimensions of scalars","Section",FontSize->12]];,
GFIJ, Print[StyleForm["Calculate anomalous dimensions of fermions","Section",FontSize->12]];,
GSijHat, Print[StyleForm["Calculate hat(gamma) for running VEVs","Section",FontSize->12]];
];

If[Length[fields]>0,
DynamicProgressRGE[type]=0;
Print["   Calculating ",Dynamic[DynamicProgressRGE[type]],"/",Length[fields],".(",Dynamic[DynamicCoupProgess[type]],")"];,
Print["   Nothing to do."];
];

For[i=1,i<=Length[fields],
DynamicProgressRGE[type]=i;
(*
If[Head[Expand[fields[[i,2,1]]]]===Plus,
res=GetNonZeroEntriesNS[Expand[fields[[i,2,1]]][[1]] /. Delta[gen1,a_]\[Rule]1 /. Delta[a___,gen2,b___]\[Rule]1,fields[[i,1]]];,
res=GetNonZeroEntriesNS[fields[[i,2,1]] /. Delta[gen1,a_]\[Rule]1 /. Delta[a___,gen2,b___]\[Rule]1,fields[[i,1]]];
];
*)

If[type=!=MSIJ && type=!=LIJKL && type=!=TIJK,
If[FreeQ[fields[[i]],Rule],
res=GetNonZeroEntriesNS[fields[[i,2]], type,fields[[i,1]]];
subNonZero=res[[1]];,
subNonZero={};
];,
subNonZero={};
];

SuperpositionNeeded=False;

UseSymmASymm=True;
Switch[type,
LIJKL,
	SuperpositionNeeded=True;
	coup=fields[[i,2,2]]/. conj[x_]->x;
	factor=fields[[i,2,1]];
	betaFunction=0;
	betaFunction2L=0;
	For[ii=1,ii<=Length[fields[[i,1]]],
	If[FreeQ[bfcalculated,getBlank/@fields[[i,1,ii,2,2]]],
	bF1L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=BetaFunctionLijkl1LnonSUSY[fields[[i,1,ii,2,2]]];
	If[twoloop,bF2L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=BetaFunctionLijkl2LnonSUSY[fields[[i,1,ii,2,2]]];,bF2L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=0;];
	bfcalculated=Join[bfcalculated,{getBlank/@fields[[i,1,ii,2,2]]}];
	];
	betaFunction+=Expand[1/factor* CalcRGEValue[CalcDelta[fields[[i,1,ii,1]](bF1L[fields[[i,1,ii,2,2]]]/. SA`gCoup[a__]->0 )/.fields[[i,1,ii,2,1]]],False]];
If[twoloop,
betaFunction2L+=Expand[1/factor* CalcRGEValue[CalcDelta[fields[[i,1,ii,1]](bF2L[fields[[i,1,ii,2,2]]]/. SA`SubIgnore2L /. 0[a__]->0/. YcYYcY4[a__]->ExpandTermNS[YcYYcY4func[a]])/.fields[[i,1,ii,2,1]]] ,False]];
];
	factor=1;
	ii++;];,
YIJK,
	coup=Yijk[fields[[i,1,1]]/.subGC[1],fields[[i,1,2]]/.subGC[2],fields[[i,1,3]]/.subGC[3]];
	betaFunction=BetaFunctionYijk1LnonSUSY[fields[[i,1]]/. subNonZero ];
	If[twoloop,betaFunction2L=BetaFunctionYijk2LnonSUSY[fields[[i,1]]/. subNonZero ];,betaFunction2L=0];,
MFIJ,
	coup=Muij[fields[[i,1,1]]/.subGC[1],fields[[i,1,2]]/.subGC[2]];
	betaFunction=BetaFunctionMFij1LnonSUSY[fields[[i,1]]/. subNonZero ];
	If[twoloop,betaFunction2L=BetaFunctionMFij2LnonSUSY[fields[[i,1]]/. subNonZero ];,betaFunction2L=0];,
TIJK,
(*	coup=Aijk[fields[[i,1,1]]/.subGC[1],fields[[i,1,2]]/.subGC[2],fields[[i,1,3]]/.subGC[3]];
	betaFunction=BetaFunctionTijk1LnonSUSY[fields[[i,1]]/. subNonZero ];
	If[twoloop,betaFunction2L=BetaFunctionTijk2LnonSUSY[fields[[i,1]]/. subNonZero ];,betaFunction2L=0]; *)
SuperpositionNeeded=True;
	coup=fields[[i,2,2]]/. conj[x_]->x;
	factor=fields[[i,2,1]];
	betaFunction=0;
	betaFunction2L=0;
	For[ii=1,ii<=Length[fields[[i,1]]],
	If[FreeQ[bfcalculated,getBlank/@fields[[i,1,ii,2,2]]],
	bF1L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=BetaFunctionTijk1LnonSUSY[fields[[i,1,ii,2,2]]];
		If[twoloop,bF2L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=BetaFunctionTijk2LnonSUSY[fields[[i,1,ii,2,2]]];,bF2L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=0;];
	bfcalculated=Join[bfcalculated,{getBlank/@fields[[i,1,ii,2,2]]}];
	];
	betaFunction+=Expand[1/factor* CalcRGEValue[CalcDelta[fields[[i,1,ii,1]](bF1L[fields[[i,1,ii,2,2]]]/. SA`gCoup[a__]->0 )/.fields[[i,1,ii,2,1]]],False]];
If[twoloop,
betaFunction2L+=Expand[1/factor* CalcRGEValue[CalcDelta[fields[[i,1,ii,1]](bF2L[fields[[i,1,ii,2,2]]]/. SA`SubIgnore2L /. 0[a__]->0/. YcYYcY4[__]->0)/.fields[[i,1,ii,2,1]]] ,False]];
];
	factor=1;
	ii++;];,
MSIJ,
(*
	coup=Bij[fields[[i,1,1]]/.subGC[1],fields[[i,1,2]]/.subGC[2]]/. conj[x_]\[Rule]x;
	betaFunction=BetaFunctionMSij1LnonSUSY[fields[[i,1]]/. subNonZero ];
	If[twoloop,betaFunction2L=BetaFunctionMSij2LnonSUSY[fields[[i,1]]/. subNonZero ];,betaFunction2L=0]; *)
SuperpositionNeeded=True;
	coup=fields[[i,2,2]]/. conj[x_]->x;
	factor=fields[[i,2,1]];
	betaFunction=0;
	betaFunction2L=0;
	For[ii=1,ii<=Length[fields[[i,1]]],
	If[FreeQ[bfcalculated,getBlank/@fields[[i,1,ii,2,2]]],
	bF1L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=BetaFunctionMSij1LnonSUSY[fields[[i,1,ii,2,2]]];
	If[twoloop,bF2L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=BetaFunctionMSij2LnonSUSY[fields[[i,1,ii,2,2]]];,bF2L[fields[[i,1,ii,2,2]]/.Flatten[Table[subGCRule[iii]/.subGC[iii] ,{iii,1,4}]]]=0;];
	bfcalculated=Join[bfcalculated,{getBlank/@fields[[i,1,ii,2,2]]}];
	];
	betaFunction+=Expand[1/factor* CalcRGEValue[CalcDelta[fields[[i,1,ii,1]](bF1L[fields[[i,1,ii,2,2]]]/. SA`gCoup[a__]->0 )/.fields[[i,1,ii,2,1]]],False]];
If[twoloop,
betaFunction2L+=Expand[1/factor* CalcRGEValue[CalcDelta[fields[[i,1,ii,1]](bF2L[fields[[i,1,ii,2,2]]]/. SA`SubIgnore2L /. 0[a__]->0/. YcYYcY4[__]->0)/.fields[[i,1,ii,2,1]] ],False]];
];
	factor=1;
	ii++;];,
GAUGE,
	coup=fields[[i,2,1]];
	betaFunction=BetaFunctionGauge1LnonSUSY[fields[[i,1]]];
	If[twoloop,betaFunction2L=BetaFunctionGauge2LnonSUSY[fields[[i,1]]];,betaFunction2L=0];,
VEVI,
	coup=VEVi[fields[[i,1,1]]/.subGC[1]];
	betaFunction=BetaFunctionVEVi1LnonSUSY[fields[[i,1,1]]];
	If[twoloop,betaFunction2L=BetaFunctionVEVi2LnonSUSY[fields[[i,1,1]]];,betaFunction2L=0];,
GSIJ,
	coup={fields[[i,1,1]],fields[[i,1,2]]};
	betaFunction=GammaSij1L[fields[[i,1,1]],fields[[i,1,2]]];
	If[twoloop,betaFunction2L=GammaSij2L[fields[[i,1,1]],fields[[i,1,2]]];,betaFunction2L=0];,
GFIJ,
	coup={fields[[i,1,1]],fields[[i,1,2]]};
	betaFunction=GammaFij1L[fields[[i,1,1]],fields[[i,1,2]]];
	If[twoloop,betaFunction2L=GammaFij2L[fields[[i,1,1]],fields[[i,1,2]]];,betaFunction2L=0];,
GSijHat,
	coup={fields[[i,1,1]],fields[[i,1,2]]};
	betaFunction=GammaSijHat1L[fields[[i,1,1]],fields[[i,1,2]]];
	If[twoloop,betaFunction2L=GammaSijHat2L[fields[[i,1,1]],fields[[i,1,2]]];,betaFunction2L=0];
 ];
betaFunction2LSaveA=betaFunction2L;
If[SuperpositionNeeded=!=True,
If[type===GFIJ || type===GSIJ || type===GSijHat,
factor=1;,
factor=DeleteCases[DeleteCases[fakeFac coup /. CGCBroken[{a___}]:>CGCBroken[{a}/. Conj->conj]/. subNonZero,_?(MemberQ[{gen1,gen2,gen3,gen4},#]&),10] /. A_[{}]->1 /. A_[]->1 /. Conj[x_]->x,_?(MemberQ[Transpose[parameters][[1]],#]&),10] /. fakeFac ->1;
];
];

DynamicCoupProgess[type]=1/factor*CalcRGEValue[coup /. subNonZero  /. Delta[a__]->1 /.epsTensor[a__]->1/. InvMat[a__][b__]->1] ;
If[SuperpositionNeeded=!=True,
betaFunction =Expand[1/factor* CalcRGEValue[CalcDelta[betaFunction /. subNonZero /. SA`gCoup[a__]->0] ,False]];
betaFunction2L = Expand[1/factor* CalcRGEValue[CalcDelta[betaFunction2L /. SA`SubIgnore2L /. 0[a__]->0 /. subNonZero /. YcYYcY4[__]->0],False]];
];
If[type===VEVI,
betaFunction2LSave=betaFunction2L;
betaFunction=-betaFunction /. Delta2->Delta /. Delta[a_[{b1_,d1___}][{c1__}],a_[{b2_,d2___}][{c2__}]]->Delta[a[{b1}],a[{b2}]]/. Delta[a__]->0;
betaFunction2L=-betaFunction2L /. Delta2->Delta /. Delta[a_[{b1_,d1___}][{c1__}],a_[{b2_,d2___}][{c2__}]]->Delta[a[{b1}],a[{b2}]]/. Delta[a__]->0;,
betaFunction=betaFunction /. Delta2[a__]->1 /. Kronecker[a_,a_]->1;
betaFunction2L=betaFunction2L /. Delta2[a__]->1/. Kronecker[a_,a_]->1;
];

subGenInd={}; nrInd=1;
torep={};
If[type===GFIJ || type===GSIJ || type===GSijHat,
subGenInd={gen1->i1,gen2->i2};,
If[SuperpositionNeeded=!=True,
For[j=1,j<=Length[fields[[i,1]]],
If[NumericQ[fields[[i,1,j]]]===False,
If[getGen[fields[[i,1,j]],ALL]>1,
If[(getGen[fields[[i,1,j]],ALL]<99 ) || (getGenAux[getBlank[fields[[i,1,j]] ]] >1),
 torep=Join[torep,{Select[{gen1,gen2,gen3,gen4},(FreeQ[fields[[i,1,j]],#]==False)&][[1]]}]; 
(* torep=Join[torep,Select[{gen1,gen2,gen3,gen4},(FreeQ[fields[[i,1,j]],#]\[Equal]False)&][[Count[Take[fields[[i,1]],{1,j-1}],fields[[i,1,j]]]+1]]]; *)
];
];
];
j++;]; ,
For[j=1,j<=Length[fields[[i,1,1,2,2]]],
If[NumericQ[fields[[i,1,1,2,2,j]]]===False,
If[getGen[fields[[i,1,1,2,2,j]],ALL]>1,
If[(getGen[fields[[i,1,1,2,2,j]],ALL]<99 ) || (getGenAux[getBlank[fields[[i,1,1,2,2,j]] ]] >1),
 torep=Join[torep,{Select[{gen1,gen2,gen3,gen4},(FreeQ[fields[[i,1,1,2,2,j]],#]==False)&][[1]]}]; 
(* torep=Join[torep,Select[{gen1,gen2,gen3,gen4},(FreeQ[fields[[i,1,j]],#]\[Equal]False)&][[Count[Take[fields[[i,1]],{1,j-1}],fields[[i,1,j]]]+1]]]; *)
];
];
];
j++;]; 
];

torep=DeleteCases[torep,{}];
(* torep=Sort[torep]; *)
For[nrInd=1,nrInd<=Length[torep],
If[Depth[CalcRGEValue[coup /. subNonZero  /. Delta[a__]->1 /.epsTensor[a__]->1/. InvMat[a__][b__]->1]]>=3,
subGenInd=Join[subGenInd,{torep[[nrInd]]->ToExpression["i"<>ToString[Position[CalcRGEValue[coup /. subNonZero  /. Delta[a__]->1 /.epsTensor[a__]->1/. InvMat[a__][b__]->1]  ,torep[[nrInd]]][[1,2]]]]}];,
subGenInd=Join[subGenInd,{torep[[nrInd]]->ToExpression["i"<>ToString[Position[CalcRGEValue[coup /. subNonZero  /. Delta[a__]->1 /.epsTensor[a__]->1/. InvMat[a__][b__]->1] ,torep[[nrInd]]][[1,1]]]]}];
];
(* subGenInd=Join[subGenInd,{torep[[nrInd]]->ToExpression["i"<>ToString[nrInd]]}]; *)
nrInd++;
];
];

If[Simp===True && ThreeIndexParametersInvolved=!=True,
SaveArray = Join[SaveArray,{{1/factor*CalcRGEValue[coup /. subNonZero  /. Delta[a__]->1 /.epsTensor[a__]->1/. InvMat[a__][b__]->1] /. subGenInd ,Simplify[betaFunction/. subGenInd//.Conj->conj],Simplify[ betaFunction2L/. subGenInd//.Conj->conj]}}];,
SaveArray = Join[SaveArray,{{1/factor*CalcRGEValue[coup /. subNonZero/. Delta[a__]->1 /.epsTensor[a__]->1/. InvMat[a__][b__]->1] /. subGenInd ,betaFunction/. subGenInd//.Conj->conj , betaFunction2L/. subGenInd//.Conj->conj }}];
];
i++;];
DynamicCoupProgess[type]="All Done";

Put[SaveArray,ToFileName[$sarahCurrentRGEDir,filename<>".m"]];

Clear[kF];

If[ThreeIndexParametersInvolved===True,
MakeMatrixMul=True;
For[i=1,i<=Length[SaveArray],
SaveArray3I=Join[SaveArray3I,{{SaveArray[[i,1]],Split3IndexParameter[SaveArray[[i,2]]]//.Conj->conj,Split3IndexParameter[SaveArray[[i,3]]]//.Conj->conj}}];
i++;];
MakeMatrixMul=False;
Put[SaveArray3I,ToFileName[$sarahCurrentRGEDir,filename3I<>".m"]];
];

Switch[type,
LIJKL, BetaLijkl=SaveArray; BetaLijkl3I=SaveArray3I;,
YIJK, BetaYijk=SaveArray; BetaYijk3I=SaveArray3I;,
MFIJ,BetaMFij=SaveArray; BetaMFij3I=SaveArray3I;
               BetaMuij=BetaMFij; BetaMuij3I=BetaMFij3I;,
TIJK,BetaTijk=SaveArray; BetaTijk3I=SaveArray3I;,
MSIJ,BetaBij=SaveArray; BetaBij3I=SaveArray3I;,
M2IJ,Betam2ij=SaveArray; Betam2ij3I=SaveArray3I;,
GAUGE,BetaGauge=SaveArray; BetaGauge3I=SaveArray3I;,
VEVI,BetaVEV=SaveArray; BetaVEV3I=SaveArray3I;,
GSIJ,Gammaij=SaveArray; Gammaij3I=SaveArray3I;
            GSij=SaveArray; GSij3I=SaveArray3I;,
GFIJ,GFij=SaveArray; GFij3I=SaveArray3I;,
GSijHat,GammaijHat=SaveArray; Gammaij3IHat=SaveArray3I;
];
UseSymmASymm=False;

SA`Doc`EndEntry[];
];


GetNonZeroEntriesNS[term_,type_,fields_]:=Block[{sub={},pos,i,j,fac=1,epsilons, deltas, indnr,coup,coup2,searchedcoup,indtab,Found},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"GetNonZeroEntriesNS\",\nInitializationCell->True]\)";
SA`Doc`Info = "This function returns a combination of gauge indices which lead to a non-zero value for a given interaction. For instance, if the interaction invovles Delta[col1,col2] a valid result might be (col1->1,col2->1)";
SA`Doc`Input={"term"->"The considered term","type"->"The generic type of the interaction","fields"->"The involved particles"};
SA`Doc`GenerateEntry[];

Switch[type,
LIJKL,
	 coup=Lijkl[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3],fields[[4]]/.subGC[4] ];
	coup2=Lijkl[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3]/.SA`subImagToReal,fields[[4]]/.subGC[4]/.SA`subImagToReal ];,
YIJK,
	coup=Yijk[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3]];
	coup2=I Yijk[fields[[1]]/.subGC[1]/.SA`subImagToReal,fields[[2]]/.subGC[2]/.SA`subImagToReal,fields[[3]]/.subGC[3]/.SA`subImagToReal];,
MFIJ,
	coup=Muij[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2]];,
TIJK,
	coup=Aijk[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3]];,
MSIJ,
	coup=Bij[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2]];,
GAUGE,
	SA`Doc`Return[{{},1}];
	coup=fields[[2,1]];,
VEVI,
	coup=VEVi[fields[[1]]/.subGC[1]];,
GSIJ,
	coup=1;,
GFIJ,
	coup=1;,
GSijHat,
	coup=1;
 ];
indtab={};

For[i=1,i<=Length[fields],
If[Head[fields[[i]]]=!=Symbol,
indnr=ToExpression[StringTake[ToString[(fields[[i]] /. {A_[{a___}][{b__}]->{a,b},A_[{a___}]->{a}})[[1]]],-1]];
ind=getIndRGENS[getBlankSF[fields[[i]]],indnr];
For[j=1,j<=Length[ind],
indtab=Join[indtab,{Table[ind[[j,1]]->k,{k,1,ind[[j,3]]}]}];
j++;];
];
i++;];
If[type===GSIJ || type===GSijHat ||type===GFIJ ,
If[indtab==={},
SA`Doc`Return[{{1->1},1}];,
SA`Doc`Return[{indtab[[1]],1}];
];
];
searchedcoup=Select[Transpose[parameters][[1]],(FreeQ[term/. CGCBroken[a___][b___]->CGCBroken[b],#]==False)&];
If[indtab==={},SA`Doc`Return[{{1->1},term[[1]] /. searchedcoup[[1]]->1 }];];
indtab=Tuples[indtab];

searchedcoup=Select[Transpose[parameters][[1]],(FreeQ[term/. CGCBroken[a___][b___]->CGCBroken[b],#]==False)&];
coup=coup/.Reverse/@Flatten[Table[subIndFinal[iii,iii],{iii,1,4}]];
i=1;
Found=False;
While[Found==False && i <= Length[indtab],
res=(coup/.indtab[[i]]);
If[res=!=0,
If[Select[Transpose[parameters][[1]],(FreeQ[res/. CGCBroken[a___][b___]->CGCBroken[b],#]==False)&]===searchedcoup,
Found=True;,
i++;
];,
i++;];
];


If[Found==True,
SA`Doc`Return[{indtab[[i]],(term[[1]]*term[[2]] /. indtab[[i]]/.(indtab[[i]]/.Flatten[Table[subIndFinal[iii,iii],{iii,1,4}]])  /. Delta[a__]->1  /. searchedcoup[[1]][a__]->1 /. searchedcoup[[1]]->1)}];,
SA`Doc`Return[{}];
];
];

(*
GetNonZeroEntriesNSAll[term_,type_,fields_]:=Block[{sub={},pos,i,j,fac=1,epsilons,deltas,indnr,coup,coup2,searchedcoup,indtab,Found},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "GetNonZeroEntriesNSAll";
SA`Doc`Info = "";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

Switch[type,LIJKL,coup=Lijkl[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3],fields[[4]]/.subGC[4]];
coup2=Lijkl[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3]/.SA`subImagToReal,fields[[4]]/.subGC[4]/.SA`subImagToReal];,YIJK,coup=Yijk[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3]];,MFIJ,coup=Muij[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2]];,TIJK,coup=Aijk[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2],fields[[3]]/.subGC[3]];,MSIJ,coup=Bij[fields[[1]]/.subGC[1],fields[[2]]/.subGC[2]];,GAUGE,SA`Doc`Return[{{},1}];
coup=fields[[2,1]];,VEVI,coup=VEVi[fields[[1]]/.subGC[1]];,GSij,coup=1;,GSijHat,coup=1;];
indtab={};
For[i=1,i\[LessEqual]Length[fields],If[Head[fields[[i]]]=!=Symbol,indnr=ToExpression[StringTake[ToString[(fields[[i]]/.{A_[{a___}][{b__}]\[Rule]{a,b},A_[{a___}]\[Rule]{a}})[[1]]],-1]];
ind=getIndRGENS[getBlankSF[fields[[i]]],indnr];
For[j=1,j\[LessEqual]Length[ind],indtab=Join[indtab,{Table[ind[[j,1]]\[Rule]k,{k,1,ind[[j,3]]}]}];
j++;];];
i++;];
indtab=Tuples[indtab/.Flatten[Table[subIndFinal[i,i],{i,1,4}],1]];

SA`Doc`Return[indtab];
];

CheckPairsInsertions[list_,coups_,rcoup_]:=Block[{i,sums,lAins},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "CheckPairsInsertions";
SA`Doc`Info = "";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

lAins={};
For[i=1,i\[LessEqual]Length[list],
inds=GetNonZeroEntriesNSAll[list[[i,2,1]],LIJKL,list[[i,1]]];
For[j=1,j\[LessEqual]Length[inds],
If[(list[[i,2,1]]/.inds[[j]])=!=0,
lAins=Join[lAins,{{list[[i,1]],inds[[j]],list[[i,2,1]]/.inds[[j]]}}];];
j++;];
i++;];
sums={};
For[i=1,i<Length[lAins],
For[j=i+1,j\[LessEqual]Length[lAins],
sums=Join[sums,{{{lAins[[i,1]],lAins[[i,2]],lAins[[j,1]],lAins[[j,2]],P},{lAins[[i,3]]+lAins[[j,3]],1}}}];
sums=Join[sums,{{{lAins[[i,1]],lAins[[i,2]],lAins[[j,1]],lAins[[j,2]],M},{lAins[[i,3]]-lAins[[j,3]],1}}}];
j++;];
i++;];
sums=Select[sums,FreeQ[#,rcoup]\[Equal]False&];
sums=Select[sums,FreeQcoups[#,coups]\[Equal]{}&];

If[sums=!={},
sums=sums[[1]];

If[sums[[1,5]]===M,
sums={{Join[{1},sums[[1,1]]],Join[{-1},sums[[1,3]]]},{{sums[[1,2]]},sums[[2]]}};,
sums={{Join[{1},sums[[1,1]]],Join[{1},sums[[1,3]]]},{{sums[[1,2]]},sums[[2]]}};
];
];
SA`Doc`Return[sums];
(* Return[Select[sums,FreeQcoups[#,coups]\[Equal]{}&]]; *)
];


CheckPairs[list_,coups_,rcoup_]:=Block[{i,sums},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "CheckPairs";
SA`Doc`Info = "";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

sums={};
For[i=1,i<Length[list],
For[j=i+1,j\[LessEqual]Length[list],
sums=Join[sums,{{{list[[i,1]],list[[j,1]],P},{list[[i,2,1]]+list[[j,2,1]],list[[i,2,2]]}}}];
sums=Join[sums,{{{list[[i,1]],list[[j,1]],M},{list[[i,2,1]]-list[[j,2,1]],list[[i,2,2]]}}}];
j++;];
i++;];
sums=Select[sums,FreeQ[#,rcoup]\[Equal]False&];
SA`Doc`Return[Select[sums,FreeQcoups[#,coups]\[Equal]{}&]];
];
*)
FreeQcoups[list_,coups_]:=Select[coups,FreeQ[list,#]==False&];

CheckForNecessarySuperpositions:=Block[{i,j,ii,temp,quartics,cubics,bilinears,res,res2},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"CheckForNecessarySuperpositions\",\nInitializationCell->True]\)";
SA`Doc`Info = "This function checks if it is necessary to take the superposition of fields in order to get the beta-function of a coupling. For instance, looking at a left-right model there are two Yukawa couplings:

 YQ1 Phi.QLbar.QR  + YQ2 conj[Phi].QLbar.QR 

After splitting Phi in it's real components as it has to be done for the RGE calculation one gets

(YQ1+YQ2) phi.QLbar.QR + (YQ1-YQ2) sigma.QLbar.QR

This is the origin for the problem, because now YQ1 and YQ2 are no longer separated. Thus, to get the RGEs for the couplings SARAH calculates the beta-functions for both sets of external particles and uses

beta(YQ1) = 1/2 (beta(phi.QLbar.QR) +  beta(sigma.QLbar.QR))
beta(YQ2) = 1/2 (beta(phi.QLbar.QR) -  beta(sigma.QLbar.QR))

to disentangle the running. Similar effects appear for instance for the quartic couplings in THDMs models.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

If[SA`SSSSlist=!={},
quartics=Transpose[SA`SSSSlist][[2]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1;
lA4oneNew={};
For[i=1,i<=Length[quartics],
temp=Select[Select[Select[lA4 ,FreeQ[#,quartics[[i]] /. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]==False&],FreeQ[#,If[conj[quartics[[i]]]===quartics[[i]],notnecessary,conj[quartics[[i]]]] /. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]==True&],FreeQcoups[#,DeleteCases[quartics,quartics[[i]]]/. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]=={}&];

If[temp=!={},res=GetNonZeroEntriesNS[temp[[1,2]], LIJKL,temp[[1,1]]];];
If[temp=!={} && res=!={},
subNonZero=res[[1]];
lA4oneNew=Join[lA4oneNew,{{{{1,{subNonZero,temp[[1,1]]}}},{res[[2]],quartics[[i]]}}}];,
res=BruteForceSuperpositionNew[SA`SSSSlist[[i]],quartics[[i]],LIJKL,quartics];
If[res==={},
RGEs::StillEntangled="Can't disentangle the contributions to the running of ``";
Message[RGEs::StillEntangled,quartics[[i]]];,
lA4oneNew=Join[lA4oneNew,{res}]];
];
i++;];


lA4oneNewFlat={};
For[i=1,i<=Length[lA4oneNew],
For[ii=1,ii<=Length[lA4oneNew[[i,1]]],
lA4oneNewFlat=Join[lA4oneNewFlat,{lA4oneNew[[i,1,ii,2,2]]}];
ii++;];
i++;];


lA4oneBeta=lA4oneNew;,
lA4oneNew={};
lA4oneBeta={};
lA4oneNewFlat={};
];


If[SA`SSSlist=!={},
cubics=Transpose[SA`SSSlist][[2]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1;
lA3oneNew={};
For[i=1,i<=Length[cubics],
temp=Select[Select[Select[lA3 ,FreeQ[#,cubics[[i]] /. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]==False&],FreeQ[#,If[conj[cubics[[i]]]===cubics[[i]],notnecessary,conj[cubics[[i]]]] /. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]==True&],FreeQcoups[#,DeleteCases[cubics,cubics[[i]]]/. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]=={}&];

If[temp=!={},res=GetNonZeroEntriesNS[temp[[1,2]], TIJK,temp[[1,1]]];];
If[temp=!={} && res=!={},
subNonZero=res[[1]];
lA3oneNew=Join[lA3oneNew,{{{{1,{subNonZero,temp[[1,1]]}}},{res[[2]],cubics[[i]]}}}];,
res=BruteForceSuperpositionNew[SA`SSSlist[[i]],cubics[[i]],TIJK,cubics];
If[res==={},
RGEs::StillEntangled="Can't disentangle the contributions to the running of ``";
Message[RGEs::StillEntangled,cubics[[i]]];,
lA3oneNew=Join[lA3oneNew,{res}]];
];
i++;];


lA3oneNewFlat={};
For[i=1,i<=Length[lA3oneNew],
For[ii=1,ii<=Length[lA3oneNew[[i,1]]],
lA3oneNewFlat=Join[lA3oneNewFlat,{lA3oneNew[[i,1,ii,2,2]]}];
ii++;];
i++;];


lA3oneBeta=lA3oneNew;,
lA3oneNew={};
lA3oneBeta={};
lA3oneNewFlat={};
];

If[SA`SSlist=!={},
bilinears=Transpose[SA`SSlist][[2]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1;
lA2oneNew={};
For[i=1,i<=Length[bilinears],
If[conj[bilinears[[i]]]=!=bilinears[[i]],
temp=Select[Select[Select[lA2 ,FreeQ[#,bilinears[[i]] /. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]==False&],FreeQ[#,If[conj[bilinears[[i]]]===bilinears[[i]],notnecessary,conj[bilinears[[i]]]] /. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]==True&],FreeQcoups[#,DeleteCases[bilinears,bilinears[[i]]]/. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]=={}&];,
temp=Select[Select[lA2 ,FreeQ[#,bilinears[[i]] /. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]==False&],FreeQcoups[#,DeleteCases[bilinears,bilinears[[i]]]/. A_[gen1,___]->A/. A_[gen2,___]->A/. A_[gen3,___]->A]=={}&];
];

If[temp=!={},res=GetNonZeroEntriesNS[temp[[1,2]], MSIJ,temp[[1,1]]];];
If[temp=!={} && res=!={},
subNonZero=res[[1]];
lA2oneNew=Join[lA2oneNew,{{{{1,{subNonZero,temp[[1,1]]}}},{res[[2]],bilinears[[i]]}}}];,
res=BruteForceSuperpositionNew[SA`SSlist[[i]],bilinears[[i]],MSIJ,bilinears];
If[res==={},
RGEs::StillEntangled="Can't disentangle the contributions to the running of ``";
Message[RGEs::StillEntangled,bilinears[[i]]];,
lA2oneNew=Join[lA2oneNew,{res}]];
];
i++;];


lA2oneNewFlat={};
For[i=1,i<=Length[lA2oneNew],
For[ii=1,ii<=Length[lA2oneNew[[i,1]]],
lA2oneNewFlat=Join[lA2oneNewFlat,{lA2oneNew[[i,1,ii,2,2]]}];
ii++;];
i++;];


lA2oneBeta=lA2oneNew;,
lA2oneNew={};
lA2oneBeta={};
lA2oneNewFlat={};
];

SA`Doc`EndEntry[];
];


MakeDummyListRGEsNonSUSY:=Block[{i,j},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"MakeDummyListRGEsNonSUSY\",\nInitializationCell->True]\)";
SA`Doc`Info = "This creates dummy lists with only zeros for the beta-functions. These are used in the SPheno output if the RGE calculation/output is turned off.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

OnlyDummy=True;
NeededAnaDimsForVEVs={};
UseSymmASymm=True;
ParticlesBefore=Particles[RGEs];
PARTsave[F]=PART[F];
PART[F]=DeleteCases[FFields,0,3]/.conj[x_]->x;
PART[S]=SplitComplexScalars[DeleteCases[SFields,0,3]];
PART[Sc]=PART[S][[1]];
PART[Sr]=PART[S][[2]];
PART[S]=Join[PART[S][[1]],PART[S][[2]]];
LPName=Flatten[{PART[F],PART[S]}]/.A_[{b__}][{c__}]->A/.A_[{b__}]->A/.conj[x_]->x;
PARTALL[F]=PART[F]/.conj[x_]->x;
LP=LPName;
SA`ListGC={};
For[i=1,i<=Length[Gauge],SA`ListGC=Join[SA`ListGC,{{{i,i},{Gauge[[i,4]],1}}}];
If[Gauge[[i,2]]=!=U[1],SA`CheckU1[i]=0;
GUTren[i]=1;,SA`CheckU1[i]=1;];
For[j=1,j<=Length[Gauge],If[Gauge[[i,2]]=!=U[1],If[i===j,SA`gCoup[i,j]=Gauge[[i,4]];,SA`gCoup[i,j]=0;];,If[Gauge[[j,2]]=!=U[1]|| NoU1Mixing===True,SA`gCoup[i,j]=0;,If[i===j,SA`gCoup[i,j]=Gauge[[i,4]];,SA`ListGC=Join[SA`ListGC,{{{i,j},{GaugesU1[i,j],1}}}];
SA`gCoup[i,j]=GaugesU1[i,j];];];];
j++;];
i++;];
GenerateCouplingLists;
GenerateCouplingVariables[False,False,False];
BetaYijk=Table[{If[Head[lW3one[[i,2,1]]]===Plus,lW3one[[i,2,1,1]],lW3one[[i,2,1]]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1 /. A_[b__]+A_[c__]->A,0,0},{i,1,Length[lW3one]}];
BetaMFij=Table[{lW2one[[i,2,1]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1/. A_[b__]+A_[c__]->A,0,0},{i,1,Length[lW2one]}];
BetaMuij=BetaMFij;
BetaLijkl=Table[{If[Head[lA4one[[i,2,1]]]===Plus,lA4one[[i,2,1,1]],lA4one[[i,2,1]]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1/. A_[b__]+A_[c__]->A,0,0},{i,1,Length[lA4one]}];
BetaTijk=Table[{If[Head[lA3one[[i,2,1]]]===Plus,lA3one[[i,2,1,1]],lA3one[[i,2,1]]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1/. A_[b__]+A_[c__]->A,0,0},{i,1,Length[lA3one]}];
BetaBij=Table[{lA2one[[i,2,1]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1/. A_[b__]+A_[c__]->A,0,0},{i,1,Length[lA2one]}];
BetaGauge=Table[{SA`ListGC[[i,2,1]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1/. A_[b__]+A_[c__]->A,0,0},{i,1,Length[SA`ListGC]}];
BetaVEV=Table[{SA`ListVEVi[[i,2,1]]/.{Delta[a__]->1,epsTensor[a__]->1,CG[a__][b__]->1,InvMat[a__][b__]->1,gt1->i1,gt2->i2,gt3->i3,gt4->i4}/.x_?NumericQ->1/. A_[b__]+A_[c__]->A,0,0},{i,1,Length[SA`ListVEVi]}];

BetaYijk=Select[BetaYijk,#[[1]]=!=1&];
BetaLijkl=Select[BetaLijkl,#[[1]]=!=1&];
BetaMFij=Select[BetaMFij,#[[1]]=!=1&];
BetaMuij=Select[BetaMuij,#[[1]]=!=1&];
BetaBij=Select[BetaBij,#[[1]]=!=1&];


UseSymmASymm=False;

SA`Doc`EndEntry[];
];

BruteForceSuperpositionNew[coupling_,parameter_,type_,allpar_]:=Block[{tempList,temp,subindnames,fields,indnr,ind,indtab,i,Found,j,indlist,allCombinations,listcoefficients,tempterm,subcoeffs,acoeff,res,solall,nonzerosuper,pos,resout},
SA`Doc`File = "Package/RGEs/nonSUSYrges.nb";
SA`Doc`Name = "\!\(\*
StyleBox[\"BruteForceSuperpositionNew\",\nInitializationCell->True]\)";
SA`Doc`Info = "This routine tries to find the necessary superpositions to disentangle the beta-functions of parameters which involve the same external states. The approach is to generate an equation with arbitrary coefficients in front of the contributions from different fields and use Mathematica's SolveAlways to find the coefficients which disentangle. For instance, one might have that two field combinations result in (L1 + L2) and (L1 - L2). This would give the following equaiton to find the coefficients to get L1: \n
	a1 (L1 + L2) + a2 (L1 - L2) = L1 \n
The SolveAlways function of Mathematica would find the result (a1->1/2, a2->1/2). ";
SA`Doc`Input={"coupling"->"The currently considered coupling","parameter"->"The parameter which should be extracted","type"->"The generic type of the coupling","allpar"->"All other parameters (which shouldn't show up in the result)"};
SA`Doc`GenerateEntry[];


subindnames=Flatten[Table[Reverse/@ReleaseHold[subIndizesFinal/. number1->i /. number2->i],{i,1,4}]];
tempList=List@@Expand[Times@@coupling[[1]]/. subComplexScalarsSum /. subRealSplitted]/. x_?NumericQ->1 /. Times->List /. subindnames;
fields=coupling[[1]]/. conj[x_]->x;
indtab={};
indlist={};
For[i=1,i<=Length[fields],
If[Head[fields[[i]]]=!=Symbol,
indnr=ToExpression[StringTake[ToString[(fields[[i]] /. {A_[{a___}][{b__}]->{a,b},A_[{a___}]->{a}})[[1]]],-1]];
ind=getIndRGENS[getBlankSF[fields[[i]]],indnr];
indlist=Join[indlist,ind];
For[j=1,j<=Length[ind],
indtab=Join[indtab,{Table[ind[[j,1]]->k,{k,1,ind[[j,3]]}]}];
j++;];
];
i++;];
indtab=Tuples[indtab]/. subindnames;


allCombinations={};
allCombinationsPure={};
For[i=1,i<=Length[tempList],
For[j=1,j<=Length[indtab],
allCombinations=Join[allCombinations,{{indtab[[j]],tempList[[i]]/. indtab[[j]]}}];
allCombinationsPure=Join[allCombinationsPure,{{indtab[[j]],tempList[[i]]}}];
j++;];
i++;];

listcoefficients={};
subcoeffs={};
For[i=1,i<=Length[allCombinations],
listcoefficients=Join[listcoefficients,{{caa[i],allCombinationsPure[[i]]}}];
subcoeffs=Join[subcoeffs,{Times@@allCombinations[[i,2]]->caa[i]}];
i++;];
acoeff=Table[caa[i],{i,1,Length[allCombinations]}];

Switch[type,
LIJKL,
tempterm=Expand[Plus@@(tempList/. {b_,c_,d_,e_}:>b c d e Lijkl[b,c,d,e]/;Head[b]=!=List   /. Lijkl[a__]->0 )];,
TIJK,
tempterm=Expand[Plus@@(tempList/. {b_,c_,d_}:>b c d  Aijk[b,c,d]/;Head[b]=!=List   /. Aijk[a__]->0 )];,
MSIJ,
tempterm=Expand[Plus@@(tempList/. {b_,c_}:>b c  Bij[b,c]/;Head[b]=!=List   /. Bij[a__]->0 )];
];

For[ii=1,ii<=Length[indlist],
tempterm=ReleaseHold[Hold[Sum[tempterm,{AXvar,AXstart,AXend}]]/.{AXvar->indlist[[ii,1]],AXstart->indlist[[ii,2]],AXend->indlist[[ii,3]]}];
ii++;];

LinEqu=tempterm/.subcoeffs;


solall=SolveAlways[LinEqu==parameter,Flatten[{allpar,Conj/@allpar}]];

res={};
For[i=1,i<=Length[solall[[1]]],
sel=Select[acoeff,FreeQ[solall[[1,i,2]],#]==False&];
res=Join[res,Table[sel[[iii]]->0,{iii,1,Length[sel]}]];
res=Join[res,{solall[[1,i,1]]->(solall[[1,i,2]]/.res)}];
i++;];
res=Intersection[res];
nonzerosuper=Select[res,#[[2]]=!=0&];
resout={};
For[i=1,i<=Length[nonzerosuper],
pos=Position[listcoefficients,nonzerosuper[[i,1]]][[1,1]];
resout=Join[resout,{{nonzerosuper[[i,2]],listcoefficients[[pos,2]]}}];
i++;];
resout={resout,{1,parameter}};

If[(LinEqu/.res)=!=parameter,
RGEs::StillEntangled="Can't disentangle the contributions to the running of ``";
Message[RGEs::StillEntangled,parameter];
Print["Check: ",LinEqu/.res];
SA`Doc`Return[];
];

SA`Doc`Return[resout];

];

