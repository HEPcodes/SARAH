(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
GetMassesAndRotationMatrices[tadpar_]:=Block[{i,j,eig,def,angles,ev},
Print["Calculate Expressions for Masses and Rotation Matrices"];

realVar=Join[realVar,Select[$ParametrisationUV,FreeQ[realVar,#[[1]]]==False && Head[#[[2]]]=!=Times&] /. Rule[a_,b_]:>b];
realVar=Join[realVar,
Cases[$AssumptionsMatching,Greater[_,_Real|_Integer]|Less[_Real|_Integer,_]|Element[_,Reals]] /. Greater[a_,_Real|_Integer]:>a/.Less[_Real|_Integer,a_]:>a/.Element[a_,Reals]:>a];

If[tadpar==={},
TreeLevelTadpoleSolutions={};,
TreeLevelTadpoleSolutions=Solve[TadpoleEquations[EWSB]==0,tadpar][[1]];
];
Off[Part::pkspec1];
(* Check conventions for rotation matrices! *)
ReplacementRotationMatrices={};
ReplacementMasses={};
For[i=1,i<=Length[PART[S]],
If[getGen[PART[S][[i,1]]]===1,
eig=Simplify[Sqrt[Limit[TreeMass[PART[S][[i,1]],CurrentStates] /. TreeLevelTadpoleSolutions /.$ParametrisationUV /.$SimplificationsMatching,epsUV->0]],$AssumptionsMatching];
ReplacementMasses=Join[ReplacementMasses,{Mass[PART[S][[i,1]]]->eig}];
If[eig==0,
$SimplificationsMatching=Join[$SimplificationsMatching,{M[PART[S][[i,1]]]->0}];
];
Set[M[PART[S][[i,1]]],eig];,
eig=Eigensystem[Limit[Simplify[MassMatrix[PART[S][[i,1]]] /. TreeLevelTadpoleSolutions /.RXi[__]->0 //.$ParametrisationUV /.$SimplificationsMatching],epsUV->0]];
If[Length[Intersection[eig[[1]]]]===1,
eig=Reverse/@eig; (* in order to get the identity matrix for trivial mixing *)
];
ReplacementRotationMatrices=Join[ReplacementRotationMatrices,{getMixingMatrix[PART[S][[i,1]]][a__Integer]->(Simplify[#,$AssumptionsMatching]&/@Normalize/@eig[[2]])[[a]]}];
If[eig[[2]]===IdentityMatrix[getGen[PART[S][[i,1]]]],
$SimplificationsMatching=Join[$SimplificationsMatching,{getMixingMatrix[PART[S][[i,1]]]->Delta}];
];
ReplacementMasses=Join[ReplacementMasses,{Mass[PART[S][[i,1]]][a_Integer]->Simplify[Sqrt/@eig[[1]],$AssumptionsMatching][[a]]}]; 
Set[M[PART[S][[i,1]]],Simplify[Sqrt/@eig[[1]],$AssumptionsMatching]];
If[Intersection[eig[[1]]]==={0},
$SimplificationsMatching=Join[$SimplificationsMatching,{M[PART[S][[i,1]][a_]]->0}]
];
];
i++;];

For[i=1,i<=Length[PART[F]],
If[getGen[PART[F][[i,1]]]===1,
eig=Simplify[Limit[TreeMass[PART[F][[i,1]],CurrentStates] /. TreeLevelTadpoleSolutions /.$ParametrisationUV /.$SimplificationsMatching,epsUV->0],$AssumptionsMatching];
ReplacementMasses=Join[ReplacementMasses,{Mass[PART[F][[i,1]]]->eig}];
Set[M[PART[F][[i,1]]],eig];
If[eig==0,
$SimplificationsMatching=Join[$SimplificationsMatching,{M[PART[F][[i,1]]]->0}];
];,
If[FreeQ[massless,PART[F][[i,1]]]==False,
(* ReplacementMasses=Join[ReplacementMasses,{Mass[PART[F][[i,1]]][a_]\[Rule]0}]; *)
$SimplificationsMatching=Join[$SimplificationsMatching,{M[PART[F][[i,1]]][a_]->0}];,
Switch[Length[Intersection[getMixingMatrix[PART[F][[i,1]]]]],
1,
eig=Eigensystem[Limit[Simplify[MassMatrix[PART[F][[i,1]]] /. TreeLevelTadpoleSolutions /.RXi[__]->0 //.$ParametrisationUV /.$SimplificationsMatching],epsUV->0]];
If[Length[Intersection[eig[[1]]]]===1,
eig=Reverse/@eig; (* in order to get the identity matrix for trivial mixing *)
];
ReplacementRotationMatrices=Join[ReplacementRotationMatrices,{getMixingMatrix[PART[F][[i,1]]][[1]][a__Integer]->(Simplify[#,$AssumptionsMatching]&/@Normalize/@eig[[2]])[[a]]}];
If[eig[[2]]===IdentityMatrix[getGen[PART[F][[i,1]]]],
$SimplificationsMatching=Join[$SimplificationsMatching,{getMixingMatrix[PART[F][[i,1]]][[1]]->Delta}];
];
 ReplacementMasses=Join[ReplacementMasses,{Mass[PART[F][[i,1]]][a_Integer]->(Simplify[#,$AssumptionsMatching]&/@eig[[1]])[[a]]}];
Set[M[PART[F][[i,1]]],Simplify[#,$AssumptionsMatching]&/@eig[[1]]];
If[Intersection[eig[[1]]]==={0},
$SimplificationsMatching=Join[$SimplificationsMatching,{M[PART[F][[i,1]][a_]]->0}]
];,
2,
eig=SingularValueDecomposition[Limit[Simplify[MassMatrix[PART[F][[i,1]]] /. TreeLevelTadpoleSolutions /.RXi[__]->0 //.$ParametrisationUV],epsUV->0]]/. Conjugate->conj//.$ParametrisationUV  /.$SimplificationsMatching;
ReplacementRotationMatrices=Join[ReplacementRotationMatrices,{getMixingMatrix[PART[F][[i,1]]][[1]][a__Integer]->(Simplify[#,$AssumptionsMatching]&/@Normalize/@eig[[1]])[[a]]}];
ReplacementRotationMatrices=Join[ReplacementRotationMatrices,{getMixingMatrix[PART[F][[i,1]]][[2]][a__Integer]->(Simplify[#,$AssumptionsMatching]&/@Normalize/@eig[[3]])[[a]]}];
If[eig[[1]]===IdentityMatrix[getGen[PART[F][[i,1]]]],
$SimplificationsMatching=Join[$SimplificationsMatching,{getMixingMatrix[PART[F][[i,1]]][[1]]->Delta}];
];
If[eig[[3]]===IdentityMatrix[getGen[PART[F][[i,1]]]],
$SimplificationsMatching=Join[$SimplificationsMatching,{getMixingMatrix[PART[F][[i,1]]][[2]]->Delta}];
];
 ReplacementMasses=Join[ReplacementMasses,{Mass[PART[F][[i,1]]][a_Integer]->Table[Simplify[eig[[2]][[j,j]],$AssumptionsMatching],{j,1,Length[eig[[2]]]}][[a]]}]; 
Set[M[PART[F][[i,1]]],Table[Simplify[eig[[2]][[j,j]],$AssumptionsMatching],{j,1,Length[eig[[2]]]}]];
If[Intersection[Table[eig[[2]][[j,j]],{j,1,Length[eig[[2]]]}]]==={0},
$SimplificationsMatching=Join[$SimplificationsMatching,{M[PART[F][[i,1]][a_]]->0}]
];
];
];
];
i++;];

For[i=1,i<=Length[SA`RotationMatricesGaugeSector],
If[AssociatedMixingAngles[SA`RotationMatricesGaugeSector[[i]]]=!={},
angles=AssociatedMixingAngles[SA`RotationMatricesGaugeSector[[i]]];
def=Select[DEFINITION[Last[NameOfStates]][GaugeSector],FreeQ[#,SA`RotationMatricesGaugeSector[[i]]]==False&][[1]];
eig=Limit[Eigensystem[Simplify[MassMatrix[def[[2,1]]] /.RXi[__]->0 //.$ParametrisationUV]],epsUV->0];
ev=Normalize/@eig[[2]] /.Abs[x_]->x;
For[j=1,j<=Length[angles],
$SimplificationsMatching=Join[$SimplificationsMatching,{angles[[j]]->(getEntryParameter[angles[[j]],DependenceSPheno]/.{SA`RotationMatricesGaugeSector[[i]]->ev}/.A_[b__Integer]:>A[[b]])}];
j++;];
];
i++;];

ExtractExternalIndices[ReplacementRotationMatrices];

On[Part::pkspec1];
];


(*PerformMatching[InputFile_,read_]:=Block[{i},

Get[InputFile];

RunSARAH[$UVModel,read];

Print[StyleForm["Calculation Matching conditions for scalar couplings","Section",FontSize\[Rule]12]];

InitMatching[read];

(*
M[bar[x_]]:=M[x];
M[conj[x_]]:=M[x];
*)

MatchLO;
MatchNLO;

]; *)

MatchLO:=Block[{i,res},
SetOptions[EFTcoupLO,
ExcludeFields->If[Head[$ExcludeFieldsMatching]===List,$ExcludeFieldsMatching,{}],
Debug->False,
SimplifyResults->True
];
Print["  Tree-Level Matching: ",Dynamic[DynamicLO],"/",Length[$MatchingConditions]," (",Dynamic[DynamicLOname],")"];
For[i=1,i<=Length[$MatchingConditions],
DynamicLO=i;
DynamicLOname=$MatchingConditions[[i,1]];
res=$MatchingConditions[[i,2]] /. Dot->TMP/.TMP[a__]:>EFTcoupLO[{a}];
Set[EFTLO[$MatchingConditions[[i,1]]],res];
SA`MatchingResultsLO=Join[SA`MatchingResultsLO,{{$MatchingConditions[[i,1]],res}}];
i++;];
];


MatchNLO:=Block[{i,res},
Clear[CACHE];
SetOptions[EFTcoupNLO,
InternalPatterns->{},
Topologies->{},
ExcludeTopologies->{OffdiagonalWFRs},
Debug->False,
Caching->True,
LoopReplace->AnalyticLoopFunctions,
IncludeTreeLevel->True,
ShiftMSDR->Automatic,
LoopFactor->1/(4Pi)^2,
GaugeThresholds->True,
ShowProgress->True,
SimplifyResults->True,
ExcludeFields->If[Head[$ExcludeFieldsMatching]===List,$ExcludeFieldsMatching,{}]
];
Print["  One-Loop Matching: ",Dynamic[DynamicNLO],"/",Length[$MatchingConditions]," (",Dynamic[DynamicNLOname],")"];
For[i=1,i<=Length[$MatchingConditions],
DynamicNLO=i;
DynamicNLOname=$MatchingConditions[[i,1]];
res=$MatchingConditions[[i,2]] /. Dot->TMP/.TMP[a__]:>EFTcoupNLO[{a}];
SA`MatchingResultsNLO=Join[SA`MatchingResultsNLO,{{$MatchingConditions[[i,1]],res}}];
Set[EFTNLO[$MatchingConditions[[i,1]]],res];
i++;];
];


RunSARAH[model_,read_]:=Block[{output},
    Start[model];
    ModelOutput[EWSB,VerticesForLoops->True,ReadLists->read];
MakeCouplingLists;
];

InitMatching[opt___]:=InitMatchingFunc[ReadLists/.{opt}/.Options[InitMatching],Assumptions/.{opt}/.Options[InitMatching],Parametrisation /.{opt}/. Options[InitMatching],SolveTadpoles/.{opt}/. Options[InitMatching],InputFile/. {opt}/.Options[InitMatching]];
InitMatchingFunc[read_,assumptions_,par_,tadpoles_,input_]:=Block[{},
Print[StyleForm["Initialise Matching Routines","Section",FontSize->12]];
(*clear used variables*)
ClearAll[B0,C0,D0,dB0,dB1,Generic1LoopAmp];
TreeLevelTadpoleSolutions={};
(* Load generic loop functions from previous calculation *)
Get[ToFileName[{$sarahPackageDir,"Matching"},"Generic1LoopEffectiveScalarAmplitudes.m"]];
Get[ToFileName[{$sarahPackageDir,"Matching"},"Generic1LoopEffectiveScalarCouplings.m"]];
Get[ToFileName[{$sarahPackageDir,"Matching"},"1LoopDiagramsGeneric.m"]];
Get[ToFileName[{$sarahPackageDir,"Matching"},"LoopFunctions.m"]];

ModelOutput[EWSB,VerticesForLoops->True,ReadLists->read];
MakeCouplingLists;


If[Head[input]===String,  (* Batch Mode *)
Get[ToFileName[{$sarahCurrentModelDir},input]];
If[Head[$SimplificationsMatching]=!=List,$SimplificationsMatching={}];
If[Head[$ParametrisationUV]=!=List,$ParametrisationUV={}];
If[Head[$AssumptionsMatching]=!=List,$AssumptionsMatching=Table[Gauge[[i,4]]>0,{i,1,Length[Gauge]}],$AssumptionsMatching=Join[$AssumptionsMatching,Table[Gauge[[i,4]]>0,{i,1,Length[Gauge]}]]];
$AssumptionsMatching=Join[$AssumptionsMatching,Table[ToExpression[ToString[Gauge[[i,4]]]<>"Q"]>0,{i,1,Length[Gauge]}]];
GetMassesAndRotationMatrices[$SolveTadpolesUV];
$MassesMatching=setMasses[M];
$AllSimplifications=Join[$SimplificationsMatching,$ParametrisationUV, ReplacementRotationMatrices,ReplacementMasses,{sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}]}];
Print[StyleForm["Perform Matching","Section",FontSize->12]];
SA`MatchingResultsLO={};
SA`MatchingResultsNLO={};
MatchLO;
MatchNLO;
$sarahMatchingDir=ToFileName[{$sarahCurrentOutputDir,"Matching"}];
If[FileExistsQ[$sarahMatchingDir]=!=True,CreateDirectory[$sarahMatchingDir];];
$sarahCurrentMatchingDir=ToFileName[{$sarahMatchingDir,$NameUV}];
If[FileExistsQ[$sarahCurrentMatchingDir]=!=True,
CreateDirectory[$sarahCurrentMatchingDir];,
DeleteDirectory[$sarahCurrentMatchingDir,DeleteContents->True];
CreateDirectory[$sarahCurrentMatchingDir];
];
Put[SA`MatchingResultsLO,ToFileName[{$sarahCurrentMatchingDir},"CouplingsLO.m"]];
Put[SA`MatchingResultsNLO,ToFileName[{$sarahCurrentMatchingDir},"CouplingsNLO.m"]];

Print[StyleForm["Write Output","Section",FontSize->12]];

If[$EFTcouplingsToTeX===True,
WriteEFTcoupsToTeX;
];

If[$ExportToSPheno===True,
ExportToSPheno[WriteSPhenoDOTm->True];
];

Print["Done... Output is written to ",$sarahCurrentMatchingDir];
,
$SimplificationsMatching={};
$ParametrisationUV=par;
$AssumptionsMatching=Join[Table[Gauge[[i,4]]>0,{i,1,Length[Gauge]}],assumptions];
GetMassesAndRotationMatrices[tadpoles];
$MassesMatching=setMasses[M];
$AllSimplifications=Join[$SimplificationsMatching,$ParametrisationUV, ReplacementRotationMatrices,ReplacementMasses,{sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}]}];
];
];

Options[ExportToSPheno]={WriteSPhenoDOTm->False,OutputFile->Automatic};
ExportToSPheno[opt___]:=ExportToSPhenoFunc[WriteSPhenoDOTm/.{opt}/.Options[WriteSPhenoDOTm],OutputFile/.{opt}/.Options[ExportToSPheno]];
ExportToSPhenoFunc[spheno_,outfile_]:=Block[{i,c,f,func,funcname,info,funccall,ComplexParameters={},RealParameters={},sphenofilename,funcfilename,funcfile,opts=Sequence@@(getOpts[GenerateSPhenodotm]/.opt[z_]:>OptionValue[z])},
Print["  Writing SPheno Output"];
GenerateFortranRoutines[outfile];
If[spheno===True,
(* GenerateWrapperFile; *)
GenerateSPhenoFiles;
];
];

(*
GenerateWrapperFile:=Block[{varsRAW,vars,arguments,real,complex,i,j,temp,funcfile},
varsRAW = DeleteCases[Variables@Level[SA`MatchingResultsNLO, {-Infinity,Infinity}],UVscaleQ];
vars = Join[Select[varsRAW,SymbolQS[#]&],Cases[varsRAW,_[__Integer]]]//Sort;
arguments = (#/.F_[___]:>F&/@vars);
real = Select[vars, conj[#]==#&];
complex = DeleteCases[Complement[vars,real],UVscaleQ];
varsUVin={};
varsUVout={};
complexUVin={};
complexUVout={};
realUVin={};
For[i=1,i\[LessEqual]Length[$SPhenoParameterMatching],
If[FreeQ[$SPhenoParameterMatching[[i]],EFTcoupNLO],
varsUVin=Join[varsUVin,{DeleteCases[Variables@Level[$SPhenoParameterMatching[[i,2]], {-Infinity,Infinity}],Transpose[$SPhenoMINPAR][[2]]]}];
SPhenoParameters=Join[SPhenoParameters,{{}}];
If[$SPhenoParameterMatching[[i,1]]===conj[$SPhenoParameterMatching[[i,1]]],
complexUVin=Join[complexUVin,{varsUVin[[-1]]}];,
realUVin=Join[realUVin,{varsUVin[[-1]]}];
realVar=Join[realVar,{varsUVin[[-1]]}];
];,
varsUVout=Join[varsUVout,{$SPhenoParameterMatching[[i,1]]}];
];
i++;];


funcfile=ToFileName[{$sarahCurrentMatchingDir},"EFT_wrapper.f90"];
OpenWrite[funcfile];
WriteString[funcfile,"Subroutine EFTwrapper("<> Join[varsUVin,varsUVout] <>") \n"];
MakeVariableList[vars,"",funcfile];
MakeVariableList[complexUVin,",Intent(in)",funcfile];
MakeVariableList[complexUVout,",Intent(in)",funcfile];
MakeVariableList[realUVin,",Intent(in)",funcfile];
WriteString[funcfile,"Implicit None \n\n"];

For[i=1,i\[LessEqual]Length[$SPhenoParameterMatching],
If[FreeQ[$SPhenoParameterMatching[[i]],EFTcoupNLO],
WriteString[funcfile,SPhenoForm[$SPhenoParameterMatching[[i,1]]]<>" = "<>SPhenoForm[$SPhenoParameterMatching[[i,2]]]<>"\n"];
];
i++;];
WriteString[funcfile,"End Subroutine EFTwrapper \n"];
Close[funcfile];
];
*)

GenerateFortranRoutines[outfile_]:=Block[{i,c,f,func,funcname,info,funccall,ComplexParameters={},RealParameters={},sphenofilename,funcfilename,funcfile,opts=Sequence@@(getOpts[GenerateSPhenodotm]/.opt[z_]:>OptionValue[z])},
SetOptions[GenerateSPhenodotm,"BoundaryHighScale"->SA`MatchingResultsNLO];
SA`ListFuncCalls={};
SA`ListFuncFiles={};
For[i=1,i<=Length[SA`MatchingResultsNLO],
c=SA`MatchingResultsNLO[[i]];
func=c[[2]];
funcname="EFTcoupling"<>ToString[i];
info=GenerateSelfDefinedFuntion[funcname,func,opts];
funccall=funcname<>"["<>ListToString[info["Arguments"]]<>"]";
SA`ListFuncCalls=Join[SA`ListFuncCalls,{{SA`MatchingResultsNLO[[i,1]],funccall}}];
ComplexParameters=Union[ComplexParameters,info["ComplexParameters"]];
RealParameters=Union[RealParameters,info["RealParameters"]];
sphenofilename="SPhenoEFT_"<>ModelName<>"_"<>$NameUV<>".f90";
If[outfile===Automatic,
funcfilename=funcname<>"_"<>sphenofilename;,
funcfilename=outfile;
];
funcfile=ToFileName[{$sarahCurrentMatchingDir},funcfilename];
If[FileExistsQ[funcfile],If[OptionValue["Backup"],RenameFile[funcfile,funcfile<>".bkp_"<>ToString[AbsoluteTime[]//Round]];DeleteFile[funcfile];,DeleteFile[funcfile];];];
CreateFile[funcfile];
SA`ListFuncFiles=Join[SA`ListFuncFiles,{funcfile}];
WriteString[funcfile,info["SelfDefinedFunction"]];
Close[funcfile];
i++;];
];


WriteEFTcoupsToTeX:=Block[{i},
Print["  Writing LaTeX Output"];
Off[Part::pkspec1];
Off[SetDelayed::write];
MAXTEXLENGTH=50;
CreateTeXForm;
FirstLevel=True;
clines=1;

TeXFile=OpenWrite[ToFileName[$sarahCurrentMatchingDir,"MatchingConditions_"<>ModelName<>"_"<>$NameUV<>".tex"]];

WriteString[TeXFile,"\\documentclass[A4]{article} \n"];
WriteString[TeXFile,"\\usepackage{amsmath}\n"];
WriteString[TeXFile,"\\usepackage[T1]{fontenc}\n"];
WriteString[TeXFile,"\\usepackage{amssymb}\n"];
WriteString[TeXFile,"\\usepackage{feynmp}\n"];
WriteString[TeXFile,"\\usepackage{hyperref}\n"];
WriteString[TeXFile,"\\usepackage{longtable}\n"];
WriteString[TeXFile,"\\DeclareGraphicsRule{*}{mps}{*}{}\n"];
WriteString[TeXFile,"\\graphicspath{{./Diagrams/}}\n"];
WriteString[TeXFile,"\\newcommand{\\Tr}{\\mbox{Tr}}\n"];

WriteString[TeXFile,"\\textwidth 18cm\n"];
WriteString[TeXFile,"\\oddsidemargin -1.0cm\n"];
WriteString[TeXFile,"\\evensidemargin -1.0cm\n"];

WriteString[TeXFile,"\\renewcommand{\\arraystretch}{1.3} \n"];
WriteString[TeXFile,"\\setlength{\\parindent}{0em} \n"];



WriteString[TeXFile,"\\begin{document}\n"];
WriteString[TeXFile, "\\title{"<>ModelNameLaTeX <> "\\\\ Matching of Scalar Couplings to an effective theory} \n\n"];

WriteString[TeXFile, "\\author{SARAH "<>SA`Version<>"} \n"];

WriteString[TeXFile," \\maketitle \n"];

WriteString[TeXFile," \\vspace{10cm} \n"];

WriteString[TeXFile, "This file was automatically generated by SARAH version "<>SA`Version<>".  \\\\ \n"];
WriteString[TeXFile, "Package Homepage: sarah.hepforge.org \\\\ \n"];

WriteString[TeXFile," \\pagebreak \n"];

WriteString[TeXFile," \\tableofcontents \n"];

WriteString[TeXFile," \\pagebreak \n"];

WriteString[TeXFile,"\\allowdisplaybreaks\n"];
WriteString[TeXFile,"\\section{Parametrisation and Assumptions}\n"];
WriteString[TeXFile,"\\subsection{Parametrisation in the UV}\n"];
WriteString[TeXFile,"\\begin{align}\n"];
For[i=1,i<=Length[$ParametrisationUV],
WriteString[TeXFile,TeXOutput[$ParametrisationUV[[i,1]]/.Pattern->pattern /.pattern[a_,b_]->a]<>"\\quad & = \\quad " <>TeXOutput[$ParametrisationUV[[i,2]]/.Delta->KroneckerDelta]<>"\\\\ \n"];
i++;];
WriteString[TeXFile,"\\end{align}\n"];

WriteString[TeXFile,"\\subsection{Assumptions at the Matching Scale}\n"];
WriteString[TeXFile,"\\begin{align}\n"];
For[i=1,i<=Length[$AssumptionsMatching],
Switch[Head[$AssumptionsMatching[[i,1]]],
Greater,
WriteString[TeXFile,TeXOutput[$AssumptionsMatching[[i,1]]]<>"\\quad & > \\quad " <>TeXOutput[$AssumptionsMatching[[i,2]]]<>"\\\\ \n"];,
Smaller,
WriteString[TeXFile,TeXOutput[$AssumptionsMatching[[i,1]]]<>"\\quad & > \\quad " <>TeXOutput[$AssumptionsMatching[[i,2]]]<>"\\\\ \n"];,
_,
WriteString[TeXFile,TeXOutput[$AssumptionsMatching[[i]]]<>"\\\\ \n"];
];
i++;];
WriteString[TeXFile,"\\end{align}\n"];

WriteString[TeXFile,"\\subsection{Simplifications at the Matching Scale}\n"];
WriteString[TeXFile,"\\begin{align}\n"];
For[i=1,i<=Length[$SimplificationsMatching],
If[FreeQ[ReplacementRotationMatrices/.Rule[a_[c__],b_]:>a,$SimplificationsMatching[[i,1]]] && Head[$SimplificationsMatching[[i,1]]]=!=M&& Head[Head[$SimplificationsMatching[[i,1]]]]=!=M && FreeQ[SA`Angles,$SimplificationsMatching[[i,1]]],
WriteString[TeXFile,TeXOutput[$SimplificationsMatching[[i,1]]/.Pattern->pattern /.pattern[a_,b_]->a]<>"\\quad & \\to \\quad " <>TeXOutput[$SimplificationsMatching[[i,2]]]<>"\\\\ \n"];
];
i++;];
WriteString[TeXFile,"\\end{align}\n"];

WriteString[TeXFile,"\\subsection{Calculated Masses at the Matching Scale}\n"];
WriteString[TeXFile,"\\begin{align}\n"];
For[i=1,i<=Length[ReplacementMasses],
If[Head[ReplacementMasses[[i,2]]]===Part,
WriteString[TeXFile,TeXOutput[ReplacementMasses[[i,1]]/.Mass[a_][b_]:>Mass[a]]<>"\\quad & \\to \\quad \\{" <>TeXOutput[ReplacementMasses[[i,2,1]]]<>"\\}\\\\ \n"];,
WriteString[TeXFile,TeXOutput[ReplacementMasses[[i,1]]/.Mass[a_][b_]:>Mass[a]]<>"\\quad & \\to \\quad " <>TeXOutput[ReplacementMasses[[i,2]]]<>"\\\\ \n"];
];
i++;];
WriteString[TeXFile,"\\end{align}\n"];

WriteString[TeXFile,"\\subsection{Calculated Rotation Matrices at the Matching Scale}\n"];
WriteString[TeXFile,"\\begin{align}\n"];
For[i=1,i<=Length[ReplacementRotationMatrices],
WriteString[TeXFile,TeXOutput[ReplacementRotationMatrices[[i,1]]/.A_[b__]->A]<>"\\quad & \\to \\quad " <>StringReplace[TeXOutput[ReplacementRotationMatrices[[i,2,1]]//MatrixForm],{"\\left\\Big"->"\\left","\\right\\Big"->"\\right"}]<>"\\\\ \n"];
i++;];
WriteString[TeXFile,"\\end{align}\n"];

WriteString[TeXFile,"\\section{Results}\n"];
WriteString[TeXFile,"\\subsection{Tree-Level Matching Conditions}\n"];
WriteString[TeXFile,"\\begin{align}\n"];
For[i=1,i<=Length[SA`MatchingResultsLO],
WriteString[TeXFile,TeXOutput[SA`MatchingResultsLO[[i,1]]]<>"\\quad & = \\quad " <>TeXOutput[SA`MatchingResultsLO[[i,2]]]<>"\\\\ \n"];
i++;];
WriteString[TeXFile,"\\end{align}\n"];

WriteString[TeXFile,"\\subsection{One-Loop Shifts}\n"];
WriteString[TeXFile,"\\begin{align}\n"];
For[i=1,i<=Length[SA`MatchingResultsLO],
WriteString[TeXFile,"\\Delta"<>TeXOutput[SA`MatchingResultsNLO[[i,1]]]<>"\\quad & = \\quad " <>TeXOutput[SA`MatchingResultsNLO[[i,2]]]<>"\\\\ \n"];
i++;];
WriteString[TeXFile,"\\end{align}\n"];

WriteString[TeXFile,"\\end{document}\n"];
Close[TeXFile];
On[Part::pkspec1];
On[SetDelayed::write]
];

(*
Options[EFTcoupLO]={Simplifications\[Rule]{}};
Options[EFTcoupNLO]={
Simplifications\[Rule]{},
Topologies\[Rule]{},
ExcludeTopologies\[Rule]{OffdiagonalWFRs},
ExcludeFields\[Rule]{},
GaugeThresholds\[Rule]True,
ShiftMSDR\[Rule]Automatic,
SimplifyResults\[Rule]True,
ExplicitLoopFunctions\[Rule]True,
Debug\[Rule]False
};
EFTcoupLO[{fields__},opt___]:=eftLOwrapper[{fields},Simplifications/.{opt}/.Options[EFTcoupLO]];
EFTcoupNLO[{fields__},opt___]:=eftNLOwrapper[{fields},
Simplifications/.{opt}/.Options[EFTcoupNLO],
Topologies/.{opt}/.Options[EFTcoupNLO],
ExcludeTopologies/.{opt}/.Options[EFTcoupNLO],
ExcludeFields/.{opt}/.Options[EFTcoupNLO],
GaugeThresholds/.{opt}/.Options[EFTcoupNLO],
ShiftMSDR/.{opt}/.Options[EFTcoupNLO],
SimplifyResults/.{opt}/.Options[EFTcoupNLO],
ExplicitLoopFunctions/.{opt}/.Options[EFTcoupNLO],
Debug/.{opt}/.Options[EFTcoupNLO]
];
eftLOwrapper[{fields__},simp_]:=Block[{LocalSimplifications},
Off[Part::pkspec1];
LocalSimplifications=Join[simp,$AllSimplifications];
On[Part::pkspec1];
Clear[CACHE,Lambda];
SetOptions[getLambda,Assumptions->LocalSimplifications,    "Masses"->setMasses[M],  "Topologies"->{T},"ExcludeTopologies"\[Rule]{OffdiagonalWFRs,DiagonalWFRs},    MSDR->0,   "IncludeGaugeThresholds" -> False,"Progress"\[Rule]False];
Return[Simplify[getLambda[{fields}]/. epsUV\[Rule]0//.Den[0,0]:>0/.Den[a_,b_]:>1/(a-b)//.Inf[___]:>0//.LocalSimplifications,$AssumptionsMatching]];
];

eftNLOwrapper[{fields__},simp_,top_,extop_,exclude_,gt_,msdr_,simpres_,replloops_,debug_]:=Block[{LocalSimplifications,temp},
Off[Part::pkspec1];
LocalSimplifications=Join[simp,$AllSimplifications];
On[Part::pkspec1];
Clear[CACHE,Lambda];
SetOptions[getLambda,	
Assumptions->LocalSimplifications,   
 "Masses"->setMasses[M],    
"Topologies"\[Rule]top,
"ExcludeTopologies"\[Rule] extop,
 MSDR\[Rule]If[msdr===Automatic,If[SupersymmetricModel,1,0],msdr],   
"IncludeGaugeThresholds" -> gt,  
ExcludeLoopFields\[Rule]exclude,
"LoopReplace"\[Rule]If[replloops,getAnalyticLoops,Identity],
"Debug"\[Rule]debug,
"Progress"\[Rule]True
];
temp=getLambda[{fields}]/. epsUV\[Rule]0//.Den[0,0]:>0/.Den[a_,b_]:>1/(a-b)//.Inf[___]:>0 ;
If[simpres,
Return[Simplify[temp//.LocalSimplifications,$AssumptionsMatching]];,
Return[temp//.LocalSimplifications];
];
];
*)
