(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* Begin["`Numerik`"] *)

SA`Doc`ToDo="COMPLETELY OUTDATED!! FILE CAN/SHOULD BE REMOVED AT SOME POINT! \n
Because of that, I also won't add any comments here. FS, 17/05/19 "

(*----------------------------------------*)
(* Numerical Values  *)
(*----------------------------------------*)


(* ----- Read Specturm File --------*)

FirstRead=True;

GetNumericalValues[file_]:=Block[{},
PrintDebug["   ... checking for spectrum file"];
Print["   ... checking for spectrum file: ", Dynamic[DynamicSpectrumFileInput]];

If[file=!=None,
ReadSpectrum[file];
DynamicSpectrumFileInput="Read";,
PrintDebug["     No Spectrum File defined"];
DynamicSpectrumFileInput="No Spectrum File defined";
];


MakeNumericalValueList;
subNum=Join[subNum,subNumValue];

CalcMatrices;

];

Options[ShowValue]={Appearance->Last};
Options[ShowBlock]={Appearance->Last};

ShowValue[block_,entry_,opt___]:=FindValue[ToUpperCase[ToString[block]],entry,LesHouchesInput,Appearance/.{opt}/.Options[ShowValue]];
ShowBlock[block_,opt___]:=FindValue[ToUpperCase[ToString[block]],None,LesHouchesInput,Appearance/.{opt}/.Options[ShowBlock]];


ReadSpectrum[file_]:=Block[{i,j,a,b,c,lval,nrgesucht,j2, list},

LesHouchesList={};

For[i=1,i<=Length[ParameterDefinitions],
lh = LesHouches /. ParameterDefinitions[[i,2]];
LesHouchesList=Join [LesHouchesList,{{ ParameterDefinitions[[i,1]],lh}}];
i++;];

ReadSpectrumFile[ToFileName[$sarahCurrentModelDir,file],ITSJUSTONEFILE];

For[i=1,i<=Length[LesHouchesList],
If[FreeQ[LesHouchesInput,LHBlockName[LesHouchesList[[i,1]]]]==False,
Switch[Depth[LesHouchesList[[i,2]]],
1,
   real =ShowBlock[LesHouchesList[[i,2]]];
   imag =ShowBlock[ToExpression["IM"<>ToString[LesHouchesList[[i,2]]]]];
  If[real=!=None || imag =!=None,
If[real===None, real = imag*0]; If[imag===None, imag = real*0];
   subNum = Join[subNum, Table[LesHouchesList[[i,1]]@@Transpose[Drop[Transpose[real],-1]][[j]]->Last[Transpose[real]][[j]]+I Last[Transpose[imag]][[j]],{j,1, Length[real]}]];
];,
2,
   real =ShowValue[LesHouchesList[[i,2,1]],LesHouchesList[[i,2,2]]];
   imag =ShowValue[ToExpression["IM"<>ToString[LesHouchesList[[i,2,1]]]],LesHouchesList[[i,2,2]]];
  If[real=!=None || imag =!=None,
If[real===None, real = imag*0]; If[imag===None, imag = real*0];
   subNum = Join[subNum, {LesHouchesList[[i,1]] -> real +I imag}];
];
];
];
i++;];

pos = Position[LesHouchesInput,"MASS"];

If[pos=!={},
listMass=Drop[LesHouchesInput[[pos[[1,1]]]],1];
For[i=1,i<=Length[LesHouchesListMasses],
pos = Position[listMass,LesHouchesListMasses[[i,2,1,2]]];
If[pos=!={},
subNum = Join[subNum,{LesHouchesListMasses[[i,1]]-> listMass[[pos[[1,1]]]][[2]]}];
];
i++;];
];


subNum = Flatten[subNum /. EndOfFile ->0];

]; 


SortDecay[list_]:=Block[{temp={},temp1={},i},
temp1=DeleteCases[list,{},3];
temp={temp1[[1]],{WIDTH,width}};
For[i=2,i<=Length[temp1],
temp=Join[temp,{{FinalParticles@@Take[temp1[[i]],{3,Length[temp1[[i]]]}],temp1[[i,1]]}}];
i++;];
Return[temp];
];

ReadSpectrumFile[file_,splitsequence_]:=Block[{i,j,a,b,c,sps={}, temp,t="", return},
If[splitsequence=!=False,
AllLesHouchesInput={};
SplitLine =splitsequence;,
SplitLine="123NO!";
];
in=OpenRead[file];
While[t=!="BLOCK" && t=!="DECAY", t=ToUpperCase[Read[in,Word]]; ];
return=t;
While[return=!=EndOfFile, 
If[ToUpperCase[return]==="BLOCK",
temp=ReadBlock[False,SplitLine];
decay=False;,
temp=ReadBlock[True,SplitLine];
decay=True;
];
return=temp[[2]];
If[decay==True, temp[[1]]=SortDecay[temp[[1]]];];
sps=Join[sps,{temp[[1]]}];

If[splitsequence=!=False,
If[return===splitsequence,
AllLesHouchesInput=Join[AllLesHouchesInput,{sps}];
t="";
While[t=!="BLOCK" && t=!="DECAY" && t=!=ToUpperCase[EndOfFile], t=ToUpperCase[Read[in,Word]]; ];
If[t===ToUpperCase[EndOfFile],
return=EndOfFile;,
return=t;
];
sps={};
];
];
];
Close[in];
If[splitsequence=!=False,AllLesHouchesInput=Join[AllLesHouchesInput,{sps}];];
LesHouchesInput=sps;

(* Print["Finished with reading!"]; *)
];



ReadBlock[decay_,SplitLine_]:=Block[{i,t,temp,temp1={},j,test,first=True},
temp ={ToUpperCase[Read[in,Word]]};
SetStreamPosition[in,StreamPosition[in]-1];
test=Read[in,String];
If[decay==True,
width=StringDrop[test,1];
width = ToExpression[StringReplace[StringTake[width,{1,StringPosition[width,"#"][[1,1]]-1}],{"E"->"*10^","e"->"*10^"}]];
];
While[ToUpperCase[j]=!="BLOCK" && ToUpperCase[j]=!="DECAY" &&ToUpperCase[j]=!= SplitLine&& j=!=EndOfFile,
i=j;
If[i==="#",
temp = Join[temp,{temp1}];
SetStreamPosition[in,StreamPosition[in]-1];
test=Read[in,String];
temp1={};,
If[first=!=True &&  ToUpperCase[j]=!="DECAY", temp1 = Join[temp1,{ToExpression[StringReplace[i,{"E"->"*10^","e"->"*10^"}]]}]; ];
];
j=Read[in,Word];
first=False;
];
Return[{temp,j}];
];

FindValue[block_,entry_,data_,app_]:=Block[{pos,blockname},
If[Head[block]===Symbol,
blockname=ToUpperCase[ToString[block]];,
blockname = ToUpperCase[block];
];

pos=Position[data,blockname];
If[pos=!={},
If[Head[app]===Integer,
pos = pos[[app,1]];,
pos=Last[pos][[1]];
];
temp=DeleteCases[Drop[Extract[data,pos],1],{}];
If[entry===None, Return[temp];];
If[Head[entry]===List,
pos=Cases[NIX[temp][[1]],Join[entry,{_}]];
If[pos=={},Return[None];];
Return[Last[pos[[1]]]];,
pos=Position[Transpose[temp][[1]],entry];
If[pos=={},Return[None];];
Return[temp[[pos[[1,1]]]][[2]]];
];,
Return[None];
];
];



MakeNumericalValueList:=Block[{i},

PrintAll["   ... reading parameter values and dependences"];

subNumValue={};
For[i=1,i<=Length[ParameterDefinitions],
If[((Value /. ParameterDefinitions[[i,2]])=!=None) && (Value /. ParameterDefinitions[[i,2]])=!=Value,
If[Depth[(Value /. ParameterDefinitions[[i,2]])]==1,
subNumValue = Join[subNumValue,{ParameterDefinitions[[i,1]] -> (Value /. ParameterDefinitions[[i,2]])}];,
lval= Value/. ParameterDefinitions[[i,2]];
For[j=1,j<=Length[lval],
subNumValue= Join[subNumValue,{(ParameterDefinitions[[i,1]][lval[[j,1]]] /. A_[{a__}]->A[a])-> lval[[j,2]]}];
j++;];
];
];
i++;];

DefinedNumericalValues=subNumValue;

];

CalcMatrices:=Block[{i,j,k, states, basis, matrices, mixName,massesTemp},

PrintAll["   ... calculate mixing matrices"];

states = NameOfStates;

alreadyCalculated={};

For[i=1,i<=Length[states],
basis = MixBasis[states[[i]]];
matrices=MassMatricesFull[states[[i]]];
mixName=MixMatrix[states[[i]]];
massesTemp=MassesTemp[states[[i]]];
Particles[Current]=Particles[states[[i]]];

If[Head[basis]=!= MixBasis,
For[j=1,j<=Length[matrices],
If[FreeQ[alreadyCalculated,mixName[[j,2]]]==True,
alreadyCalculated = Join[alreadyCalculated,{mixName[[j,2]]}];
If[NumericalValue[matrices[[j]]]=!=NaN,
If[RE[basis[[j,1]]]===RE[basis[[j,2]]],
CalcMixingmatrixSymm[matrices[[j]],ToExpression[ToString[mixName[[j,2]]]<>"Num"],mixName[[j,1]]];,
CalcMixingmatrixNSymm[matrices[[j]],ToExpression[ToString[mixName[[j,1,2]]]<>"Num"],ToExpression[ToString[mixName[[j,2,2]]]<>"Num"],mixName[[j,1,1]],mixName[[j,2,1]]];
];
];
];
j++;];
];
Masses[states[[i]]]=massesTemp;
i++;];
];


MakeSubNum[list_]:=Block[{temp},
temp=DeleteCases[list,{},10];
Return[Flatten[Table[Table[ToExpression[temp[[i,1]]]@@Drop[temp[[i,j]],-1]->Last[temp[[i,j]]],{j,2,Length[temp[[i]]]}],{i,1,Length[temp]}]]];
];

CalcParameters[file_]:=Block[{i},

PrintAll["   ... read numerical input file"];


PrintAll["   ... calc mixing matrices"];

For[i=1,i<= Length[MassMatricesFull],
If[conj[Transpose[MassMatricesFull[[i]]]]==MassMatricesFull[[i]],
CalcMixingmatrixSymm[MassMatricesFull[[i]],ToExpression[ToString[mix[[i,2,2]]]<>"Num"],ToExpression["Mass"<>ToString[mix[[i,2,1]]]]];,
CalcMixingmatrixNSymm[MassMatricesFull[[i]],ToExpression[ToString[mix[[i,2,1,2]]]<>"Num"],ToExpression[ToString[mix[[i,2,2,2]]]<>"Num"],ToExpression["Mass"<>ToString[mix[[i,2,1,1]]]],ToExpression["Mass"<>ToString[mix[[i,2,2,1]]]]];
];
i++;];
];




(* ::Input::Initialization:: *)
(* -------- Functions for Changing Numerical Value -------*)

NumericValQ[x_List]:=NumericValQ/@ x;
NumericValQ[x_Times]:=NumericValQ/@ x;
NumericValQ[x_Power]:=NumericValQ/@ x;
NumericValQ[x_Plus]:=NumericValQ/@ x;
NumericValQ[x_]:=NumericQ[x];

NVal[x_List]:=NVal/@ x;
NVal[x_Times]:=NVal/@ x;
NVal[x_Power]:=NVal/@ x;
NVal[x_Plus]:=NVal/@ x;
NVal[x_Sin]:=NVal/@ x;
NVal[x_Cos]:=NVal/@ x;
NVal[x_Tan]:=NVal/@ x;
NVal[x_Plus]:=NVal/@ x;
NVal[x_Integer]:=x;
NVal[x_Real]:=x;
NVal[x_Complex]:= x;
NVal[x_Rational]:=x;
NVal[x_Mass]:=Block[{},
If[NumericValQ[(x /.  subNum)],Return[x /.subNum];];
If[NumericValQ[(x /. {Mass[a_,b_]->MassGiven[a[b]] , Mass[a_] -> MassGiven[a]} /. subNum)],
Return[x /. {Mass[a_,b_]->MassGiven[a[b]] , Mass[a_] -> MassGiven[a]} /. subNum];
];
If[NumericValQ[(x /. {Mass[a_,b_]->MassRead[a[b]] , Mass[a_] -> MassRead[a]} /. subNum)],
Return[x /. {Mass[a_,b_]->MassRead[a[b]] , Mass[a_] -> MassRead[a]} /. subNum];
];
Return[x];
];

NVal[x_Width]:=Block[{},
If[NumericValQ[(x /.  subNum)],Return[x /.subNum];];
If[NumericValQ[(x /. {Width[a_,b_]->WidthGiven[a[b]] , Width[a_] -> WidthGiven[a]} /. subNum)],
Return[x /. {Width[a_,b_]->WidthGiven[a[b]] ,Width[a_] -> WidthGiven[a]} /. subNum];
];
Return[x];
];

NVal[x_]:=Block[{temp},
If[FreeQ[x,sum]==False,
temp=x;
While[FreeQ[temp,sum]==False,
temp = temp /. sum[a_,b_,c_,d_]->Hold[Sum[d,{a,b,c}]];
temp =ReleaseHold[temp];
];
Return[NVal[temp]];,

If[FreeQ[subNum,x]==False,
Return[x /. subNum];
];

If[FreeQ[subNum,dependtPara]==False,
Return[NVal[x/. subNumDependences]];
];

Return[x];
];
];


WriteErrorNum=False;

NumericalValue[x_] :=Block[{},
result=NVal[x /. subNum] /. subNum;
result = result  /.subNumDependences /.subNum  /.subNumDependences  /.subNum;
If[FreeQ[NumericValQ[result],False]==True,
Return[result];,
If[WriteErrorNum,
listNoNumeric=DeleteCases[Intersection[Flatten[DeleteCases[Expand[result] /. Power->Times ,y_?NumericQ,2] /. Plus->List /. Times->List /. conj[y_]->y /. {Sin[y_]->y,Tan[y_]->y,Cos[y_]->y}]],y_?((NumericValQ[#])&)];
PrintAll["No numerical values for: ",listNoNumeric];
];
If[SetNaNtoZero==True,
Return[0];,
Return[NaN];
];
];
];

NoNumericValQ[x_]:=If[NumericQ[x]==True, Return[False];,Return[True];];


(* ::Input::Initialization:: *)
SetParameterValue[x_,y_]:=Block[{},
If[MemberQ[subNum,x->_],
subNum=DeleteCases[subNum, x->_];
];
subNum = Join[subNum,{x->y}];
];

DeleteParameterValue[x_]:=Block[{},
subNum=DeleteCases[subN, x->_];
];




(* ::Input::Initialization:: *)


(* ---------- Calc Eigensystem ------------*)

CalcMixingmatrix[M_]:=Block[{eigenSystem,pi,i,vec,temp,m,k},
eigenSystem=Chop[SetPrecision[Eigensystem[SetPrecision[M,100]],10],10^-50];
pi=Table[k,{k,Dimensions[M][[1]]}];
vec=eigenSystem[[2]];
temp=vec;
For[k=1,k<=Dimensions[M][[1]],
For[m=1,m<=Dimensions[M][[1]],
If[Abs[vec[[pi[[k]],k]]]<Abs[vec[[m,k]]],pi[[k]]=m];
m++];
vec[[pi[[k]]]]=Table[0,{Dimensions[M][[1]]}];
k++;];
vec=temp[[pi]];
Return[vec];
];

TestReducibility[M_,Mixing_]:=Block[{i,j},
TestMatrix=Table[0,{Dimensions[M][[1]]},{Dimensions[M][[2]]}];

For[i=1,i<=Dimensions[M][[1]],
For[j=1,j<=Dimensions[M][[2]],
If[M[[i,j]]=!=0,
TestMatrix[[i,j]]=1000*Random[];
];
j++;];
i++;];

mix=CalcMixingmatrix[TestMatrix];

For[i=1,i<=Dimensions[mix][[1]],
For[j=1,j<=Dimensions[mix][[2]],
If[Abs[mix[[i,j]]]<10^(-100),
Mixing[i,j]=0;
];
j++;];
i++;];
];


TestReality[M_] :=Block[{i,j},
If[conj[M] =!= M, Return[False];,

TestMatrix=Table[0,{Dimensions[M][[1]]},{Dimensions[M][[2]]}];

For[i=1,i<=Dimensions[M][[1]],
For[j=1,j<=Dimensions[M][[2]],
If[M[[i,j]]=!=0,
TestMatrix[[i,j]]=1000*Random[];
];
j++;];
i++;];

EV=Eigenvalues[TestMatrix];

If[Length[Cases[EV,x_?Negative]]>0, Return[False];,Return[True];];


];
];


(* ::Input::Initialization:: *)

(* ------- Non Symmetric Matrix ------- *)

CalcMixingmatrixNSymm[M_,U_,V_,M1_,M2_]:=Block[{i,j},
MMfN=NumericalValue[M];
Utemp=CalcMixingmatrix[MMfN.Transpose[MMfN]];
Vtemp=CalcMixingmatrix[Transpose[MMfN].MMfN];
tempMass1 = {};
tempMass2 = {};

dia1 = Vtemp.(Transpose[MMfN].MMfN).Inverse[Vtemp];
dia2 = Utemp.(MMfN.Transpose[MMfN]).Inverse[Utemp];
For[i=1,i<=Dimensions[M][[1]],
For[j=1,j<=Dimensions[M][[1]],
subNum=Join[subNum,{ToExpression[StringDrop[ToString[U],Length[ToString[U]]-3]<>"[i,j]"]->Utemp[[i,j]]}];
subNum=Join[subNum,{ToExpression[StringDrop[ToString[V],Length[ToString[V]]-3]<>"[i,j]"]->Vtemp[[i,j]]}];
j++;];
subNum= Join[subNum,{Mass[M1,i] -> Sqrt[dia1[[i,i]]]}];
subNum= Join[subNum,{Mass[M2,i] -> Sqrt[dia2[[i,i]]]}];
i++;];
Set[U,Utemp];
Set[V,Vtemp];
];


(* ::Input::Initialization:: *)

(* ----------- Symmetric Matrix ---------- *)

CalcMixingmatrixSymm[M_,U_,M1_]:=Block[{i,j},
MMfN=NumericalValue[M];
Utemp=CalcMixingmatrix[MMfN];
tempMass={};
dia = Utemp.MMfN.Inverse[Utemp];
For[i=1,i<=Dimensions[M][[1]],
For[j=1,j<=Dimensions[M][[1]],
subNum=Join[subNum,{ToExpression[StringDrop[ToString[U],Length[ToString[U]]-3]<>"[i,j]"]->Utemp[[i,j]]}];
j++;];
subNum = Join[subNum,{Mass[M1,i]->dia[[i,i]]}];
i++;];
Set[U,Utemp];
];

(* End[] *)
