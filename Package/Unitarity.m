(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
InitUnitarity[approx_:{}]:=Block[{},
(* get all scalars (inlcuding the complex conjugated ones) *)
partS=Transpose[Select[Particles[EWSB],#[[4]]===S&]][[1]];
partS=Intersection[Join[partS,conj/@partS]];

partV=Transpose[Select[Particles[EWSB],#[[4]]===V&]][[1]];
partV=Intersection[Join[partV,conj/@partV]];

SA`CurrentStates=EWSB;
(* 3- and 4- tuples => to get vertices *)
tup3=Intersection[Sort/@Tuples[partS,{3}]];
tup3=Select[tup3,Plus@@(getElectricCharge/@#)==0&];
tup4=Intersection[Sort/@Tuples[partS,{4}]];
tup4=Select[tup4,Plus@@(getElectricCharge/@#)==0&];

tup3V=Intersection[Sort/@Tuples[Join[partS,partV],{3}]];
tup3V=Select[tup3V,Count[getType/@#,S]==2&];
tup3V=Select[tup3V,Plus@@(getElectricCharge/@#)==0&];
vertexlist3=getVertices[tup3,approx];
vertexlist3V=getVertices[tup3V,approx];
vertexlist4=getVertices[tup4,approx];

scattering22=Select[Intersection[Tuples[partS,{4}] /. {a_,b_,c_,d_}:>{Sort[{a,b}],Sort[{c,d}]}],Plus@@(getElectricCharge/@#[[1]])===-Plus@@(getElectricCharge/@#[[2]])&];
(* get all pairs for initial/final states *)
scatteringPairs=Intersection[Tuples[partS,{2}]/. {a_,b_}:>Sort[{a,b}]] ;


];


getVertices[list_,approx_]:=Block[{res,i},
vertexlist={};
For[i=1,i<=Length[list],
res=Vertex[list[[i]]][[2,1]] /.approx; 
If[res=!=0,
vertexlist=Join[vertexlist,{{list[[i]],res}}];
];
i++;];
Return[vertexlist];
];


(* generate quartic diagram *)
Qchannel[s1_,s2_,s3_,s4_,inds_]:=Block[{outlist,i},
outlist=0;
(* check if vertex exists *)
If[FreeQ[vertexlist4,Sort[{s1,s2,s3,s4}]]==False,

(* replace generation index in vertex expression by external indices *)
pos1a=Position[Select[vertexlist4,#[[1]]==Sort[{s1,s2,s3,s4}]&][[1,1]],s1,{1}][[1,1]];
pos1b=Position[ReplacePart[Select[vertexlist4,#[[1]]==Sort[{s1,s2,s3,s4}]&][[1,1]],pos1a->taken],s2,{1}][[1,1]];
pos1c=Position[ReplacePart[ReplacePart[Select[vertexlist4,#[[1]]==Sort[{s1,s2,s3,s4}]&][[1,1]],pos1a->taken],pos1b->taken],s3,{1}][[1,1]];
pos1d=Position[ReplacePart[ReplacePart[ReplacePart[Select[vertexlist4,#[[1]]==Sort[{s1,s2,s3,s4}]&][[1,1]],pos1a->taken],pos1b->taken],pos1c->taken],s4,{1}][[1,1]];

(* save all information in a list *)
(*
outlist+=QC[mout1,mout2,mout3,mout4,Select[vertexlist4,#[[1]]==Sort[{s1,s2,s3,s4}]&][[1,2]]/.{ToExpression["gt"<>ToString[pos1d]]\[Rule]inds[[4]],ToExpression["gt"<>ToString[pos1c]]\[Rule]inds[[3]],ToExpression["gt"<>ToString[pos1b]]\[Rule]inds[[2]],ToExpression["gt"<>ToString[pos1a]]\[Rule]inds[[1]]}]; *)
outlist+= -2 I Select[vertexlist4,#[[1]]==Sort[{s1,s2,s3,s4}]&][[1,2]]/.{ToExpression["gt"<>ToString[pos1d]]->inds[[4]],ToExpression["gt"<>ToString[pos1c]]->inds[[3]],ToExpression["gt"<>ToString[pos1b]]->inds[[2]],ToExpression["gt"<>ToString[pos1a]]->inds[[1]]};
];
Return[outlist];
];
(* generate S-channel diagram for external states *)
Schannel[s1_,s2_,s3_,s4_,inds_]:=Block[{outlist,i,sign},
outlist=0;
(* check for all scalars in the propagator *)
For[i=1,i<=Length[partS],
(* check if vertex exists *)
If[FreeQ[vertexlist3,Sort[{s1,s2,partS[[i]]}]]==False&&FreeQ[vertexlist3,Sort[{s3,s4,conj[partS[[i]]]}]]==False,

(* replace generation index in vertex expression by external indices *)
pos1a=Position[Select[vertexlist3,#[[1]]==Sort[{s1,s2,partS[[i]]}]&][[1,1]],s1,{1}][[1,1]];
pos1b=Position[ReplacePart[Select[vertexlist3,#[[1]]==Sort[{s1,s2,partS[[i]]}]&][[1,1]],pos1a->taken],s2,{1}][[1,1]];
pos1c=Position[ReplacePart[ReplacePart[Select[vertexlist3,#[[1]]==Sort[{s1,s2,partS[[i]]}]&][[1,1]],pos1a->taken],pos1b->taken],partS[[i]],{1}][[1,1]];
pos2a=Position[Select[vertexlist3,#[[1]]==Sort[{s3,s4,conj[partS[[i]]]}]&][[1,1]],s3,{1}][[1,1]];
pos2b=Position[ReplacePart[Select[vertexlist3,#[[1]]==Sort[{s3,s4,conj[partS[[i]]]}]&][[1,1]],pos2a->taken],s4,{1}][[1,1]];
pos2c=Position[ReplacePart[ReplacePart[Select[vertexlist3,#[[1]]==Sort[{s3,s4,conj[partS[[i]]]}]&][[1,1]],pos2a->taken],pos2b->taken],conj[partS[[i]]],{1}][[1,1]];

(* save all information in a list *)
outlist+=SC[mout1,mout2,mout3,mout4,partS[[i]],Select[vertexlist3,#[[1]]==Sort[{s1,s2,partS[[i]]}]&][[1,2]]/.{ToExpression["gt"<>ToString[pos1c]]->propInd,ToExpression["gt"<>ToString[pos1b]]->inds[[2]],ToExpression["gt"<>ToString[pos1a]]->inds[[1]]},
Select[vertexlist3,#[[1]]==Sort[{s3,s4,conj[partS[[i]]]}]&][[1,2]]/.{ToExpression["gt"<>ToString[pos2c]]->propInd,ToExpression["gt"<>ToString[pos2b]]->inds[[4]],ToExpression["gt"<>ToString[pos2a]]->inds[[3]]}];
];
i++;];

(*
For[i=1,i\[LessEqual]Length[partV],
(* check if vertex exists *)
If[FreeQ[vertexlist3V,Sort[{s1,s2,partV[[i]]}]]\[Equal]False&&FreeQ[vertexlist3V,Sort[{s3,s4,conj[partV[[i]]]}]]\[Equal]False,


(* sign from momentum flow in vertex *)
sign=1;
If[Sort[{s1,s2}]=!={s2,s1},sign=-sign;];
If[Sort[{s3,s4}]=!={s3,s4},sign=-sign;];

(* replace generation index in vertex expression by external indices *)
pos1a=Position[Select[vertexlist3V,#[[1]]==Sort[{s1,s2,partV[[i]]}]&][[1,1]],s1,{1}][[1,1]];
pos1b=Position[ReplacePart[Select[vertexlist3V,#[[1]]==Sort[{s1,s2,partV[[i]]}]&][[1,1]],pos1a\[Rule]taken],s2,{1}][[1,1]];
pos1c=Position[ReplacePart[ReplacePart[Select[vertexlist3V,#[[1]]==Sort[{s1,s2,partV[[i]]}]&][[1,1]],pos1a\[Rule]taken],pos1b\[Rule]taken],partV[[i]],{1}][[1,1]];
pos2a=Position[Select[vertexlist3V,#[[1]]==Sort[{s3,s4,conj[partV[[i]]]}]&][[1,1]],s3,{1}][[1,1]];
pos2b=Position[ReplacePart[Select[vertexlist3V,#[[1]]==Sort[{s3,s4,conj[partV[[i]]]}]&][[1,1]],pos2a\[Rule]taken],s4,{1}][[1,1]];
pos2c=Position[ReplacePart[ReplacePart[Select[vertexlist3V,#[[1]]==Sort[{s3,s4,conj[partV[[i]]]}]&][[1,1]],pos2a\[Rule]taken],pos2b\[Rule]taken],conj[partV[[i]]],{1}][[1,1]];

(* save all information in a list *)
outlist+=sign (* SCV[pmass[s1[inds[[1]]]],pmass[s2[inds[[2]]]],pmass[s3[inds[[3]]]],pmass[s4[inds[[4]]]],partV[[i]], *)SCV[mout1,mout2,mout3,mout4,partV[[i]],Select[vertexlist3V,#[[1]]==Sort[{s1,s2,partV[[i]]}]&][[1,2]]/.{ToExpression["gt"<>ToString[pos1c]]\[Rule]propInd,ToExpression["gt"<>ToString[pos1b]]\[Rule]inds[[2]],ToExpression["gt"<>ToString[pos1a]]\[Rule]inds[[1]]},
Select[vertexlist3V,#[[1]]==Sort[{s3,s4,conj[partV[[i]]]}]&][[1,2]]/.{ToExpression["gt"<>ToString[pos2c]]\[Rule]propInd,ToExpression["gt"<>ToString[pos2b]]\[Rule]inds[[4]],ToExpression["gt"<>ToString[pos2a]]\[Rule]inds[[3]]}];
];
i++;];*)
Return[outlist];
];
(* generate T-channel diagram for external states *)
Tchannel[s1_,s2_,s3_,s4_,{ind1_,ind2_,ind3_,ind4_}]:=Block[{},
Return[Schannel[s1,s3,s2,s4,{ind1,ind3,ind2,ind4}]] /.SC->TC /.SCV->TCV;
];

(* generate U-channel diagram for external states *)
Uchannel[s1_,s2_,s3_,s4_,{ind1_,ind2_,ind3_,ind4_}]:=Block[{},
Return[Schannel[s1,s4,s2,s3,{ind1,ind4,ind2,ind3}]]/.SC->UC /.SCV->UCV;
];

GetScatteringDiagrams[{inf1_,inf2_}->{outf1_,outf2_}]:=Block[{indices={}},
If[Depth[RE[inf1]]==1,
indices=Join[indices,{in1}];,
indices=Join[indices,{RE[inf1][[1]]}];
];
If[Depth[RE[inf2]]==1,
indices=Join[indices,{in2}];,
indices=Join[indices,{RE[inf2][[1]]}];
];
If[Depth[RE[outf1]]==1,
indices=Join[indices,{out1}];,
indices=Join[indices,{RE[outf1][[1]]}];
];
If[Depth[RE[outf2]]==1,
indices=Join[indices,{out2}];,
indices=Join[indices,{RE[outf2][[1]]}];
];
Return[GetDiagrams[inf1/.A_[b_Integer]->A,inf2/.A_[b_Integer]->A,outf1/.A_[b_Integer]->A,outf2/.A_[b_Integer]->A,indices]/.SC->SCfunc /. TC->TCfunc /.UC->UCfunc];
];

(* get all diagrams (with a propagator so far)  *)
GetDiagrams[s1_,s2_,s3_,s4_,ind_]:=Block[{res},
If[FreeQ[scattering22,{Sort[{s1,s2}],Sort[{s3,s4}]}],Return[0]];
res=sChan Schannel[s1,s2,s3,s4,ind];
res+=tChan Tchannel[s1,s2,s3,s4,ind];
res+=uChan Uchannel[s1,s2,s3,s4,ind];
res+=qChan Qchannel[s1,s2,s3,s4,ind];
res=1/(32Pi) (KL[s,mout1^2,mout2^2]KL[s,mout3^2,mout4^2])^(1/4)/s res;
Return[If[s1===s2,If[getGen[s1]>1,Sqrt2[ind[[1]],ind[[2]]],1/Sqrt[2]],1]If[s3===s4,If[getGen[s3]>1,Sqrt2[ind[[3]],ind[[4]]],1/Sqrt[2]],1]res/.{mout1->pmass[s1[ind[[1]]]],mout2->pmass[s2[ind[[2]]]],mout3->pmass[s3[ind[[3]]]],mout4->pmass[s4[ind[[4]]]]}];
];
(* expression after phase space integration for T-channel diagrams *)
TCfunc[m1_,m2_,m3_,m4_,prop_,c1_,c2_]:=Block[{res,i},
res=0;
For[i=1,i<=getGen[prop],
res+= c1 c2 intT[m1,m2,m3,m4,pmass[prop[i]]] /.propInd->i;
i++;];
Return[res];
];

(* expression after phase space integration for S-channel diagrams *)
SCfunc[m1_,m2_,m3_,m4_,prop_,c1_,c2_]:=Block[{res,i},
res=0;
For[i=1,i<=getGen[prop],
res+=c1 c2 intS[m1,m2,m3,m4,pmass[prop[i]]]/.propInd->i;
i++;];
Return[res];
];

(* expression after phase space integration for U-channel diagrams *)
UCfunc[m1_,m2_,m3_,m4_,prop_,c1_,c2_]:=Block[{res,i},
res=0;
For[i=1,i<=getGen[prop],
res+=c1 c2 intU[m1,m2,m3,m4,pmass[prop[i]]]/.propInd->i;
i++;];
Return[res];
];



(* expression after phase space integration for T-channel diagrams with vectors *)
TCVfunc[m1_,m2_,m3_,m4_,prop_,c1_,c2_]:=Block[{res,i},
res=0;
For[i=1,i<=getGen[prop],
res+= c1 c2 intTV[m1,m2,m3,m4,pmass[prop[i]]] /.propInd->i;
i++;];
Return[res];
];

(* expression after phase space integration for S-channel diagrams  with vectors  *)
SCVfunc[m1_,m2_,m3_,m4_,prop_,c1_,c2_]:=Block[{res,i},
res=0;
For[i=1,i<=getGen[prop],
res+=c1 c2  intSV[m1,m2,m3,m4,pmass[prop[i]]]/.propInd->i;
i++;];
Return[res];
];

(* expression after phase space integration for U-channel diagrams  with vectors  *)
UCVfunc[m1_,m2_,m3_,m4_,prop_,c1_,c2_]:=Block[{res,i},
res=0;
For[i=1,i<=getGen[prop],
res+=c1 c2 intUV[m1,m2,m3,m4,pmass[prop[i]]]/.propInd->i;
i++;];
Return[res];
];
(* result for the integrals after expressing everything in terms of s and cos\theta and external masses *)
intS[m1_,m2_,m3_,m4_,mP_]:=2/(-mP^2+s);
intT[m1_,m2_,m3_,m4_,mP_]:=(2 s Log[((m1-m2) (m1+m2) (m3-m4) (m3+m4)-(m1^2+m2^2+m3^2+m4^2-2 mP^2) s+s^2-Sqrt[(m1^4+(m2^2-s)^2-2 m1^2 (m2^2+s)) (m3^4+(m4^2-s)^2-2 m3^2 (m4^2+s))])/((m1-m2) (m1+m2) (m3-m4) (m3+m4)-(m1^2+m2^2+m3^2+m4^2-2 mP^2) s+s^2+Sqrt[(m1^4+(m2^2-s)^2-2 m1^2 (m2^2+s)) (m3^4+(m4^2-s)^2-2 m3^2 (m4^2+s))])])/Sqrt[(m1^4+(m2^2-s)^2-2 m1^2 (m2^2+s)) (m3^4+(m4^2-s)^2-2 m3^2 (m4^2+s))];
intU[m1_,m2_,m3_,m4_,mP_]:=(2 s Log[-(((m1-m2) (m1+m2) (m3-m4) (m3+m4)+(m1^2+m2^2+m3^2+m4^2-2 mP^2) s-s^2+Sqrt[(m1^4+(m2^2-s)^2-2 m1^2 (m2^2+s)) (m3^4+(m4^2-s)^2-2 m3^2 (m4^2+s))])/(-(m1-m2) (m1+m2) (m3-m4) (m3+m4)-(m1^2+m2^2+m3^2+m4^2-2 mP^2) s+s^2+Sqrt[(m1^4+(m2^2-s)^2-2 m1^2 (m2^2+s)) (m3^4+(m4^2-s)^2-2 m3^2 (m4^2+s))]))])/Sqrt[(m1^4+(m2^2-s)^2-2 m1^2 (m2^2+s)) (m3^4+(m4^2-s)^2-2 m3^2 (m4^2+s))];

intSV[m1_,m2_,m3_,m4_,mP_]:=(2 (m1-m2) (m1+m2) (m3-m4) (m3+m4))/((mP^2-s) s);
intTV[m1_,m2_,m3_,m4_,mP_]:=2+(4 (m1^2+m2^2+m3^2+m4^2-mP^2-2 s) s ArcCoth[((m1-m2) (m1+m2) (m3-m4) (m3+m4)-(m1^2+m2^2+m3^2+m4^2-2 mP^2) s+s^2)/(Sqrt[KL[s,m1^2,m2^2]] Sqrt[KL[s,m3^2,m4^2]])])/(Sqrt[KL[s,m1^2,m2^2]] Sqrt[KL[s,m3^2,m4^2]]);
intUV[m1_,m2_,m3_,m4_,mP_]:=2-(4 (m1^2+m2^2+m3^2+m4^2-mP^2-2 s) s ArcCoth[((m1-m2) (m1+m2) (m3-m4) (m3+m4)+(m1^2+m2^2+m3^2+m4^2-2 mP^2) s-s^2)/(Sqrt[KL[s,m1^2,m2^2]] Sqrt[KL[s,m3^2,m4^2]])])/(Sqrt[KL[s,m1^2,m2^2]] Sqrt[KL[s,m3^2,m4^2]]);


(* Kaehler function *)
KL[a_,b_,c_]:=a^2-2 a (b+c)+(b-c)^2
(* Sqrt(2) for identical states *)
Sqrt2[a_Integer,b_Integer]:=If[a==b,1/Sqrt[2],1];
pmass[conj[x_]]:=pmass[x];
pmass[a_[b_]]:=pmass[a]/;getGen[a]==1;


(* ::Input::Initialization:: *)

(*--------------------------*)
(* Build scattering matrix *)
(*--------------------------*)


BuildScatteringMatrix:=Block[{i,j,x1,x2,x3,x4},
matrix={};
For[i=1,i<=Length[scatteringPairs],
For[x1=1,x1<=getGen[scatteringPairs[[i,1]]],
x2start=1;
If[scatteringPairs[[i,1]]===scatteringPairs[[i,2]],x2start=x1;];
For[x2=x2start,x2<=getGen[scatteringPairs[[i,2]]],
row={};
For[j=1,j<=Length[scatteringPairs],
For[x3=1,x3<=getGen[scatteringPairs[[j,1]]],
x4start=1;
If[scatteringPairs[[j,1]]===scatteringPairs[[j,2]],x4start=x3;];
For[x4=x4start,x4<=getGen[scatteringPairs[[j,2]]],
row=Join[row,{GetDiagrams[scatteringPairs[[i,1]],scatteringPairs[[i,2]],conj[scatteringPairs[[j,1]]],conj[scatteringPairs[[j,2]]],{x1,x2,x3,x4}]}];
x4++;];
x3++;];
j++;];
matrix=Join[matrix,{row}];
x2++;];
x1++;];
i++;];


Return[matrix/.SC->SCfunc /. TC->TCfunc /. UC->UCfunc];
];


(* ::Input::Initialization:: *)
(*--------------------------*)
(* function to get numerical valus for masses and rotation angles *)
(*-----------------------------------*)

NumMasses[input_,tadpar_]:=Block[{i,j,mat,res},
res={};
solTad=Solve[TadpoleEquations[EWSB]==0,tadpar][[1]];
For[i=1,i<=Length[partS],
If[getGen[partS[[i]]]>1,
mat=MassMatrix[partS[[i]]/.conj[x_]->x] /. RXi[a__]->1 /.solTad//. input;
eigS=Eigensystem[mat];
(* one can ignore the warning! *)

res=Join[res,{getMixingMatrix[partS[[i]]][a__Integer]->eigS[[2]][[a]]}];
res=Join[res,Table[pmass[partS[[i]][jj]]->Sqrt[eigS[[1,jj]]],{jj,1,getGen[partS[[i]]]}]];,
res=Join[res,{pmass[partS[[i]][1]]->Sqrt[TreeMass[partS[[i]],EWSB]]/.RXi[a__]->XI/.solTad//.input}]];

i++;];
Return[res];
];
