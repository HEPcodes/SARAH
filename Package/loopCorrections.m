(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)

Options[CalcLoopCorrections]={ReadLists->False, OnlyWith->{}};

CalcLoopCorrections[Eigenstates_,opt___ ]:=CalcOneLoopCorrections[Eigenstates,ReadLists/.{opt}/.Options[CalcLoopCorrections],OnlyWith/.{opt}/.Options[CalcLoopCorrections]];

CalcOneLoopCorrections[Eigenstates_, ReadLists_,OnlyWith_]:=Block[{i,j,temp,entryParticles},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "CalcOneLoopCorrections";
SA`Doc`Info = "This is the main routine to perform the one-loop calculations for tadpoles and self-energies. It creates the necessary directories, generates a list with 'unroted' fields (i.e. the external gauge eigenstates), calls the different functions to perform the individual calculations, cleans up and stores the results.";
SA`Doc`Input={"Eigenstates"->"The considered eigenstates","ReadLists"->"Shall previous results be read?", "OnlyWith"->"Calculate only loops concerning the given list of particles"};
SA`Doc`GenerateEntry[];

If[VerticesForEigenstates=!=Eigenstates,
MakeVertexList[Eigenstates,VerticesForLoops->True];
];

SA`CurrentStates=Eigenstates;
SA`subUnrotedFieldsRotatedFields={};
SA`subRotatedFieldsUnrotedFields={};

massless=Massless[Eigenstates];

$sarahCurrentLoopDir=ToFileName[{$sarahCurrentOutputDir,"One-Loop"}];
If[FileExistsQ[$sarahCurrentLoopDir]=!=True,
CreateDirectory[$sarahCurrentLoopDir];
];

Print["Generate interaction list"];
MakeCouplingLists;

(*
Print["------------------------------------"];
Print["Calculate Loop Corrections"];
Print["------------------------------------"];
*)

Print[StyleForm["Calculate 1-loop corrections","Section",FontSize->12]];

CalculatedSelfEnergy={};
GaugeMassES={};
GaugeMassESorg={};
listAddedMasses={};
listNotMixedMasses={};
VerticesGaugeMassES={};
AddedVertex={};
entryParticles = {};

For[i=1,i<=Length[Particles[Current]],
GaugeMassES=Join[GaugeMassES,{ToExpression["U"<>ToString[Particles[Current][[i,1]]  /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates]]]}];
GaugeMassESorg=Join[GaugeMassESorg,{Particles[Current][[i,1]]  /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates]}];

If[FreeQ[MajoranaPart,Particles[Current][[i,1]]  /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates]]==False,
MajoranaPart = Join[MajoranaPart,{ToExpression["U"<>ToString[Particles[Current][[i,1]]  /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates]]]}];
];

If[FreeQ[realVar,Particles[Current][[i,1]]]==False,
realVar = Join[realVar,{ToExpression["U"<>ToString[Particles[Current][[i,1]] ]]}];
];
i++;];


Print["  For rotated fields"];
(* Print["------------------------------------"]; *)
OneLoopMassMatrices[Eigenstates];
getUnmixedMasses[Eigenstates];

Print["  For tadpoles"];
(* Print["------------------------------------"]; *)
OneLoopTadpoles[Eigenstates];

Print["  For gauge eigenstates"];
(* Print["------------------------------------"]; *)
OneLoopNotMixed[listNotMixedMasses, Eigenstates];
OneLoopSelfEnergy[Eigenstates]=CalculatedSelfEnergy;

(*
If[SA`AddOneLoopDecay === True,
OneLoopDifferentExternal[Eigenstates];
];

*)
OneLoopDifferentExternal[Eigenstates];

SelfEnergy1LoopListtemp[Eigenstates]=Join[LoopCorrectionMassMatrices[Eigenstates],LoopCorrectionUnmixed[Eigenstates]];
SelfEnergy1LoopSum[Eigenstates] = Join[SelfEnergies1Loop[Eigenstates],SelfEnergyUnmixed[Eigenstates]];
ParticlesSelfEnergy1LoopSum[Eigenstates]=entryParticles;
Tadpoles1LoopSum[Eigenstates] = Tadpoles1Loop[Eigenstates];

If[Head[DEFINITION[Eigenstates][VEVs]]===List,
Tadpoles1LoopList[Eigenstates]={};
For[i=1,i<=Length[LoopCorrectionTadpoles[Eigenstates]],
If[LoopCorrectionTadpoles[Eigenstates][[i]]=!={},
(* Tadpoles1LoopList[Eigenstates]=Join[Tadpoles1LoopList[Eigenstates],{ Delete[LoopCorrectionTadpoles[Eigenstates][[i]],2] /. gI2\[Rule]gI1}]; *)
Tadpoles1LoopList[Eigenstates]=Join[Tadpoles1LoopList[Eigenstates],{ LoopCorrectionTadpoles[Eigenstates][[i]]/. gI2->gI1}];
];
i++];,
Tadpoles1LoopList[Eigenstates]={};
];

SelfEnergy1LoopList[Eigenstates]={};

Print["   Simplify expression"];

SA`LoopMassesParticle={};

For[i=1,i<=Length[LoopCorrectionMassMatrices[Eigenstates]],
(* calcPart=DEFINITION[Eigenstates][MatterSector][[i,2,1]]; *)
calcPart=SA`BasisForMassLoop[[i,2,1]];
If[Length[calcPart]==2,
temp={calcPart[[1]] /. diracSubBack1[Eigenstates]  /. diracSubBack2[Eigenstates]};,
temp={calcPart /. diracSubBack1[Eigenstates]  /. diracSubBack2[Eigenstates]};
];
SA`LoopMassesParticle=Join[SA`LoopMassesParticle,temp];
For[j=1,j<=Length[LoopCorrectionMassMatrices[Eigenstates][[i]]],
If[LoopCorrectionMassMatrices[Eigenstates][[i,j,4]]===SSSS || LoopCorrectionMassMatrices[Eigenstates][[i,j,4]]===SSVV || LoopCorrectionMassMatrices[Eigenstates][[i,j,4]]===VVVV,
temp = Join[temp,{Delete[LoopCorrectionMassMatrices[Eigenstates][[i,j]],2] /. gI2->gI1}];,
temp = Join[temp,{ LoopCorrectionMassMatrices[Eigenstates][[i,j]]}];
];
j++;];
SelfEnergy1LoopList[Eigenstates] = Join[SelfEnergy1LoopList[Eigenstates],{temp}];
i++];


For[i=1,i<=Length[LoopCorrectionUnmixed[Eigenstates]],
calcPart=ListUnmixed[Eigenstates][[i,1]];
temp={calcPart /. diracSubBack1[Eigenstates]  /. diracSubBack2[Eigenstates]};
If[Length[LoopCorrectionUnmixed[Eigenstates][[i]]]>1,
For[j=1,j<=Length[LoopCorrectionUnmixed[Eigenstates][[i]]],
If[LoopCorrectionUnmixed[Eigenstates][[i,j,4]]===SSSS || LoopCorrectionUnmixed[Eigenstates][[i,j,4]]===SSVV || LoopCorrectionUnmixed[Eigenstates][[i,j,4]]===VVVV,
temp = Join[temp,{Delete[LoopCorrectionUnmixed[Eigenstates][[i,j]],2] /. gI2->gI1}];,
temp = Join[temp,{LoopCorrectionUnmixed[Eigenstates][[i,j]]}];
];
j++;];
SelfEnergy1LoopList[Eigenstates] = Join[SelfEnergy1LoopList[Eigenstates],{temp}];
];
i++];

If[OnlyWith=!={},
Print["Removing light field contributions"];
LoopCorrectionMassMatrices[Eigenstates] = DeleteLightFieldContributions[LoopCorrectionMassMatrices[Eigenstates],OnlyWith,listAddedMasses];
LoopCorrectionUnmixed[Eigenstates] = DeleteLightFieldContributions[LoopCorrectionUnmixed[Eigenstates],OnlyWith,Transpose[ListUnmixed[Eigenstates]][[1]]];
Tadpoles1Loop[Eigenstates] = DeleteLightFieldContrubtions[Tadpoles1Loop[Eigenstates],OnlyWith,True];
VerticesGaugeMassESsave = VerticesGaugeMassES;
VerticesGaugeMassES = DeleteLightFieldVertices[VerticesGaugeMassES, OnlyWith];
];

Put[OneLoopSelfEnergy[Eigenstates],ToFileName[$sarahCurrentLoopDir,"SelfEnergy.m"]];
Put[SelfEnergies1Loop[Eigenstates],ToFileName[$sarahCurrentLoopDir,"SelfEnergyRotatedFields.m"]];
Put[SelfEnergyUnmixed[Eigenstates],ToFileName[$sarahCurrentLoopDir,"SelfEnergyUnrotatedFields.m"]];
Put[Tadpoles1Loop[Eigenstates],ToFileName[$sarahCurrentLoopDir,"Tadpoles1Loop.m"]];
Put[LoopCorrectionMassMatrices[Eigenstates],ToFileName[$sarahCurrentLoopDir,"SelfEnergyRotatedFields-list.m"]];
Put[LoopCorrectionUnmixed[Eigenstates],ToFileName[$sarahCurrentLoopDir,"SelfEnergyUnrotatedFields-list.m"]];
Put[LoopCorrectionTadpoles[Eigenstates],ToFileName[$sarahCurrentLoopDir,"Tadpoles1Loop-list.m"]];
Put[ListUnmixed[Eigenstates],ToFileName[$sarahCurrentLoopDir,"UnrotatedParticles.m"]];
Put[VerticesGaugeMassES,ToFileName[$sarahCurrentLoopDir,"NewVertices.m"]]; 


CalculatedLoopCorrections=Eigenstates;

SA`Doc`EndEntry[];
];


(* ::Input::Initialization:: *)
 OneLoopNotMixed[particles_, Eigenstates_]:=Block[{i,j},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "OneLoopNotMixed";
SA`Doc`Info = "This routine calculates the one-loop self-energies for fields which don't mix, i.e. which only show up in one generation. In this case the gauge and mass eigenstates of the external fields are identical.";
SA`Doc`Input={"particles"->"The list of particles for which the one-loop self-energies shall be calculated","Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

CorrectionList = Table[0,{Length[particles]}];
OneLoopProp = Table[0,{Length[particles]}];
Print["    ... processing: ",Dynamic[DynamicOneLoopNameNM],"(",Dynamic[DynamicOneLoopNrNM],"/",Length[particles],")"];
For[i=1,i<=Length[particles],
DynamicOneLoopNrNM=i;
DynamicOneLoopNameNM=particles[[i,1]];
If[FreeQ[massless,particles[[i,1]]]==True || getType[particles[[i,1]]]===V  || getType[particles[[i,1]]]===F, 
particle=particles[[i,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
(* Print["    Calculate One Loop Self Energy of ",particle]; *)

Switch[getType[particle],
  S,temp=Join[ThreeParticleVertex2[particle],FourParticleVertex2[particle]];,
  V,temp=Join[ThreeParticleVertex2[particle],FourParticleVertex2[particle]];,
  F,temp=ThreeParticleVertex2check[particle];
];

If[getGen[particle]>1,

CorrectionList[[i]]=temp /.{particle[{gO1,a___}]-> ToExpression["U"<>ToString[particle]][{gO1,a}],particle[{gO2,a___}]-> ToExpression["U"<>ToString[particle]][{gO2,a}]};

SA`subUnrotedFieldsRotatedFields=Join[SA`subUnrotedFieldsRotatedFields,{ ToExpression["U"<>ToString[particle]]->particle}];
SA`subRotatedFieldsUnrotedFields=Join[SA`subRotatedFieldsUnrotedFields,{ particle->ToExpression["U"<>ToString[particle]]}];

LoopCorrection=0;
For[j=1,j<=Length[temp],
 VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddUnrotatedVertex[{temp[[j,4]],AntiField[particle],temp[[j,1]],temp[[j,2]]},None],temp[[j,4]]}}];
If[temp[[j,4]]===GGS && C@@(AntiField/@Cp[AntiField[particle],temp[[j,1]],temp[[j,2]]])=!=C@@Cp[AntiField[particle],temp[[j,1]],temp[[j,2]]],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddUnrotatedVertex[{temp[[j,4]],particle,AntiField[temp[[j,1]]],AntiField[temp[[j,2]]]}],temp[[j,4]]}}]; 
];
LoopCorrection += AddLoop2[particle,temp[[j]]] /. {Mass[conj[x_]]->Mass[x],Mass[bar[x_]]->Mass[x],Mass2[conj[x_]]->Mass2[x],Mass2[bar[x_]]->Mass2[x]};
j++;];,

LoopCorrection=0;
CorrectionList[[i]]=temp ;
For[j=1,j<=Length[temp],
If[FreeQ[AddedVertex,temp[[j,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C],
 VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddVertex[{temp[[j,4]],AntiField[particle],temp[[j,1]],temp[[j,2]]}],temp[[j,4]]}}]; 
 AddedVertex=Join[AddedVertex,{temp[[j,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C}];
If[temp[[j,4]]===GGS && C@@(AntiField/@Cp[AntiField[particle],temp[[j,1]],temp[[j,2]]])=!=C@@Cp[AntiField[particle],temp[[j,1]],temp[[j,2]]],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddVertex[{temp[[j,4]],particle,AntiField[temp[[j,1]]],AntiField[temp[[j,2]]]}],temp[[j,4]]}}]; 
 AddedVertex=Join[AddedVertex,{AntiField/@temp[[j,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C}];
];
]; 
LoopCorrection += AddLoop2[particle,temp[[j]]]/. {Mass[conj[x_]]->Mass[x],Mass[bar[x_]]->Mass[x],Mass2[conj[x_]]->Mass2[x],Mass2[bar[x_]]->Mass2[x]};
j++;];


];
OneLoopProp[[i]]=LoopCorrection;
CalculatedSelfEnergy= Join[CalculatedSelfEnergy,{{particle,LoopCorrection}}];,
OneLoopProp[[i]]=0;
];
entryParticles=Join[entryParticles,{particle}];


i++;];

LoopCorrectionUnmixed[Eigenstates]=CorrectionList;
SelfEnergyUnmixed[Eigenstates]=OneLoopProp;

SA`Doc`EndEntry[];
];


 OneLoopFieldMixing[particles_, Eigenstates_]:=Block[{i,j,subUF},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "OneLoopFieldMixing";
SA`Doc`Info="This routine calculates the one-loop self-energies between two different, external particles.";
SA`Doc`Input={"particles"->"The list of particles for which the one-loop self-energies shall be calculated","Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

CorrectionList = Table[0,{Length[particles]}];
OneLoopProp = Table[0,{Length[particles]}];

Print["    ... processing: ",Dynamic[DynamicOneLoopNameFM],"(",Dynamic[DynamicOneLoopNrFM],"/",Length[particles],")"];

For[i=1,i<=Length[particles],
particle1=particles[[i,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
particle2=particles[[i,2]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
(* Print["    Calculate One Loop Self Energy of ",particle]; *)
DynamicOneLoopNrFM=i;
DynamicOneLoopNameFM=particle;


temp=InsFields[{{C[particle1,FieldToInsert[1],AntiField[FieldToInsert[2]]],C[AntiField[particle2],AntiField[FieldToInsert[1]],FieldToInsert[2]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],External[1]->particle1,External[2]->AntiField[particle2]}}];
temp = Join[temp,
InsFields[{{C[particle1,FieldToInsert[1],AntiField[FieldToInsert[2]],AntiField[particle2]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],External[1]->particle1,External[2]->AntiField[particle2]}}];
];


If[getGen[particle1]>1,subUF = Join[subUF,{particle1[{gO1,a___}]-> ToExpression["U"<>ToString[particle1]][{gO1,a}]}];];
If[getGen[particle2]>1,subUF = Join[subUF,{particle2[{gO2,a___}]-> ToExpression["U"<>ToString[particle1]][{gO2,a}]}];];


LoopCorrection=0;
CorrectionList[[i]]=temp ;
For[j=1,j<=Length[temp],
 LoopCorrection += AddLoop2mix[particle1,particle2,temp[[j]]] /. {Mass[conj[x_]]->Mass[x],Mass[bar[x_]]->Mass[x],Mass2[conj[x_]]->Mass2[x],Mass2[bar[x_]]->Mass2[x]};
j++;];


OneLoopProp[[i]]=LoopCorrection;
CalculatedSelfEnergy= Join[CalculatedSelfEnergy,{{particle,LoopCorrection}}];
entryParticles=Join[entryParticles,{particle}];


i++;];

LoopCorrectionUnmixed[Eigenstates]=CorrectionList;
SelfEnergyUnmixed[Eigenstates]=OneLoopProp;

SA`Doc`EndEntry[];

];


OneLoopMassMatrices[Eigenstates_]:=Block[{i,j,i1,i2,i3,i4,temp,cbasis},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "OneLoopMassMatrices";
SA`Doc`Info = "This routine calculates the one-loop self-energies for fields which mix, i.e. the corrections to the tree-level mass matrix. In this case the external particles are replaced by 'unrotated' fields, i.e. gauge eigenstates. The names of the unrotated fields start with 'U'. \n
The results are stored in two ways: as sum over all contributions as well as list of all contributions. The necessary vertices involving unrotated fields are stored in the list 'VerticesGaugeMassES' which is for instance used later by MakeSPheno.";
SA`Doc`Input ={"Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];
 
basis={};

For[i=1,i<=Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[i]]][MatterSector]]===List,
cbasis= DEFINITION[NameOfStates[[i]]][MatterSector];
For[j=1,j<=Length[cbasis],
If[Length[RE[cbasis[[j,2,1]]]]==0,
If[FreeQ[Particles[Eigenstates],RE[cbasis[[j,2,1]]]]==False && getTypeOld[cbasis[[j,2,1]]]=!=A,
basis=Join[basis,{cbasis[[j]]}];
];,
If[FreeQ[Particles[Eigenstates],cbasis[[j,2,1,1]]]==False,
basis=Join[basis,{cbasis[[j]]}];
];
];
j++;];
];
i++;];

SA`BasisForMassLoop=basis;

(* basis =DEFINITION[Eigenstates][MatterSector];

If[Head[basis]=!=List,basis={};];
*)

CorrectedMassMatrices=Table[0,{Length[basis]}];
CorrectionList=Table[0,{Length[basis]}];

Print["  ... processing: ",Dynamic[DynamicOneLoopNameMM],"(",Dynamic[DynamicOneLoopNrMM],"/",Length[basis],")"];

 For[i=1,i<=Length[basis], 
DynamicOneLoopNrMM=i;
If[Length[basis[[i,2,1]]]==0,
DynamicOneLoopNameMM=basis[[i,2,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
(*Print["    Calculate One Loop Self Energy of ",basis[[i,2,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates]];*),
DynamicOneLoopNameMM=basis[[i,2,1,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
(*Print["    Calculate One Loop Self Energy of ",basis[[i,2,1,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates]];*)
];

If[Length[Dimensions[basis[[i,2]]]]==1,
OneLoopMassMatrix=Table[0,{Length[basis[[i,1]]]},{Length[basis[[i,1]]]}];
particle=basis[[i,2,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
unrotateMatrix=basis[[i,2,2]];,
OneLoopMassMatrix=Table[0,{Length[basis[[i,1,1]]]},{Length[basis[[i,1,1]]]}];
particle=basis[[i,2,1,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
unrotateMatrix={basis[[i,2,1,2]],basis[[i,2,2,2]]};
];

listAddedMasses=Join[listAddedMasses,{particle}];

Switch[getType[particle],
 S,temp=Join[ThreeParticleVertex2[particle],FourParticleVertex2[particle]];,
  V,temp=Join[ThreeParticleVertex2[particle],FourParticleVertex2[particle]];,
  F,temp=ThreeParticleVertex2check[particle];
];

SA`subUnrotedFieldsRotatedFields=Join[SA`subUnrotedFieldsRotatedFields,{ ToExpression["U"<>ToString[particle]]->particle}];
SA`subRotatedFieldsUnrotedFields=Join[SA`subRotatedFieldsUnrotedFields,{ particle->ToExpression["U"<>ToString[particle]]}];

If[getGen[particle]>1,
CorrectionList[[i]]=temp /.{particle[{gO1,a___}]-> ToExpression["U"<>ToString[particle]][{gO1,a}],particle[{gO2,a___}]-> ToExpression["U"<>ToString[particle]][{gO2,a}]};,
CorrectionList[[i]]=temp;
];

LoopCorrection=0;
For[j=1,j<=Length[temp],
If[getGen[particle]>1,
LoopCorrection += AddLoop2[basis[[i,2,1]],temp[[j]] /.{particle[{gO1,a___}]-> ToExpression["U"<>ToString[particle]][{gO1,a}],particle[{gO2,a___}]-> ToExpression["U"<>ToString[particle]][{gO2,a}]}] /. {Mass[conj[x_]]->Mass[x],Mass[bar[x_]]->Mass[x],Mass2[conj[x_]]->Mass2[x],Mass2[bar[x_]]->Mass2[x]};,
LoopCorrection += AddLoop2[basis[[i,2,1]],temp[[j]]] /. {Mass[conj[x_]]->Mass[x],Mass[bar[x_]]->Mass[x],Mass2[conj[x_]]->Mass2[x],Mass2[bar[x_]]->Mass2[x]};
];


If[FreeQ[AddedVertex,(CorrectionList[[i,j,3]]  /. A_[{a___}]->a)/. Cp ->C],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddUnrotatedVertex[{temp[[j,4]],AntiField[particle],temp[[j,1]],temp[[j,2]]},unrotateMatrix],temp[[j,4]]}}];
AddedVertex=Join[AddedVertex,{(CorrectionList[[i,j,3]]  /. A_[{a___}]->A)/. Cp ->C}];
If[temp[[j,4]]===GGS && C@@(AntiField/@Cp[AntiField[particle],temp[[j,1]],temp[[j,2]]])=!=C@@Cp[AntiField[particle],temp[[j,1]],temp[[j,2]]],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddUnrotatedVertex[{temp[[j,4]],particle,AntiField[temp[[j,1]]],AntiField[temp[[j,2]]]},unrotateMatrix],temp[[j,4]]}}]; 
 AddedVertex=Join[AddedVertex,{(AntiField/@CorrectionList[[i,j,3]]  /. A_[{a___}]->A)/. Cp ->C}];
];
];

  

j++;];

CorrectedMassMatrices[[i]]=LoopCorrection;

If[Length[basis[[i,2,1]]]==2,
CalculatedSelfEnergy= Join[CalculatedSelfEnergy,{{basis[[i,2,1]][[1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates],LoopCorrection}}];,
CalculatedSelfEnergy= Join[CalculatedSelfEnergy,{{basis[[i,2,1]],LoopCorrection}}];
];

entryParticles=Join[entryParticles,{particle}];
i++;];


SelfEnergies1Loop[Eigenstates]=CorrectedMassMatrices;
LoopCorrectionMassMatrices[Eigenstates]=CorrectionList;

SA`Doc`EndEntry[];
];


OneLoopTadpoles[Eigenstates_]:=Block[{i,vevs,scalars,temp,vevNr,i1,i2, res,par1,basis,particlelist,temp3,pos,k},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "OneLoopTadpoles";
SA`Doc`Info = "This routine calculates the one-loopt tadpoles. In this case the external particles are replaced by 'unrotated' fields, i.e. gauge eigenstates. The names of the unrotated fields start with 'U'. \n
The results are stored in two ways: as sum over all contributions as well as list of all contributions. It's assumed that no new vertices are needed compared to the self-energy calculation, i.e.  'VerticesGaugeMassES' is not further extended here.";
SA`Doc`Input ={"Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

TEqu={};
basis={};
vevs={};

For[k=1,k<=Length[NameOfStates],
If[Head[TadpoleEquations[NameOfStates[[k]]]]===List,
TEqu=Join[TEqu,TadpoleEquations[NameOfStates[[k]]]];
];
If[Head[DEFINITION[NameOfStates[[k]]][MatterSector]]===List,
basis=Join[basis,DEFINITION[NameOfStates[[k]]][MatterSector]];
];
If[Head[DEFINITION[NameOfStates[[k]]][VEVs]]===List,
vevs=Join[vevs,DEFINITION[NameOfStates[[k]]][VEVs]  /. {b__,{a_}}->{b}];
];
k++;];

SA`vevsForLoop=vevs;

neededVerticesForTadpoles={};
CorrectionListTadpoles={};

Print["    ... processing: ",Dynamic[DynamicOneLoopTadName],"(",Dynamic[DynamicOneLoopTadNr],"/",Dynamic[DynamicOneLoopTadNrAll],")"];

If[Head[vevs]===List && vevs=!={},
scalars=Transpose[Transpose[vevs][[4]]][[1]];
vevNames=Transpose[Transpose[vevs][[2]]][[1]];
TadpolesLoop ={};
ScalarsForTadpoles={};
UnrotatedFieldsTadpoles={};
listVEVseparated={};

For[i=1,i<=Length[vevNames],
particle = scalars[[i]];
DynamicOneLoopTadNrAll=Length[vevNames];
DynamicOneLoopTadNr=i;
DynamicOneLoopTadName=particle;

If[FreeQ[basis,particle]==False,
pos = Position[basis,particle][[1,1]];
particle = basis[[pos,2,1]];
];

If[FreeQ[ScalarsForTadpoles,particle] && FreeQ[listVEVseparated,vevNames[[i]]],
ScalarsForTadpoles=Join[ScalarsForTadpoles,{particle}];


temp=ThreeParticleVertex2[particle];
temp2={};


For[i1=1,i1<=Length[temp],
If[AntiField[temp[[i1,1]]]===temp[[i1,2]] && FreeQ[MasslessBosons,temp[[i1,1]]]==True,
temp2=Join[temp2,{temp[[i1]]}];
];
i1++;];

If[getGen[particle]>1,
CorrectionListTadpoles=Join[CorrectionListTadpoles,{temp2 /.{particle[{gO1,a___}]-> ToExpression["U"<>ToString[particle]][{gO1,a}]}}];
neededVerticesForTadpoles = Join[neededVerticesForTadpoles,{ ToExpression["U"<>ToString[particle]]}];
UnrotatedFieldsTadpoles=Join[UnrotatedFieldsTadpoles,{ToExpression["U"<>ToString[particle]]}];,
CorrectionListTadpoles=Join[CorrectionListTadpoles,{temp2}];
neededVerticesForTadpoles = Join[neededVerticesForTadpoles,{particle}];
UnrotatedFieldsTadpoles=Join[UnrotatedFieldsTadpoles,{particle}];
];


LoopCorrection=0;
For[j=1,j<=Length[temp2],
If[temp2[[j,1]]===AntiField[temp2[[j,2]]],
LoopCorrection  +=AddLoop1[particle,temp2[[j]]] /. {Mass[conj[x_]]->Mass[x],Mass[bar[x_]]->Mass[x],Mass2[conj[x_]]->Mass2[x],Mass2[bar[x_]]->Mass2[x]};
];
j++;];

temp={};
 For[i1=1,i1<=Length[vevNames],
(* If[ScalarToVEV[vevNames[[i1]],Eigenstates]===particle, *)
If[ScalarToVEV[vevNames[[i1]]]===particle,
temp=Join[temp,{vevNames[[i1]]}];
];
i1++;];
listVEVseparated = Join[listVEVseparated,{temp}];

If[getGen[particle]>1,
TadpolesLoop = Join[TadpolesLoop,{{particle, LoopCorrection /.{particle[{gO1,a___}]-> ToExpression["U"<>ToString[particle]][{gO1,a}]}}}];,
TadpolesLoop =Join[TadpolesLoop,{{particle, LoopCorrection }}];
];

];
i++;];

Tadpoles1Loop[Eigenstates]=TadpolesLoop;
LoopCorrectionTadpoles[Eigenstates]=CorrectionListTadpoles;,

Tadpoles1Loop[Eigenstates]={{}};
LoopCorrectionTadpoles[Eigenstates]={{}};
];

SA`Doc`EndEntry[];
];


ScalarToVEV[x_, Eigenstates_]:=Block[{pos,i,s,basis},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "ScalarToVEV";
SA`Doc`Info = "Takes the name of a scalar field and returns the associated VEV";
SA`Doc`Input={"x"->"The considered scalar particle","Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

pos=Position[Transpose[Transpose[DEFINITION[Eigenstates][VEVs]/. {b__,{a_}}->{b}][[2]]][[1]],x][[1,1]];
s=Transpose[Transpose[DEFINITION[Eigenstates][VEVs]/. {b__,{a_}}->{b}][[4]]][[1]][[pos]];
If[FreeQ[DEFINITION[Eigenstates][MatterSector],s],
SA`Doc`Return[s];,

pos = Position[DEFINITION[Eigenstates][MatterSector],s][[1,1]];
SA`Doc`Return[DEFINITION[Eigenstates][MatterSector][[pos,2,1]]];
];
];

ScalarToVEV[x_]:=Block[{pos,i5,s,basis,found=False},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "ScalarToVEV";
SA`Doc`Info = "Takes the name of a scalar field and returns the associated VEV (looking through all possible eigenstates)";
SA`Doc`Input={"x"->"The considered scalar particle"};
SA`Doc`GenerateEntry[];

For[i5=1,i5<=Length[NameOfStates],
If[FreeQ[DEFINITION[NameOfStates[[i5]]][VEVs],x]==False,
pos=Position[Transpose[Transpose[DEFINITION[NameOfStates[[i5]]][VEVs]/. {b__,{a_}}->{b}][[2]]][[1]],x][[1,1]];
s=Transpose[Transpose[DEFINITION[NameOfStates[[i5]]][VEVs]/. {b__,{a_}}->{b}][[4]]][[1]][[pos]];
];
i5++;];
For[i5=1,i5<=Length[NameOfStates],
If[FreeQ[DEFINITION[NameOfStates[[i5]]][MatterSector],s]==False,
pos = Position[DEFINITION[NameOfStates[[i5]]][MatterSector],s][[1,1]];
found=True;
res=DEFINITION[NameOfStates[[i5]]][MatterSector][[pos,2,1]];
];
i5++;];
If[found=!=True,
SA`Doc`Return[s];,
SA`Doc`Return[res];
];
];

AddLoop1[particle_,corrections_]:=Block[{temp,m1,m2,m0,i,vCur,vCur2},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "AddLoop1";
SA`Doc`Info = "Generates the expression for an one-loop correction to a tadpole";
SA`Doc`Input={"particle"->"The considered, external particle","corrections"->"A list contatining the particle in the loop as well as the vertex"};
SA`Doc`GenerateEntry[];

If[getGen[corrections[[1]]]>1,
m1=Mass[corrections[[1]][{gI1}]]/. Mass->Mass2;
m2=Mass[corrections[[1]][{gI1}]];,
m1=Mass[corrections[[1]]]/. Mass->Mass2;
m2=Mass[corrections[[1]]];
];
If[m1=!=0,
vCur = corrections[[3]] /. {gI2 ->gI1}; 
Switch[getType[corrections[[1]]],
S,amp = -A0[m1] vCur;,
V,amp =  4 (A0[m1] -1/2 rMS m1) vCur;,
F,amp = 2 A0[m1] m2 (vCur[PL]+vCur[PR]);,
G, amp =  A0[m1] vCur;
];
fac =2* corrections[[5]]*corrections[[6]];
SA`Doc`Return[fac*sum[gI1,1,getGen[corrections[[1]]],amp]];,
SA`Doc`Return[0];
];
];


(* ::Input::Initialization:: *)

OrderMasses[p1_,p2_,type_]:=Block[{m1,m2},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "OrderMasses";
SA`Doc`Info = "Brings the two masses in the loop of a self-energy into a well defined order to match the generic expressions.";
SA`Doc`Input={"p1"->"First particle","p2"->"Second particle","type"->"Generic type of the particle"};
SA`Doc`GenerateEntry[];

If[getType[p1]===type,
If[getGen[p1]>1,m1 =Mass[p1[{gI1}]];,m1=Mass[p1];];
If[getGen[p2]>1,m2 = Mass[p2[{gI2}]];,m2=Mass[p2];];,
If[getGen[p2]>1,m1 =Mass[p2[{gI1}]];,m1=Mass[p2];];
If[getGen[p1]>1,m2 = Mass[p1[{gI2}]];,m2=Mass[p1];];
];
SA`Doc`Return[{m1,m2}];
];

AddLoop2[particle_,correction_]:=Block[{part},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "AddLoop2";
SA`Doc`Info = "Generates the expression for an one-loop correction to a self-energy";
SA`Doc`Input={"particle"->"The considered, external particle","corrections"->"A list contatining the particles in the loop as well as the vertices"};
SA`Doc`GenerateEntry[];

If[Length[particle]==2,part=particle[[1]];,part=particle];
Switch[getTypeOld[part],
S, SA`Doc`Return[AddLoopScalar[part,correction]];,
F, SA`Doc`Return[AddLoopFermion[part,correction]];,
V, SA`Doc`Return[AddLoopVector[part,correction]];
];
];

AddLoopScalar[particle_,corrections_]:=Block[{temp,m1,m2,m0,mS,mV,v,fac,m12,m22},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "AddLoopScalar";
SA`Doc`Info = "Adds a self-energy correction to scalar fields";
SA`Doc`Input={"particle"->"The considered, external particle","corrections"->"A list contatining the particles in the loop as well as the vertices"};
SA`Doc`GenerateEntry[];

If[corrections[[4]]===FFS,
temp=OrderMasses[corrections[[1]],corrections[[2]],F];
m12=temp[[1]]/. Mass->Mass2;
m22=temp[[2]]/. Mass->Mass2;
m1 = temp[[1]];
m2 = temp[[2]];

If[FreeQ[m1,RE[corrections[[1]]]] && FreeQ[m2,RE[corrections[[2]]]],
m1 = m1 /. gI1->gI2;
m12 = m12 /. gI1->gI2;
m22 = m22 /. gI2->gI1;
m2 = m2 /. gI2->gI1;
];

coupL1=corrections[[3]][PL];
coupR1=corrections[[3]][PR];
coupL2= conj[corrections[[3]][PL]]/. {gO1 ->gO2};
coupR2= conj[corrections[[3]][PR]]/. {gO1 ->gO2};
pi1LoopA=-2 m1 m2 (coupL1*coupR2+coupR1*coupL2)*B0[p^2,m12,m22] ;
pi1LoopB=(coupL1*coupL2+coupR1*coupR2)*G0[p^2,m12,m22] ;
pi1LoopA =pi1LoopA* corrections[[6]]*corrections[[5]];
pi1LoopB =pi1LoopB* corrections[[6]]*corrections[[5]];
If[AntiField[particle]===particle,
SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],2 pi1LoopA]]+sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]], 2 pi1LoopB]]];,
SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1LoopA]]+sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1LoopB]]];
];,


temp=OrderMasses[corrections[[1]],corrections[[2]],S];
m11=temp[[1]]; m12=temp[[1]]/. Mass->Mass2; m21=temp[[2]]; m22=temp[[2]]/. Mass->Mass2;

If[FreeQ[m11,RE[corrections[[1]]]] && FreeQ[m21,RE[corrections[[2]]]] ,
m11 = m11 /. gI1->gI2;
m12 = m12 /. gI1->gI2;
m22 = m22 /. gI2->gI1;
m21 = m21 /. gI2->gI1;
];
coup1=corrections[[3]]; coup2=conj[corrections[[3]]]/. {gO1 ->gO2};

Switch[corrections[[4]],
	SSS,
		
		pi1Loop = coup1*coup2*B0[p^2,m12,m22];
		If[conj[particle]===particle,
		pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
		];
		SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,

	SSV,
		pi1Loop = coup1*coup2*F0[p^2,m12,m22];
		If[conj[particle]===particle,
		pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
		];
		SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,
	SVV,
		pi1Loop = 4 coup1*coup2*(B0[p^2,m12,m22]-1/2 rMS);
		If[conj[particle]===particle,
		pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
		];
		SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,

	GGS,
		If[conj[particle]===particle,
		pi1Loop = - coup1 (coup1/. {gO1 ->gO2})*B0[p^2,m12,m22];
		pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
		coup2=(AntiField/@corrections[[3]])/. {gO1 ->gO2};
		pi1Loop = - coup1*coup2*B0[p^2,m12,m22];
		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
		];
				SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,
	
	SSVV,
	If[m12=!=0,
		pi1Loop  = 4 coup1*(A0[m12]-1/2 rMS*m12);
		pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]]  /. {gI2 ->gI1}/. Cp[a___,b_[{gO1,c1___}],c___,conj[d_[{gO1,c2___}]],e___]->Cp[a,b[{gO1,c1}],c,conj[d[{gO2,c2}]],e] /. Cp[a___,b_[{gO1,c1___}],c___,d_[{gO1,c2___}],e___]->Cp[a,b[{gO1,c1}],c,d[{gO2,c2}],e];
		SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],pi1Loop]];,
		SA`Doc`Return[0];
	];,

	SSSS,
	If[m12=!=0,
		pi1Loop  = -coup1 A0[m12];
		pi1Loop =pi1Loop* corrections[[6]]  /. {gI2 ->gI1} /. Cp[a___,b_[{gO1,c1___}],c___,conj[d_[{gO1,c2___}]],e___]->Cp[a,b[{gO1,c1}],c,conj[d[{gO2,c2}]],e] /. Cp[a___,b_[{gO1,c1___}],c___,d_[{gO1,c2___}],e___]->Cp[a,b[{gO1,c1}],c,d[{gO2,c2}],e];
		If[corrections[[5]]<500, 
		SA`Doc`Return[corrections[[5]]  sum[gI1,1,getGen[corrections[[1]]],pi1Loop]];,
		SA`Doc`Return[C  sum[gI1,1,getGen[corrections[[1]]],pi1Loop]];
		];,
		SA`Doc`Return[0];
	];
	];
]; 
];

AddLoopFermion[particle_,corrections_]:=Block[{temp,m1,m2,m0,mS,mV,v,fac,m11,m12,m21,m22},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "AddLoopFermion";
SA`Doc`Info = "Adds a self-energy correction to fermion fields";
SA`Doc`Input={"particle"->"The considered, external particle","corrections"->"A list contatining the particles in the loop as well as the vertices"};
SA`Doc`GenerateEntry[];

temp=OrderMasses[corrections[[1]], corrections[[2]], F];
m11=temp[[1]]; m12=temp[[1]]/. Mass->Mass2; m21=temp[[2]]; m22=temp[[2]]/. Mass->Mass2;
coupL1= corrections[[3]][PL];
coupR1= corrections[[3]][PR];
coupL2= conj[corrections[[3]][PL]]/. {gO1 ->gO2};
coupR2= conj[corrections[[3]][PR]]/. {gO1 ->gO2};	

If[FreeQ[m11,corrections[[1]]] && FreeQ[m21,corrections[[2]]],
m11 = m11/. gI1->gI2;
m12 = m12 /. gI1->gI2;
m22 = m22 /. gI2->gI1;
m21 = m21 /. gI2->gI1;
];


Switch[corrections[[4]],
	FFS,
		Sigma1LoopS= sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],m11 coupR1*coupL2*B0[p^2,m12,m22] corrections[[6]]*corrections[[5]]]];
		Sigma1LoopR =sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]], -1/2coupR1*coupR2*(B1[p^2,m12,m22]) corrections[[6]]*corrections[[5]]]];
		Sigma1LoopL=sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],-1/2coupL1*coupL2*(B1[p^2,m12,m22]) corrections[[6]]*corrections[[5]]]];,

	FFV,
		Sigma1LoopS= sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],-4 m11 coupL1*coupR2*(B0[p^2,m12,m22] -1/2 rMS)corrections[[6]]*corrections[[5]]]];
		Sigma1LoopR = sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],- coupL1*coupL2*(B1[p^2,m12,m22]+1/2 rMS)corrections[[6]]*corrections[[5]]]];
		Sigma1LoopL=sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]], -coupR1*coupR2*(B1[p^2,m12,m22]+1/2 rMS) corrections[[6]]*corrections[[5]]]];
	];


(* If[FreeQ[MajoranaPart,particle]===False, *)
	If[AntiField[particle/.diracSubBack1[ALL]/.diracSubBack2[ALL]]===(particle /.diracSubBack1[ALL]/.diracSubBack2[ALL]),
	SA`Doc`Return[{2 Sigma1LoopS,2 Sigma1LoopR,2 Sigma1LoopL}];,
	SA`Doc`Return[{Sigma1LoopS,Sigma1LoopR,Sigma1LoopL}];
	]; 
(* Return[{2 Sigma1LoopS,2 Sigma1LoopR,2 Sigma1LoopL}]; *)
];




(* ::Input::Initialization:: *)
AddLoopVector[particle_,corrections_]:=Block[{temp,m1,m2,m0,mS,mV,v,fac,m11,m12,m21,m22,ind1,ind2},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "AddLoopVector";
SA`Doc`Info = "Adds a self-energy correction to vector fields";
SA`Doc`Input={"particle"->"The considered, external particle","corrections"->"A list contatining the particles in the loop as well as the vertices"};
SA`Doc`GenerateEntry[];

(* If[corrections[[4]]===VVVV || corrections[[4]]===SSVV,Return[0];]; *)

If[getType[corrections[[1]]]===F,
temp=OrderMasses[corrections[[1]], corrections[[2]], F];

If[FreeQ[m11,corrections[[1]]] && FreeQ[m21,corrections[[2]]],
m11 = m11/. gI1->gI2;
m12 = m12 /. gI1->gI2;
m22 = m22 /. gI2->gI1;
m21 = m21 /. gI2->gI1;
];

m11=temp[[1]]; m12=temp[[1]]/. Mass->Mass2; m21=temp[[2]]; m22=temp[[2]]/. Mass->Mass2;	
coupL1= corrections[[3]][PL];
coupR1= corrections[[3]][PR];
pi1Loop  =  (coupL1 conj[coupL1]+coupR1 conj[coupR1])*H0[p^2,m12,m22]+4  Re[conj[coupL1] coupR1]*B0[p^2,m12,m22] m11 m21;
If[conj[particle]===particle,
pi1Loop =2 pi1Loop* corrections[[6]]*corrections[[5]];,
pi1Loop = pi1Loop* corrections[[6]]*corrections[[5]];
];
SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,

temp=OrderMasses[corrections[[1]], corrections[[2]], V];
m11=temp[[1]]; m12=temp[[1]]/. Mass->Mass2; m21=temp[[2]]; m22=temp[[2]]/. Mass->Mass2;	
If[FreeQ[m11,corrections[[1]]] && FreeQ[m21,corrections[[2]]],
m11 = m11/. gI1->gI2;
m12 = m12 /. gI1->gI2;
m22 = m22 /. gI2->gI1;
m21 = m21 /. gI2->gI1;
];

coup= corrections[[3]];
Switch[corrections[[4]],
	SSV, 
			(* pi1Loop  =  -4 B22[p^2,m12,m22] - (A0[m12]+A0[m22]);	*)
			pi1Loop  =  -4 B00[p^2,m12,m22];	
			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]]coup conj[coup];
			If[conj[particle]===particle,
			SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],2 pi1Loop]]];,
			SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];
			];,
	SVV,
			pi1Loop  =coup conj[coup]B0[p^2,m12,m22];	
			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
			If[conj[particle]===particle,pi1Loop = 2 pi1Loop]; 
			SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,
	VVV,
			pi1Loop  =10 B00[p^2,m12,m22]+(m12+m22+4*p^2)*B0[p^2,m12,m22]+A0[m12]+A0[m22]-2 (m12+m22-1/3 p^2)*rMS;
			pi1Loop =-pi1Loop* corrections[[6]]*corrections[[5]]coup conj[coup];
			If[conj[particle]===particle,pi1Loop = 2 pi1Loop];
			SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,
	GGV, 
			pi1Loop  =coup conj[coup]B00[p^2,m12,m22];	
			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
			If[conj[particle]===particle,pi1Loop = 2 pi1Loop];
			SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],sum[gI2,1,getGen[corrections[[2]]],pi1Loop]]];,

	VVVV,
			coup1= corrections[[3]][1];
			coup2= corrections[[3]][2];
			coup3= corrections[[3]][3];
			pi1Loop  =2 *coup1*m12*rMS-(4*coup1+coup2+coup3)*A0[m12];
			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
			SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],pi1Loop]];,
	SSVV,
			pi1Loop  =coup*A0[m12];
			pi1Loop =pi1Loop* corrections[[6]]*corrections[[5]];
			SA`Doc`Return[sum[gI1,1,getGen[corrections[[1]]],pi1Loop]];
	];
	];
];


(* ::Input::Initialization:: *)
getUnmixedMasses[Eigenstates_]:=Block[{i,j,neededP,treeMass,massMatrixTemp},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "getUnmixedMasses";
SA`Doc`Info = "Checks which particles don't mix, i.e. where corrections to the mass term not the mass matrix need to be calculated.";
SA`Doc`Input={"Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

partListFSV=Join[PART[F],Join[PART[S],PART[V]]];
For[i=1,i<=Length[partListFSV],
If[FreeQ[listAddedMasses,partListFSV[[i,1]]]==True,
Switch[getType[partListFSV[[i,1]]],
S,type=ScalarMass;,
F,If[MemberQ[MajoranaPart,partListFSV[[i,1]]]==True,type=FermionMassSymm;,type=FermionMassNonSymm;];,
V,type=VectorMass;
];

treeMass=TreeMass[partListFSV[[i,1]],Eigenstates, False];
neededP={};

For[j=1,j<=Length[parameters],
If[FreeQ[treeMass,parameters[[j,1]]]==False,
neededP=Join[neededP,{parameters[[j,1]]}];
];
j++;];


If[FreeQ[treeMass,gt1]==False && FreeQ[treeMass,gt2]==False,
massMatrixTemp= Table[treeMass,{gt1,1,getGen[partListFSV[[i,1]]]},{gt2,1,getGen[partListFSV[[i,1]]]}];,
massMatrixTemp=treeMass;
];

If[Simplify[treeMass /. subDependences] ===0 || FreeQ[massless,partListFSV[[i,1]]]==False,
If[getType[partListFSV[[i,1]]]===V,MasslessBosons=Join[MasslessBosons, {partListFSV[[i,1]]}];];
CurrentMass=0;
treeMass=0;
massMatrixTemp=0;,
CurrentMass="M"<>ToString[partListFSV[[i,1]]];
];

listNotMixedMasses= Join[listNotMixedMasses,{{partListFSV[[i,1]],CurrentMass,neededP,treeMass,massMatrixTemp,type}}];

];
i++;];

ListUnmixed[Eigenstates]=listNotMixedMasses;

SA`Doc`EndEntry[];
];

DeleteLightFieldContributions[list_,heavyfields_,listFields_]:=Block[{i,j,k,temp, heavyInv},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "DeleteLightFieldContributions";
SA`Doc`Info = "Removes loop contributions involving only light fields. [Note sure, if this is still needed somewhere! (FS, 22/05/19)]";
SA`Doc`Input={"list"->"List of all loop contributions","heavyFields"->"List of the fields which are heavy","listFields"->"List of all fields"};
SA`Doc`GenerateEntry[];

temp=Table[{},{Length[list]}];
For[i=1,i<=Length[list],
checkentry=False;
If[listFields===True,
checkentry=True;,
If[getType[listFields[[i]]]===S,
checkentry=True;
];
];
If[checkentry==True,
For[k=1,k<=Length[list[[i]]],
heavyInv=False;
For[j=1,j<=Length[heavyfields],
If[FreeQ[list[[i,k]],heavyfields[[j]]]==False,
heavyInv=True;
];
j++;];
If[heavyInv==True,
temp[[i]] = Join[temp[[i]],{list[[i,k]]}];
];
k++;];,
temp[[i]] = {};
];
i++;];

SA`Doc`Return[temp];

];

DeleteLightFieldVertices[list_, heavyfields_]:=Block[{i,temp, heavyInv}, 
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "DeleteLightFieldVertices";
SA`Doc`Info = "Removes the vertices involving only light fields. [Note sure, if this is still needed somewhere! (FS, 22/05/19)]";
SA`Doc`Input={"list"->"List of all loop contributions","heavyFields"->"List of the fields which are heavy"};
SA`Doc`GenerateEntry[];

temp = {};
For[i=1,i<=Length[list],
heavyInv=False;
For[j=1,j<=Length[heavyfields],
If[FreeQ[list[[i,1,1]],heavyfields[[j]]]==False,
heavyInv=True;
];
j++;];
For[j=1,j<=Length[neededVerticesForTadpoles],
If[FreeQ[list[[i,1,1]],neededVerticesForTadpoles[[j]]]==False,
heavyInv=True;
];
j++;];
If[heavyInv==True,
temp = Join[temp,{list[[i]]}];
];
i++;];
SA`Doc`Return[temp];
];


(* ::Input::Initialization:: *)
OneLoopDifferentExternal[Eigenstates_]:=Block[{i,j,k, particles,temp2},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "OneLoopDifferentExternal";
SA`Doc`Info = "Calculates the one-loop corrections mixing either two vector-bosons or a vector-boson and a scalar.";
SA`Doc`Input={"Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

CorrectionListVS ={};
CorrectionListVV ={};

particles=DeleteCases[Select[Transpose[PART[V]][[1]],(getGen[#]==1)&],VectorG];
For[i=1,i<=Length[particles],
For[j=i+1,j<=Length[particles],
temp=InsFields[{{C[particles[[i]],AntiField[FieldToInsert[1]],FieldToInsert[2]],C[AntiField[particles[[j]]],AntiField[FieldToInsert[2]],FieldToInsert[1]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],External[1]->particles[[i]], External[2]->particles[[j]],Index[1]->gO1,Index[2]->gO2,Index[3]->gI1,Index[4]->gI2}}];
If[temp=!={},
temp2={};
For[k=1,k<=Length[temp],
temp2=Join[temp2,{ReleaseHold[Hold[{AntiField[Internal[1]],Internal[2],C[External[1],AntiField[Internal[1]],Internal[2]],C[AntiField[External[2]],AntiField[Internal[2]],Internal[1]],VType[getType[Internal[1]],getType[Internal[2]],getType[External[1]]],CalculateColorFactor[getBlank[External[1]],Internal[1],Internal[2]],CalculateSymmetryFactor[Internal[1],Internal[2]]}]/. temp[[k,2]]] }];


If[FreeQ[AddedVertex,temp2[[-1,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddVertex[{temp2[[-1,5]],temp2[[-1,1]],temp2[[-1,2]],particles[[i]]}],temp2[[-1,5]]}}]; 
 AddedVertex=Join[AddedVertex,{temp2[[-1,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C}];
];
If[FreeQ[AddedVertex,temp2[[-1,4]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddVertex[{temp2[[-1,5]],AntiField[temp2[[-1,1]]],AntiField[temp2[[-1,2]]],AntiField[particles[[j]]]}],temp2[[-1,5]]}}]; 
 AddedVertex=Join[AddedVertex,{temp2[[-1,4]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C}];
];


k++];
temp=InsFields[{{C[particles[[i]],AntiField[particles[[j]]],AntiField[FieldToInsert[1]],FieldToInsert[1]]},{Internal[1]->FieldToInsert[1],External[1]->particles[[i]], External[2]->particles[[j]],Index[1]->gO1,Index[2]->gO2,Index[3]->gI1}}];
If[temp=!={},
For[k=1,k<=Length[temp],
temp2=Join[temp2,{ReleaseHold[Hold[{AntiField[Internal[1]],Internal[1],Cp[External[1],AntiField[External[2]],AntiField[Internal[1]],Internal[1]],Cp[External[1],AntiField[External[2]],AntiField[Internal[1]],Internal[1]],VType[getType[Internal[1]],getType[Internal[1]],getType[External[1]],getType[External[2]]],CalculateColorFactor[getBlank[External[1]],Internal[1],AntiField[Internal[1]]],CalculateSymmetryFactor[Internal[1],AntiField[Internal[1]]]}]/. temp[[k,2]]] }];

If[FreeQ[AddedVertex,temp2[[-1,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddVertex[{temp2[[-1,5]],temp2[[-1,1]],particles[[i]],AntiField[particles[[j]]]}],temp2[[-1,5]]}}]; 
 AddedVertex=Join[AddedVertex,{temp2[[-1,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C}];
];

k++];
];
CorrectionListVV=Join[CorrectionListVV,{{{particles[[i]],particles[[j]]},ReleaseHold[temp2]}}];
];
j++;];
i++;];

particles1=Select[Transpose[PART[V]][[1]],FreeQ[massless,#]&];
particles2=Transpose[PART[S]][[1]];
For[i=1,i<=Length[particles1],
For[j=1,j<=Length[particles2],
temp=InsFields[{{C[particles1[[i]],AntiField[FieldToInsert[1]],FieldToInsert[2]],C[AntiField[particles2[[j]]],AntiField[FieldToInsert[2]],FieldToInsert[1]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],External[1]->particles1[[i]], External[2]->particles2[[j]],Index[1]->gO1,Index[2]->gO2,Index[3]->gI1,Index[4]->gI2}}];
If[temp=!={},
temp2={};
For[k=1,k<=Length[temp],
temp2=Join[temp2,{ReleaseHold[Hold[{AntiField[Internal[1]],Internal[2],C[External[1],AntiField[Internal[1]],Internal[2]],C[AntiField[External[2]],AntiField[Internal[2]],Internal[1]],VType[getType[Internal[1]],getType[Internal[2]],getType[External[1]]],CalculateColorFactor[getBlank[External[1]],AntiField[Internal[1]],Internal[2]],CalculateSymmetryFactor[Internal[1],Internal[2]]}]/. temp[[k,2]]] }];
k++];

temp=InsFields[{{C[particles1[[i]],AntiField[particles2[[j]]],AntiField[FieldToInsert[1]],FieldToInsert[1]]},{Internal[1]->FieldToInsert[1],External[1]->particles1[[i]], External[2]->particles2[[j]],Index[1]->gO1,Index[2]->gO2,Index[3]->gI1}}];
If[temp=!={},
For[k=1,k<=Length[temp],
temp2=Join[temp2,{ReleaseHold[Hold[{AntiField[Internal[1]],Internal[1],Cp[External[1],AntiField[External[2]],AntiField[Internal[1]],Internal[1]],Cp[External[1],AntiField[External[2]],AntiField[Internal[1]],Internal[1]],VType[getType[Internal[1]],getType[Internal[1]],getType[External[1]],getType[External[2]]],CalculateColorFactor[getBlank[External[1]],Internal[1],AntiField[Internal[1]]],CalculateSymmetryFactor[Internal[1],AntiField[Internal[1]]]}]/. temp[[k,2]]] }];

If[FreeQ[AddedVertex,temp2[[-1,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C],
VerticesGaugeMassES = Join[VerticesGaugeMassES,{{AddVertex[{temp2[[-1,5]],temp2[[-1,1]],particles1[[i]],AntiField[particles2[[j]]]}],temp2[[-1,5]]}}]; 
 AddedVertex=Join[AddedVertex,{temp2[[-1,3]]  //. {x_[{a__}][b_]->x,x_[{a__}]->x}/. Cp ->C}];
];

k++];
];



CorrectionListVS=Join[CorrectionListVS,{{{particles1[[i]],particles2[[j]]},ReleaseHold[temp2]}}];
];
j++;];
i++;];


CorrectionListVectorScalar[Eigenstates]=CorrectionListVS;
CorrectionListVectorVector[Eigenstates]=CorrectionListVV;

SA`Doc`EndEntry[];
];

getUnmixedMassesDummy[Eigenstates_]:=Block[{i,j,k,basis},
SA`Doc`File = "Package/loopCorrections.nb";
SA`Doc`Name = "getUnmixedMassesDummy";
SA`Doc`Info = "Creates a dummy list containing only zeros for the loop corrections. That's used in the SPheno output for intermediate regimes where tree-level masses are sufficient. ";
SA`Doc`Input={"Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

listAddedMasses={};
listNotMixedMasses={};
CalculatedSelfEnergy={};
GaugeMassES={};
GaugeMassESorg={};
listAddedMasses={};
listNotMixedMasses={};
VerticesGaugeMassES={};
AddedVertex={};
massless=Massless[Eigenstates];

basis={};

For[i=1,i<=Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[i]]][MatterSector]]===List,
cbasis= DEFINITION[NameOfStates[[i]]][MatterSector];
For[j=1,j<=Length[cbasis],
If[Length[RE[cbasis[[j,2,1]]]]==0,
If[FreeQ[Particles[Eigenstates],RE[cbasis[[j,2,1]]]]==False && getTypeOld[cbasis[[j,2,1]]]=!=A,
basis=Join[basis,{cbasis[[j]]}];
];,
If[FreeQ[Particles[Eigenstates],cbasis[[j,2,1,1]]]==False,
basis=Join[basis,{cbasis[[j]]}];
];
];
j++;];
];
i++;];

 For[i=1,i<=Length[basis], 
If[Length[Dimensions[basis[[i,2]]]]==1,
OneLoopMassMatrix=Table[0,{Length[basis[[i,1]]]},{Length[basis[[i,1]]]}];
particle=basis[[i,2,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
unrotateMatrix=basis[[i,2,2]];,
OneLoopMassMatrix=Table[0,{Length[basis[[i,1,1]]]},{Length[basis[[i,1,1]]]}];
particle=basis[[i,2,1,1]] /. diracSubBack1[Eigenstates] /. diracSubBack2[Eigenstates];
unrotateMatrix={basis[[i,2,1,2]],basis[[i,2,2,2]]};
];

listAddedMasses=Join[listAddedMasses,{particle}];
i++;];
getUnmixedMasses[Eigenstates];

SA`Doc`EndEntry[];
];

