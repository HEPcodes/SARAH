(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)

(* ------------------------------------*)
(* Zeros                               *)
(* ------------------------------------*)

SetAttributes[conj,Constant];
SetAttributes[bar,Constant];
SetAttributes[Mom,Constant];
SetAttributes[sum,Constant];
SetAttributes[GetGen,Constant];
SetAttributes[GetGenStart,Constant];

conj[a_][b__]:=conj[a[b]]; 
NoEffect[x_]=x;

conj[DelPart]=DelPart;
DelPart[{a__}]=DelPart;
DelPart[a__]=DelPart;

SA`Casimir[x_,y_]:=SA`Casimir[(x /. diracSub[ALL])[[1]],y] /; FreeQ[diracFermions[ALL],x]==False
SA`Dynkin[x_,y_]:=SA`Dynkin[(x/. diracSub[ALL])[[1]],y] /;FreeQ[diracFermions[ALL],x]==False

 
pmue[0]=0;
Mom[0,_]=0;

nix[___]:=0;
zero[a_][b_]:=zero[a[b]];

Mom[zero[a_],l_]:=Mom[a,l];
Mass[zero[a_]]:=Mass[a];
Mass[x_]:=0 /; (FreeQ[massless,x]==False && Head[x]=!=Pattern);
Mass[x_conj]:=Mass[RE[x]];
Mass[x_bar]:=Mass[RE[x]];
Mass2[x_conj]:=Mass2[RE[x]];
Mass2[x_bar]:=Mass2[RE[x]];
Mass[x_[{b__}]]:=Mass[x] /;(getGen[x]===1);
Mass2[x_[{b__}]]:=Mass2[x] /;(getGen[x]===1);
Mass[a_]:=Mass[(a /. {zero[x_]->x})] /; FreeQ[a,zero]==False
vacHead[x_]:= Return[x->zero[x]];







(* ::Input::Initialization:: *)




MakeInteractionListRGE[SP_]:=Block[{i,j,k,PM,listNew= {},SymmetryFactor=1,tempList,pos,pos2,symmetric,tempsub,nfac,rtemp,temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "MakeInteractionListRGE";
SA`Doc`Info = "Generates a  list with interactions (including the contraction of indices) stemming from a superpotential. This list is used by the RGE calculation.";
SA`Doc`Input={"SP"->"A term in the Superpotential"};
SA`Doc`GenerateEntry[];

If[Length[SP[[1]]]==2,
GivenIndexStructure=MakeIndexStructure[SP[[2]] ];,
GivenIndexStructure=SP[[1,3]];
];

GivenIndexStructure=MakeIndexStructure[SP[[2]] ];
GivenIndexStructure=getInvariantMatrix[SP[[2]],GivenIndexStructure]; 

PM=Permutations[Table[i,{i,1,Length[SP[[2]]]}]];

parts=Table[SFields[[Position[Fields,SP[[2,i]]][[1,1]]]],{i,1,Length[SP[[2]]]}] /. conj[x_]->x (* TOCHECK!!*);

tempList = Table[{Table[parts[[PM[[j,i]]]],{i,1,Length[SP[[2]]]}],{SP[[1,1]],(GivenIndexStructure genTest[SP[[1,2]],SP[[2]],False] /.  Flatten[Table[subGCRE[i,Position[PM[[j]],i][[1,1]]],{i,1,Length[SP[[2]]]}]] )}},{j,1,Length[PM]}];
symmetric=Intersection[Select[SP[[2]],(Count[SP[[2]],#1]>1)&]];
If[Length[symmetric]>0,
pos = Table[Position[SP[[2]],symmetric[[i]]],{i,1,Length[symmetric]}];
SymmetryFactor = Times@@Table[Factorial[Length[pos[[i]]]],{i,1,Length[pos]}];
PMC = PM /. Flatten[Table[Table[pos[[j,i,1]]->iAdd[j],{i,1,Length[pos[[j]]]}],{j,1,Length[pos]}]];
PMF = Intersection[PMC];
For[j=1,j<=Length[PMF],
pos2=Position[PMC,PMF[[j]]];
 listNew = Join[listNew,{{tempList[[pos2[[1,1]],1]] /. conj[x_]->x,{tempList[[pos2[[1,1]],2,1]],Sum[tempList[[pos2[[k,1]],2,2]],{k,1,Length[pos2]}]}}}];  (* TOCHECK!! *)
j++;];,
listNew = tempList;
];

tempList[[1,2,1]]=tempList[[1,2,1]]*SymmetryFactor;

SA`Doc`Return[{(tempList[[1]]),listNew}];
];


getDimFundamentalAux[nr_]:=getDimFundamental[Gauge[[nr,2]]];

GenerateAllIndizes[Nr_]:=Block[{i,j,k,l,m,n,res,states,templ,resSusyno,temp,temp2},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "GenerateAllIndizes";
SA`Doc`Info = "Generates all indices for a particle defined in the model. There are two diferent kind of indices: \n
- not expanded: correspond to unbroken gauge groups\n
- expanded: correspond to broken gauge groups, i.e. the sum over the indices is performed";
SA`Doc`Input={"Nr"->"The position of the considered field in the array 'Fields'"};
SA`Doc`GenerateEntry[];

notExpanded={{generation,Fields[[Nr,2]]}}; expanded={};
notShort={{generation,Fields[[Nr,2]]}}; expShort={};

For[k=1,k<=AnzahlGauge,
temp={};
searchedDim=FieldDim[Nr,k];
If[Gauge[[k,2]]=!=U[1] && searchedDim=!=1,
If[Gauge[[k,5]]===False || Abs[searchedDim]==getDimFundamental[Gauge[[k,2]]],
If[searchedDim===getDimAdjoint[Gauge[[k,2]]],
temp= {{getAdjointIndex[Gauge[[k,3]]],Abs[searchedDim]}};
temp2= {{getAdjointIndex[Gauge[[k,3]]],Abs[searchedDim]}};,
temp= {{Gauge[[k,3]],If[Gauge[[k,5]]===False ,Abs[searchedDim],getDimFundamentalAux[k]]}};
temp2= {{Gauge[[k,3]],If[Gauge[[k,5]]===False ,Abs[searchedDim],getDimFundamentalAux[k]]}};
];,
If[Head[Gauge[[k,2]]=!=SU], Print["Only SU(N) groups can be definite explicitly as broken!"]; Abort[]];
If[searchedDim===getNumberStatesAdjoint[Gauge[[k,2]]],
temp={{Gauge[[k,3]],getDimFundamentalAux[k]},{IndexName[Gauge[[k,3]],2],getDimFundamentalAux[k]}};
temp2={{Gauge[[k,3]],getDimFundamentalAux[k]},{-Gauge[[k,3]],getDimFundamentalAux[k]}};, 
If[Head[Fields[[Nr,k+3]]]===List,
res=TestDim[Abs/@Fields[[Nr,k+3]],Gauge[[k,2,1]]];,
res=TestDim[Abs[Fields[[Nr,k+3]]],Gauge[[k,2,1]]];
];
temp=Join[Table[{IndexName[Gauge[[k,3]],j],getDimFundamentalAux[k]},{j,1,res[[2]]}],Table[{-IndexName[Gauge[[k,3]],j+res[[2]]],getDimFundamentalAux[k]},{j,1,res[[3]]}]];
temp2=Join[Table[{Gauge[[k,3]],getDimFundamentalAux[k]},{j,1,res[[2]]}],Table[{-Gauge[[k,3]],getDimFundamentalAux[k]},{j,1,res[[3]]}]];
];
];
If[Gauge[[k,5]]===False,
notShort = Join[notShort,temp];
notExpanded=Join[notExpanded,temp2];,
expShort = Join[expShort,temp];
expanded=Join[expanded,temp2];
];
];
If[Gauge[[k,2]]===U[1],
If[NumericQ[FieldDim[Nr,k]]==False, 
templ =Cases[{FieldDim[Nr,k]},x_Symbol,4];
For[i=1,i<=Length[templ],
If[FreeQ[parameters,templ[[i]]], 
parameters=Join[parameters,{{templ[[i]],{},{}}}];
UnfixedCharges = Join[UnfixedCharges,{templ[[i]]}];
realVar = Join[realVar,{templ[[i]]}];
];
i++;];
];
];
k++;];
MultiplicityList[[Nr]] = Join[MultiplicityList[[Nr]],Table[Product[If[i!=j && Gauge[[j,2]]=!=U[1] && FieldDim[Nr,j]=!=1 && Gauge[[j,5]]=!=True,Abs[FieldDim[Nr,j]],1],{j,1,AnzahlGauge}], {i,1,AnzahlGauge}]];

notShort=notShort /. -a_Integer b_ -> a b;
expShort=expShort /. -a_Integer b_ -> a b;
notExpanded=notExpanded /. -a_Integer b_ -> a b;
expanded=expanded /. -a_Integer b_ -> a b;


SA`Doc`Return[{notExpanded,expanded, notShort,expShort}];

];

IndexName[name_,s_]:=Block[{},
If[s===1,Return[name];,Return[ToExpression[ToString[name]<>appendIndex[[s]]]]];
];

(* ------------------------------------*)
(* Momentum                            *)
(* ------------------------------------*)


Deri[x_,l_]:=Block[{erg, erg2},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "Deri";
SA`Doc`Info = "Symbol for the partial derivative of a particle with respect to a given Lorentz index. Further simplifications are done via the dependent function 'Der'";
SA`Doc`Input={"x"->"The particle","l"->"The Lorentz index"};
SA`Doc`GenerateEntry[];

If[Head[x] == List,
erg = List@@x;
erg2 = Deri/@Table[{erg[[i]],l},{i,1,Length[erg]}];
SA`Doc`Return[List@@erg2/.a_[{b_,c_}]->a[b,c]];
];
SA`Doc`Return[Der[x,l]];
];



Der[x_,lor_]:=Block[{erg,erg2},
If[Head[x]== List,erg = List@@x;erg2= Table[Der[erg[[i]],lor],{i,1,Length[erg]}];Return[List@@erg2];];
If[Head[x]==Plus,erg=List@@x;erg2=Table[Der[erg[[i]],lor],{i,1,Length[erg]}];Return[Plus@@erg2];]; 
If[Head[x]==Times,erg=List@@x;erg2=Table[Der[erg[[i]],lor],{i,1,Length[erg]}];Return[Times@@erg2]];
If[Head[x]==Power,Return[x];];
If[Head[x]==sum,Return[x];];
If[Head[x]==Integer,Return[x];];
If[Head[x]==Sin,Return[x];];
If[Head[x]==Cos,Return[x];];
If[Head[x]==Delta,Return[x];];
If[Head[x]==repl,Return[x];];
If[Head[x]==Rational,Return[x];];
If[Head[x]==Complex,Return[x];];

SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "Der";
SA`Doc`Info = "Symbol for the partial derivative of a particle with respect to a given Lorentz index. Returns the corresponding term in momentum space.";
SA`Doc`Input={"x"->"The particle","lor"->"The Lorentz index"};
SA`Doc`GenerateEntry[];

If[Head[x] == conj,
If[FreeQ[Particles[Current],Head[x[[1]]]]==False || (FreeQ[Particles[Current],Head[Head[x[[1]]]]]==False && Head[x[[1]][[-1]]]===Integer),
If[getType[x[[1]]]=!=G,
SA`Doc`Return[x Mom[x /. A__[b_Integer]->A,lor]];,
SA`Doc`Return[x];
];,
SA`Doc`Return[x];
];
];

If[FreeQ[Particles[Current],Head[x]]==False|| (FreeQ[Particles[Current],Head[Head[x]]]==False && Head[x[[-1]]]===Integer),
If[getType[x]=!=G,
SA`Doc`Return[x Mom[x/. A__[b_Integer]->A,lor]];,
SA`Doc`Return[x];
];,
SA`Doc`Return[x];
];
] /; (CalcImp == True || Head[x]==List || Head[x]==Plus || Head[x]==Times || Head[x]==Power || Head[x]==repl) && (Head[x]=!=DeltaGT);

Mom[x_,l_]:=Mom[x /. zero[y_]->y,l] /;FreeQ[x,zero]== False; 


(* ::Input::Initialization:: *)
(* ------------------------------------------- *)
(* Generation Handling *)
(* ------------------------------------------- *)


replaceGen[x_,nr_] :=Block[{i,temp,subng},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "replaceGen";
SA`Doc`Info = "Replaces an intermediate generation index 'nX' (which is the result of the substitutions during a field rotation) by a proper generation index 'genY'.";
SA`Doc`Input={"x"->"The considered index","nr"->"The numbr which shall be used"};
SA`Doc`GenerateEntry[];

subng=Table[ToExpression["n"<>ToString[i]]->genf[i],{i,1,genMax}];
temp=x;
For[i=1,i<=genMax,
temp=( (D[temp,repl[genf[i]]] /. genf[i]->intf[nr,i]) + temp) /. repl[genf[i]]->0;
i++;];

(* temp=temp/.{ n1\[Rule]gen1,n2\[Rule]gen2,n3\[Rule]gen3,n4\[Rule]gen4,n5\[Rule]gen5,n6\[Rule]gen6} /. Mom[repl[a_]]\[Rule]1 /.repl[a_]\[Rule]1  /. Mom[1]\[Rule]1 ; *)
temp=temp/.subng /. Mom[repl[a_]]->1 /.repl[a_]->1  /. Mom[1]->1 ;

SA`Doc`Return[temp];
];

repl[1]:=1;

CheckOne:=Block[{part,i,j,k,liste1,liste2,listen},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CheckOne";
SA`Doc`Info = "Checks which particles or VEVs appear only in one generation. For those a definition is added to automatically remove the generation index, i.e. 
replace X[{genX,more indices}] by X[{more indices}].";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

listen={Particles[ALL],Particles[Current]};
ParticleListOneGeneration={};

For[i=1,i<=Length[NameOfStates],
listen=Join[listen,{ParticlesTemp[NameOfStates[[i]]]}];
i++;
];

For[j=1,j<=Length[listen],
For[i=1,i<=Length[listen[[j]]],
If[listen[[j,i,4]]===VEV && listen[[j,i,3]]>1, 
listen[[j,i,1]][{a__}]=listen[[j,i,1]][a];
];
If[listen[[j,i,3]]==1 &&  FreeQ[listen[[j,i,5]],generation]==False,
Clear[part];
If[Length[listen[[j,i,5]]]==1,
ReleaseHold[ReplaceAll[Hold[SetDelayed[part[{a_}],part]] , part->listen[[j,i,1]]]];
If[FreeQ[ParticleListOneGeneration,listen[[j,i,1]]]==True,
ParticleListOneGeneration=Join[ParticleListOneGeneration,{{listen[[j,i,1]],One}}];
];,
ReleaseHold[ReplaceAll[Hold[SetDelayed[part[liste1],part[liste2]]], {part->listen[[j,i,1]],liste1-> Table[ToExpression["a"<>ToString[k]<>"_"],{k,1,Length[listen[[j,i,5]]]}],liste2->Table[ToExpression["a"<>ToString[k]],{k,2,Length[listen[[j,i,5]]]}]}]];
If[FreeQ[ParticleListOneGeneration,listen[[j,i,1]]]==True,
ParticleListOneGeneration=Join[ParticleListOneGeneration,{{listen[[j,i,1]],Table[ToExpression["a"<>ToString[k]<>"_"],{k,1,Length[listen[[j,i,5]]]}]}}];
];
];
  
listen[[j,i,5]]=DeleteCases[listen[[j,i,5]], {generation,1},2];
];
i++;
];
j++;];

For[i=1,i<=Length[listen],
listen[[i]] = DeleteCases[listen[[i]],x_?deletedTotal];
i++;];


Particles[ALL]=listen[[1]];Particles[Current]=listen[[2]];



For[i=1,i<=Length[NameOfStates],
Particles[NameOfStates[[i]]]=listen[[i+2]];
i++;
];

OnesChecked=True;
SA`Doc`EndEntry[];
];

deletedTotal[x_]:=If[x[[2]]>x[[3]], Return[True];,Return[False];];


MakeSuperpotentialAsList[term_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "MakeSuperpotentialAsList";
SA`Doc`Info = "Brings the superpotential defined in the input file into a list-notation where fields, coupling and coefficient are separated.";
SA`Doc`Input={"term"->"The considered superpotential"};
SA`Doc`GenerateEntry[];

If[Head[term]===Plus,list=CreateSPlist/@ (List@@term);,list={CreateSPlist[term]}];
SA`Doc`Return[list];
];

CreateSPlist[term_]:=Block[{fields,coup,par,coeff,contraction},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CreateSPlist";
SA`Doc`Info = "Brings a single term from superpotential defined in the input file into a list-notation where fields, coupling and coefficient are separated.";
SA`Doc`Input={"term"->"The considered terms"};
SA`Doc`GenerateEntry[];

fields=Cases[term,x_Dot];
If[fields==={},
fields=Select[List@@term,MemberQ[Transpose[SuperFields][[1]],#]&];
coup=term /. fields[[1]]->1 /. fi[x__]->1;,
fields=List@@(fields[[1]]);
coup=term /. Dot->fi /. fi[x__]->1;
];
If[Head[coup]===Times,
par=Cases[(List@@coup),x_Symbol][[1]];,
par=coup;
];
coeff=coup/par;
If[FreeQ[coup,Delta] &&FreeQ[coup,epsTensor]  && FreeQ[coup,CG] ,
SA`Doc`Return[{{coeff,par },fields}];,
SA`Doc`Return[{{coeff/. {Delta[a__]->1,epsTensor[a__]->1, CG[a__][b__]->1},par ,coeff/(coeff/. {Delta[a__]->1,epsTensor[a__]->1, CG[a__][b__]->1})},fields}];
];
];




(* ::Input::Initialization:: *)
(* ------------------------------------------- *)
(* Particle Insertion *)
(* ------------------------------------------- *)

FieldQ[x_]:=If[MemberQ[Transpose[ListFields][[1]],x],Return[True];,Return[False];];
ParticleQ[x_]:=If[MemberQ[vacuum,x] || MemberQ[vacuum,Head[x]],Return[True];,Return[False]];
LorentzQ[x_]:= If[FreeQ[x,lt1] &&  FreeQ[x,lt2] && FreeQ[x,lt3] && FreeQ[x,lt4],Return[False];,Return[True];];

getInitializationIndices[particle_]:=Block[{pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getInitializationIndices";
SA`Doc`Info = "Gets the indices of particles used during initialisation.";
SA`Doc`Input={"particle"->"The considered particle"};
SA`Doc`GenerateEntry[];

pos=Position[SA`ListAllFieldsInit,getBlankSF[particle]][[1,1]];
SA`Doc`Return[SA`ListAllFieldsInit[[pos,3]]];
];

part[particle_,nr_]:=Block[{res,sub,i,temp,ind,sumStates,nonSUN,pos,pos2},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "part";
SA`Doc`Info = "Takes the full form of a given particle where the indices get given number. Also the sums over gauge and generations indices are added. For instance (uR[{generation,color}],1) becomes sum[gem1,1,3] sum[col1,1,3] uR[{gen1,col1}]. This is the form which can be used in the Lagrangian. ";
SA`Doc`Input={"particle"->"The considered particle","nr"->"The used number"};
SA`Doc`GenerateEntry[];

(* ind=Cases[RE[particle],x_?ListQ,2][[1]]; *)
(* ind=getIndizesOldWI[RE[particle]]; *)
ind=getInitializationIndices[RE[particle]];
temp = particle /. subGC[nr];
If[ind=!={},
sumStates = Product[If[ind[[i,1]]=!= generation && ind[[i,1]] =!=lorentz,sum[ind[[i,1]] /. subGC[nr],1,ind[[i,2]]],1],{i,1,Length[ind]}];,
sumStates=1;
];
(*
If[getType[particle,True]===F,
Return[temp[nr]*sumStates*sum[genf[nr],GetGenStart[particle[1] /. subGC[nr]],GetGen[particle[1] /. subGC[nr]]]];, 
Return[temp*sumStates*sum[genf[nr],GetGenStart[particle /. subGC[nr]],GetGen[particle /. subGC[nr]]]]; 
]; *)
If[getType[particle,True]===F,
SA`Doc`Return[temp[nr]*sumStates*sum[genf[nr],GetGenStart[getBlank[particle[1] /. subGC[nr]]],GetGen[getBlank[particle[1] /. subGC[nr]]]]];, 
SA`Doc`Return[temp*sumStates*sum[genf[nr],GetGenStart[getBlank[particle /. subGC[nr]]],GetGen[getBlank[particle /. subGC[nr]]]]]; 
];
];

partBlank[particle_,nr_]:=Block[{res,sub,i,temp,ind,sumStates},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "partBlank";
"Takes the short form of a given particle, adds the indices and sets the indices to a  given number. Also the sums over gauge and generations indices are added. For instance (uR,1) becomes sum[gem1,1,3] sum[col1,1,3] uR[{gen1,col1}]. This is the form which can be used in the Lagrangian. ";
SA`Doc`Input={"particle"->"The considered particle","nr"->"The used number"};
SA`Doc`GenerateEntry[];

temp=RE[particle];
sumStates=1;
ind=getIndizes[temp];

temp = getFull[particle] /. subGC[nr];

If[getType[particle]===F,
If[Head[RE[particle]]===List,
temp[[1]] = temp[[1]][nr];
temp[[2]] = temp[[2]][nr];,
temp = temp[nr];
];
];

For[i=1,i<=Length[ind],If[ind[[i]]=!=generation&&ind[[i]]=!=lorentz,(*sumStates=sumStates*sum[ToExpression["a"<>StringTake[ToString[ind[[i]]],{4,6}]<>ToString[nr]],1,getNumberStates[ind[[i]]]];*)(*H*)(*I am changing this since getNumberStates[color] did not work if pati\[Rule]color breaking is present.I suspect that it does not work correctly even without such breaking (e.g.gG[{col1}]sum[col1,1,3]),to be discussed!!!*)(*At this stage it is not very general,however,at least it works for the ToyPS model*)If[AuxGaugesPresent===True&&MemberQ[UnbrokenSubgroups,ind[[i]],3]&&getType[particle]===G&&MemberQ[RepGaugeBosons,ToExpression["V"<>StringDrop[ToString[particle],1]],3],pos=Position[RepGaugeBosons,ToExpression["V"<>StringDrop[ToString[particle],1]]][[1]];
nStates=RepGaugeBosons[[pos[[1]],pos[[2]],2]];,nStates=getNumberStates[ind[[i]]];
];
sumStates=sumStates*sum[ToExpression[StringTake[ToString[ind[[i]]],{1,3}]<>ToString[nr]],1,nStates];];
i++;];


If[Head[RE[particle]]===List,
res = {temp[[1]]*sumStates*sum[genf[nr],GetGenStart[RE[particle][[1]]],GetGen[RE[particle][[1]]]],temp[[2]]*sumStates*sum[genf[nr],GetGenStart[RE[particle][[2]]],GetGen[RE[particle][[2]]]]};,
res = temp*sumStates*sum[genf[nr],GetGenStart[RE[particle]],GetGen[RE[particle]]]; 
];

SA`Doc`Return[res];
];


addParticle[name_, ind_, gens_,type_,fla___]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "addParticle";
SA`Doc`Info = "Adds a particle to the list of all existing particles 'Particle[X]'";
SA`Doc`Input={"name"->"The name of the particle","ind"->"the indices of the particle","gens"->"The number of generations of the particle","type"->"The generic type of the particle","fla"->"The number of flavours of the particle"};
SA`Doc`GenerateEntry[];

If[Head[gens]===List,
Particles[Current] = Join[Particles[Current],{{name,gens[[1]], gens[[2]],type,ind,fla}}];
Particles[ALL] = Join[Particles[ALL],{{name,gens[[1]], gens[[2]],type,ind,fla}}];,
Particles[Current] = Join[Particles[Current],{{name,1, gens,type,ind,fla}}];
Particles[ALL] = Join[Particles[ALL],{{name,1, gens,type,ind,fla}}];
];


If[type=!=VEV,
vacuum=Join[vacuum,{name}];
Switch[type,
F, vacuumF=Join[vacuumF,{name->zero[name]}];,
S, vacuumS=Join[vacuumS,{name->zero[name]}];,
V, vacuumV=Join[vacuumV,{name->zero[name]}];,
G, vacuumG=Join[vacuumG,{name->zero[name]}];,
A, vacuumA=Join[vacuumA,{name->zero[name]}];
];
];

SA`Doc`EndEntry[];
];

delParticle[part_]:=Block[{pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "delParticle";
SA`Doc`Info = "Removes a particle from 'Particles[Current]'.";
SA`Doc`Input={"part"->"The considered particle"};
SA`Doc`GenerateEntry[];

If[FreeQ[Particles[Current],part]==False,
pos =Position[Particles[Current],RE[part]][[1,1]];
Particles[Current]=Delete[Particles[Current],pos];
];
SA`Doc`EndEntry[];
];

makeDelta[listP_, skip_]:=Block[{i,j,k,res, listIndices,listIndicesNoSUN},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "makeDelta";
SA`Doc`Info = "Generates a product of Kronecker deltas between the gauge indices of a set of given fields.";
SA`Doc`Input={"listP"->"The list of particles","skip"->"The indices which shouldn't be included"};
SA`Doc`GenerateEntry[];

listIndices =MapIndexed[If[getGen[listP[[#2[[1]],1]]]==1,DeleteCases[#1,generation,4],#1]&, DeleteCases[Table[getIndizes[listP[[i,1]]],{i,1,Length[listP]}],x_/; MemberQ[skip,x],4]];
SA`Doc`Return[Product[Times@@Map[Delta[#1 /. subGC[listP[[i,2]]],#1/. subGC[listP[[j,2]]]]&,Intersection[listIndices[[i]],listIndices[[j]]] ],{i,1,Length[listP]-1},{j,i+1,Length[listP]}]];
];


makeDelta[particleNr_,nr1_,nr2_, skip_]:=Block[{i,j,k,res, deltas, list,SKIP,gnr},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "makeDelta";
SA`Doc`Info = "Generates a product of Kronecker deltas for the gauge indices of particle, e.g. something like Delta[gen1,gen2] Delta[col1,col2]'. The result is used in the Lagrangian. ";
SA`Doc`Input={"particleNr"->"The position of the particle in 'Fields'", "nr1"->"The first number used for the indices","nr2"->"The second number used for the indices","skip"->"The indices which shouldn't be included"};
SA`Doc`GenerateEntry[];

If[particleNr > Length[Fields],SA`Doc`Return[0];];
SKIP=skip;
If[Extract[Fields,particleNr][[2]]==1,
SKIP = Join[SKIP,{generations}];
];
deltas = 1;

listNames = Join[ListFields[[particleNr,2,1]],ListFields[[particleNr,3,1]]];
listTypes = Flatten[DeleteCases[Join[ListFields[[particleNr,2,2]],ListFields[[particleNr,3,2]]],x_?NumericQ,3]];

For[i=1,i<=Length[listNames],
If[FreeQ[SKIP,listTypes[[i]]]==True,
(* If[FreeQ[NonSUNindices,listTypes[[i]]], *)
deltas = deltas* Delta[listNames[[i]] /. subGC[nr1],listNames[[i]] /. subGC[nr2]]; (*,
gnr=Position[Gauge,listTypes[[i]]][[1,1]];
deltas = deltas*RM[Gauge[[gnr,2]],FieldDim[particleNr,gnr],DynkinLabels[Gauge[[gnr,2]],Fields[[particleNr,3]]]][listNames[[i]] /. subGC[nr1],listNames[[i]] /. subGC[nr2]];
]; *)
];
i++;];
SA`Doc`Return[deltas];
];


makeDeltaRGE[particleNr_,nr1_,nr2_, skip_]:=Block[{i,j,k,res, deltas, list,SKIP,gnr},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "makeDeltaRGE"; 
SA`Doc`Info = "Generates a product of Kronecker deltas for the gauge indices of particle, e.g. something like Delta[gen1,gen2] Delta[col1,col2]'. The result is used for the RGEs.";
SA`Doc`Input={"particleNr"->"The position of the particle in 'Fields'", "nr1"->"The first number used for the indices","nr2"->"The second number used for the indices","skip"->"The indices which shouldn't be included"};
SA`Doc`GenerateEntry[];

If[particleNr > Length[Fields],SA`Doc`Return[0];];
SKIP=skip;
If[Extract[Fields,particleNr][[2]]==1,
SKIP = Join[SKIP,{generations}];
];
deltas = 1;

listNames = Join[ListFields[[particleNr,2,1]],ListFields[[particleNr,3,1]]];
listTypes = DeleteCases[Join[ListFields[[particleNr,2,2]],ListFields[[particleNr,3,2]]],x_?NumericQ,3];

For[i=1,i<=Length[listNames],
If[FreeQ[SKIP,listTypes[[i]]]==True,
deltas = deltas* Delta[listNames[[i]] /. subGC[nr1] /. subIndFinalX[nr1,nr1,"i"],listNames[[i]] /. subGC[nr2]/. subIndFinalX[nr2,nr2,"i"]]; 
];
i++;];
SA`Doc`Return[deltas];
];

MakeIndexStructureRGE[partListIN_]:=Block[{i,j,k,l,pos,pos2,temp,dyn,ind,sign={},dims, CGc,inds, i1,i2,i3,i4,partList={}},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "MakeIndexStructureRGE";
SA`Doc`Info = "Generates the index structure of a given superpotential term in a format suitable for the RGE calculation. This version is used for SUSY models. ";
SA`Doc`Input={"partListIN"->"The list of considered particles"};
SA`Doc`GenerateEntry[];

IndexTypes={};
For[i=1,i<=Length[partListIN],
If[FreeQ[ListFields,RE[partListIN[[i]]]]==False,
partList=Join[partList,{partListIN[[i]]}];,
If[FreeQ[SFields,RE[partListIN[[i]]]]==False,
pos=Position[SFields,RE[partListIN[[i]]]][[1,1]];,
If[FreeQ[FFields,RE[partListIN[[i]]]]==False,
pos=Position[FFields,RE[partListIN[[i]]]][[1,1]];,
If[FreeQ[SFields,RE[partListIN[[i]]]]==False,
pos=Position[SFields,RE[partListIN[[i]]]][[1,1]];
];
];
];
If[Head[partListIN[[i]]]===conj,
partList=Join[partList,{conj[ListFields[[pos,1]]]}];,
partList=Join[partList,{ListFields[[pos,1]]}];
];
];
i++;];
For[i=1,i<=Length[partList],
If[FreeQ[ListFields,RE[partList[[i]]]]==False,
pos=Position[ListFields,RE[partList[[i]]]][[1,1]];
IndexTypes = Join[IndexTypes,Select[Gauge,(FreeQ[ListFields[[pos]],#[[3]]]==False &&#[[2]]=!=U[1])&]];
];
If[Head[partList[[i]]]===conj,sign=Join[sign,{-1}];,sign=Join[sign,{1}];];
i++;];
IndexTypes=Intersection[Table[IndexTypes[[i,3]],{i,1,Length[IndexTypes]}]];
structure=1;
Off[Part::"pspec"];
Off[Part::"pkspec1"];
For[i=1,i<=Length[IndexTypes],
pos=Position[Gauge,IndexTypes[[i]]][[1,1]];
CGc=GenerateInvariantsTensor[Gauge[[pos,2]],Gauge[[pos,3]],Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];
structure=structure*CGc;

If[FreeQ[SA`KnonwCG,Head[CGc]] && Length[partList]<5 && FreeQ[CGc,CG]==False &&Head[CGc]=!=Times,
If[Length[Head[CGc][[2]]]===4,
If[(FreeQ[SA`KnonwCG,Head[CGc]/. CG[a_,{i1_List,i2_List,i3_List,i4_List}]->CG[a,{i1,i2}]]==False ) &&(FreeQ[SA`KnonwCG,Head[CGc]/. CG[a_,{i1_List,i2_List,i3_List,i4_List}]->CG[a,{i3,i4}]]==False ) ,
structure=structure /.  CG[a_,{i1_List,i2_List,i3_List,i4_List}][j1_,j2_,j3_,j4_]:>CG[a,{i1,i2}][j1,j2]CG[a,{i3,i4}][j3,j4],
structure=structure /. CG[a_,b_]:>InvariantMatrixSusyno[Gauge[[pos,2]],getDynkinLabels[#,Gauge[[pos,2,1]]]&/@Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];
];,
structure=structure /. CG[a_,b_]:>InvariantMatrixSusyno[Gauge[[pos,2]],getDynkinLabels[#,Gauge[[pos,2,1]]]&/@Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];
];
];
i++;];
On[Part::"pspec"];
On[Part::"pkspec1"];
SA`Doc`Return[structure];
];

MakeIndexStructureRGEnonSUSY[partListIN_,coup_]:=Block[{i,j,k,l,pos,pos2,temp,dyn,ind,sign={},dims, CGc,inds, i1,i2,i3,i4,partList={},realScalarInv={}},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "MakeIndexStructureRGEnonSUSY";
SA`Doc`Info = "Generates the index structure of a given superpotential term in a format suitable for the RGE calculation. This version is used for non-SUSY models. ";
SA`Doc`Input={"partListIN"->"The list of considered particles"};
SA`Doc`GenerateEntry[];

IndexTypes={};
For[i=1,i<=Length[partListIN],
If[FreeQ[ListFields,RE[partListIN[[i]]]]==False,
partList=Join[partList,{partListIN[[i]]}];,
If[FreeQ[SFields,RE[partListIN[[i]]]]==False,
pos=Position[SFields,RE[partListIN[[i]]]][[1,1]];,
If[FreeQ[FFields,RE[partListIN[[i]]]]==False,
pos=Position[FFields,RE[partListIN[[i]]]][[1,1]];,
If[FreeQ[SFields,RE[partListIN[[i]]]]==False,
pos=Position[SFields,RE[partListIN[[i]]]][[1,1]];
];
];
];
If[Head[partListIN[[i]]]===conj,
partList=Join[partList,{conj[ListFields[[pos,1]]]}];,
partList=Join[partList,{ListFields[[pos,1]]}];
];
];
i++;];
For[i=1,i<=Length[partList],
If[FreeQ[ListFields,RE[partList[[i]]]]==False,
pos=Position[ListFields,RE[partList[[i]]]][[1,1]];
IndexTypes = Join[IndexTypes,Select[Gauge,(FreeQ[ListFields[[pos]],#[[3]]]==False &&#[[2]]=!=U[1])&]];
If[FreeQ[RealScalars,partList[[i]]]==False,
realScalarInv=Join[realScalarInv,Select[Gauge,(FreeQ[ListFields[[pos]],#[[3]]]==False &&#[[2]]=!=U[1])&]];
];
];
If[Head[partList[[i]]]===conj,sign=Join[sign,{-1}];,sign=Join[sign,{1}];];
i++;];
IndexTypes=Intersection[Table[IndexTypes[[i,3]],{i,1,Length[IndexTypes]}]];
structure=1;
inds=Table[{},{Length[partList]}];
For[i=1,i<=Length[IndexTypes],
pos=Position[Gauge,IndexTypes[[i]]][[1,1]];
If[Gauge[[pos,5]]===False,
CGc=GenerateInvariantsTensor[Gauge[[pos,2]],Gauge[[pos,3]],Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];
structure=structure*CGc;
If[FreeQ[SA`KnonwCG,Head[CGc]]  && Length[partList]<5 && FreeQ[CGc,CG]==False &&Head[CGc]=!=Times,
If[Length[Head[CGc][[2]]]===4,
If[(FreeQ[SA`KnonwCG,Head[CGc]/. CG[a_,{i1_List,i2_List,i3_List,i4_List}]->CG[a,{i1,i2}]]==False ) &&(FreeQ[SA`KnonwCG,Head[CGc]/. CG[a_,{i1_List,i2_List,i3_List,i4_List}]->CG[a,{i3,i4}]]==False ) ,
structure=structure /.  CG[a_,{i1_List,i2_List,i3_List,i4_List}][j1_,j2_,j3_,j4_]:>CG[a,{i1,i2}][j1,j2]CG[a,{i3,i4}][j3,j4];,
structure=structure /. CG[a_,b_]:>InvariantMatrixSusyno[Gauge[[pos,2]],getDynkinLabels[#,Gauge[[pos,2,1]]]&/@Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];
];,
structure=structure /. CG[a_,b_]:>InvariantMatrixSusyno[Gauge[[pos,2]],getDynkinLabels[#,Gauge[[pos,2,1]]]&/@Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];
];
];,

dims=Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}];
For[j=1,j<=Length[dims],
If[Abs[dims[[j]]]=!=1,
inds[[j]]=Join[inds[[j]],{Gauge[[pos,3]]/. subGC[j]}];
];
j++;];
];
i++;];
For[j=1,j<=Length[dims],
If[Length[inds[[j]]]>1,
inds[[j]]={inds[[j,1]]+(inds[[j,1]]-1)*(inds[[j,2]])};
];
j++;];
If[Head[inds]===List,inds=Flatten[inds];];
If[inds=!={}, structure=structure*(CGCBroken[partListIN,coup ]@@inds);];
SA`Doc`Return[structure];
];

MakeIndexStructure[partList_]:=Block[{i,j,k,l,pos,pos2,temp,dyn,ind,sign={}},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "MakeIndexStructure";
SA`Doc`Info = "Generates the index structure for a given a set of particles. The result is used in the Lagrangian.";
SA`Doc`Input={"partList"->"The list of considered particles"};
SA`Doc`GenerateEntry[];

IndexTypes={};
For[i=1,i<=Length[partList],
pos=Position[ListFields,RE[partList[[i]]]][[1,1]];
IndexTypes = Join[IndexTypes,Select[Gauge,(FreeQ[ListFields[[pos]],#[[3]]]==False &&#[[2]]=!=U[1])&]];
If[Head[partList[[i]]]===conj,sign=Join[sign,{-1}];,sign=Join[sign,{1}];];
i++;];
IndexTypes=Intersection[Table[IndexTypes[[i,3]],{i,1,Length[IndexTypes]}]];
structure=1;
For[i=1,i<=Length[IndexTypes],
pos=Position[Gauge,IndexTypes[[i]]][[1,1]];
If[Gauge[[pos,5]]===True && Head[Gauge[[pos,2]]]===SU,
structure=structure*ContractIndicesSUN[Gauge[[pos,2]],Gauge[[pos,3]],Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];,
structure=structure*GenerateInvariantsTensor[Gauge[[pos,2]],Gauge[[pos,3]],Table[sign[[j]]*Fields[[Position[ListFields,RE[partList[[j]]]][[1,1]],3+pos]],{j,1,Length[partList]}]];
];
i++;];
SA`Doc`Return[structure];
];

ContractIndicesSUN[group_,name_,dims_]:=Block[{i,j,k,l,pos,pos2,temp,dyn,ind},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "ContractIndicesSUN";
SA`Doc`Info = "Contracts the indices of particles charged under a SU(N) group. Note, the contraction might not be unique! Only the first valid contraction is returned. Works wiht up to four involved particles. (The function is quite old and clumpsy, but there might no need to spend to write a modern version) ";
SA`Doc`Input={"group"->"The dimension of the considered gauge group","name"->"The name of the gauge group","dims"->"The involved dimensions of the fields"};
SA`Doc`GenerateEntry[];

CurrentNumberStates=Table[{getDimFundamental[group]},{i,1,Length[IndexTypes]}];
NeededStructures={};

For[i=1,i<=Length[dims],
Switch[dims[[i]],
1 | -1,
	NeededStructures = Join[NeededStructures,{{}}];,
getDimFundamental[group],
	NeededStructures = Join[NeededStructures,{{Cov[name/.subGC[i]]}}];,
-getDimFundamental[group],
	NeededStructures = Join[NeededStructures,{{Con[name/.subGC[i]]}}];,
getNumberStatesAdjoint[group],
	NeededStructures = Join[NeededStructures,{{Cov[IndexName[name,1]/.subGC[i]],Con[IndexName[name,2]/.subGC[i]]}}];,
-getNumberStatesAdjoint[group],
	NeededStructures = Join[NeededStructures,{{Con[IndexName[name,1]/.subGC[i]],Cov[IndexName[name,2]/.subGC[i]]}}];,
_,
	res=TestDim[Abs[dims[[i]]],group[[1]]];

	If[dims[[i]]>0,
NeededStructures = Join[NeededStructures,{Join[Table[Cov[IndexName[name,j1]/.subGC[i]],{j1,1,res[[2]]}],Table[Con[IndexName[name,j1+res[[2]]]/.subGC[i]],{j1,1,res[[3]]}]]}];,
	NeededStructures = Join[NeededStructures,{Join[Table[Con[IndexName[name,j1]/.subGC[i]],{j1,1,res[[2]]}],Table[Cov[IndexName[name,j1+res[[2]]]/.subGC[i]],{j1,1,res[[3]]}]]}];
	];
];
i++;];


structure=1;
NeededStructures={NeededStructures};

For[i=1,i<=Length[NeededStructures],
If[Length[NeededStructures[[i]]]>1,
Switch[Length[NeededStructures[[i]]],
2,
(*
res=ContractIndizes[NeededStructures[[i,1]],NeededStructures[[i,2]]];
NeededStructures[[i,1]]=res[[1]];
NeededStructures[[i,2]]=res[[2]];
structure=structure*res[[3]];*)
list1a=Cases[Flatten[NeededStructures[[i,1]]],x_Cov];
list1b=Cases[Flatten[NeededStructures[[i,1]]],x_Con];
list2a=Cases[Flatten[NeededStructures[[i,2]]],x_Cov];
list2b=Cases[Flatten[NeededStructures[[i,2]]],x_Con];
res12=ContractIndizes[list1b,list2a];
structure=structure*res12[[3]];
list1b=res12[[1]];
list2a=res12[[2]];
res12=ContractIndizes[list1a,list2b];
list1a=res12[[1]];
list2b=res12[[2]];
structure=structure*res12[[3]];

If[group===SU[2],
res12=ContractIndizesEps2[list1a,list2a];
list1a=res12[[1]];
list2a=res12[[2]];
structure=structure*res12[[3]];
res12=ContractIndizesEps2[list1b,list2b];
list1b=res12[[1]];
list2b=res12[[2]];
structure=structure*res12[[3]];
];
NeededStructures[[i,1]]=Join[{list1a,list1b}];
NeededStructures[[i,2]]=Join[{list2a,list2b}];,
3,
list1a=Cases[Flatten[NeededStructures[[i,1]]],x_Cov];
list1b=Cases[Flatten[NeededStructures[[i,1]]],x_Con];
list2a=Cases[Flatten[NeededStructures[[i,2]]],x_Cov];
list2b=Cases[Flatten[NeededStructures[[i,2]]],x_Con];
list3a=Cases[Flatten[NeededStructures[[i,3]]],x_Cov];
list3b=Cases[Flatten[NeededStructures[[i,3]]],x_Con];
res13=ContractIndizes[list1a,list3b];
res12=ContractIndizes[list1b,list2a];
res23=ContractIndizes[list2b,list3a];
NeededStructures[[i,1]]=Join[res13[[1]],res12[[1]]];
NeededStructures[[i,2]]=Join[res23[[1]],res12[[2]]];
NeededStructures[[i,3]]=Join[res23[[2]],res13[[2]]];
structure=structure*res12[[3]] res13[[3]] res23[[3]];
res=ContractIndizes[NeededStructures[[i,1]],NeededStructures[[i,2]]];
NeededStructures[[i,1]]=res[[1]];
NeededStructures[[i,2]]=res[[2]];
structure=structure*res[[3]];
res=ContractIndizes[NeededStructures[[i,1]],NeededStructures[[i,3]]];
NeededStructures[[i,1]]=res[[1]];
NeededStructures[[i,3]]=res[[2]];
structure=structure*res[[3]];
res=ContractIndizes[NeededStructures[[i,2]],NeededStructures[[i,3]]];
NeededStructures[[i,2]]=res[[1]];
NeededStructures[[i,3]]=res[[2]];
structure=structure*res[[3]];,
4,
list1a=Cases[Flatten[NeededStructures[[i,1]]],x_Cov];
list1b=Cases[Flatten[NeededStructures[[i,1]]],x_Con];
list2a=Cases[Flatten[NeededStructures[[i,2]]],x_Cov];
list2b=Cases[Flatten[NeededStructures[[i,2]]],x_Con];
list3a=Cases[Flatten[NeededStructures[[i,3]]],x_Cov];
list3b=Cases[Flatten[NeededStructures[[i,3]]],x_Con];
list4a=Cases[Flatten[NeededStructures[[i,4]]],x_Cov];
list4b=Cases[Flatten[NeededStructures[[i,4]]],x_Con];

(* contract 1-2 & 3-4 *)

res12=ContractIndizes[list1b,list2a];
res34=ContractIndizes[list3b,list4a];
list1b=res12[[1]];
list2a=res12[[2]];
list3b=res34[[1]];
list4a=res34[[2]];
structure=structure res12[[3]]  res34[[3]];

res12=ContractIndizes[list1a,list2b];
res34=ContractIndizes[list3a,list4b];
list1a=res12[[1]];
list2b=res12[[2]];
list3a=res34[[1]];
list4b=res34[[2]];
structure=structure res12[[3]]  res34[[3]];

If[group===SU[2],
res12=ContractIndizesEps2[list1b,list2b];
res34=ContractIndizesEps2[list3b,list4b];
list1b=res12[[1]];
list2b=res12[[2]];
list3b=res34[[1]];
list4b=res34[[2]];
structure=structure res12[[3]]  res34[[3]];

res12=ContractIndizesEps2[list1a,list2a];
res34=ContractIndizesEps2[list3a,list4a];
list1a=res12[[1]];
list2a=res12[[2]];
list3a=res34[[1]];
list4a=res34[[2]];
structure=structure res12[[3]]  res34[[3]];

];

(* contract 2-3 & 4-1 *)

 res23=ContractIndizes[list2b,list3a]; 
 res41=ContractIndizes[list4b,list1a]; 
 list2b=res23[[1]];
list3a=res23[[2]]; 
 list4b=res41[[1]];
list1a=res41[[2]]; 
structure=structure res23[[3]]  res41[[3]];

 res23=ContractIndizes[list2a,list3b]; 
 res41=ContractIndizes[list4a,list1b]; 
 list2a=res23[[1]];
list3b=res23[[2]]; 
 list4a=res41[[1]];
list1b=res41[[2]]; 
structure=structure res23[[3]]  res41[[3]];

If[group===SU[2],
 res23=ContractIndizesEps2[list2b,list3b]; 
 res41=ContractIndizesEps2[list4b,list1b]; 
 list2b=res23[[1]];
list3b=res23[[2]]; 
 list4b=res41[[1]];
list1b=res41[[2]]; 
structure=structure res23[[3]]  res41[[3]];

 res23=ContractIndizesEps2[list2a,list3a]; 
 res41=ContractIndizesEps2[list4a,list1a]; 
 list2a=res23[[1]];
list3a=res23[[2]]; 
 list4a=res41[[1]];
list1a=res41[[2]]; 
structure=structure res23[[3]]  res41[[3]];
];



(* contract 1-3 & 2-4 *)

res13=ContractIndizes[list1b,list3a];
res24=ContractIndizes[list2b,list4a];
list1b=res13[[1]];
list3a=res13[[2]];
list2b=res24[[1]];
list4a=res24[[2]];
structure=structure res13[[3]]  res24[[3]];

res13=ContractIndizes[list1a,list3b];
res24=ContractIndizes[list2a,list4b];
list1a=res13[[1]];
list3b=res13[[2]];
list2a=res24[[1]];
list4b=res24[[2]];
structure=structure res13[[3]]  res24[[3]];

If[group===SU[2],
res13=ContractIndizesEps2[list1b,list3b];
res24=ContractIndizesEps2[list2b,list4b];
list1b=res13[[1]];
list3b=res13[[2]];
list2b=res24[[1]];
list4b=res24[[2]];
structure=structure res13[[3]]  res24[[3]];

res13=ContractIndizesEps2[list1a,list3a];
res24=ContractIndizesEps2[list2a,list4a];
list1a=res13[[1]];
list3a=res13[[2]];
list2a=res24[[1]];
list4a=res24[[2]];
structure=structure res13[[3]]  res24[[3]];

];


NeededStructures[[i,1]]=Join[list1a,list1b];
NeededStructures[[i,2]]=Join[list2a,list2b];
NeededStructures[[i,3]]=Join[list3a,list3b];
NeededStructures[[i,4]]=Join[list4a,list4b];

res=ContractIndizes[NeededStructures[[i,1]],NeededStructures[[i,2]]];
NeededStructures[[i,1]]=res[[1]];
NeededStructures[[i,2]]=res[[2]];
structure=structure*res[[3]];
res=ContractIndizes[NeededStructures[[i,1]],NeededStructures[[i,3]]];
NeededStructures[[i,1]]=res[[1]];
NeededStructures[[i,3]]=res[[2]];
structure=structure*res[[3]];

res=ContractIndizes[NeededStructures[[i,1]],NeededStructures[[i,4]]];
NeededStructures[[i,1]]=res[[1]];
NeededStructures[[i,4]]=res[[2]];
structure=structure*res[[3]];

res=ContractIndizes[NeededStructures[[i,2]],NeededStructures[[i,3]]];
NeededStructures[[i,2]]=res[[1]];
NeededStructures[[i,3]]=res[[2]];
structure=structure*res[[3]];

res=ContractIndizes[NeededStructures[[i,2]],NeededStructures[[i,4]]];
NeededStructures[[i,2]]=res[[1]];
NeededStructures[[i,4]]=res[[2]];
structure=structure*res[[3]];

res=ContractIndizes[NeededStructures[[i,3]],NeededStructures[[i,4]]];
NeededStructures[[i,3]]=res[[1]];
NeededStructures[[i,4]]=res[[2]];
structure=structure*res[[3]];


];
];
list1=Cases[Flatten[NeededStructures[[i]]],x_Cov];
list2=Cases[Flatten[NeededStructures[[i]]],x_Con];
res=ContractIndizes[list1,list2];
NeededStructures[[i]]=Join[res[[1]],res[[2]]];
structure=structure*res[[3]];
If[Length[NeededStructures[[i]]]>0,If[FreeQ[NeededStructures[[i]],Cov,3]||FreeQ[NeededStructures[[i]],Con,3],ind=Flatten[NeededStructures[[i]]/.{Cov[x_]->x,Con[x_]->x}];
term=epsTensor[];
For[j=1,j<=Length[ind],term=Append[term,ind[[j]]];
If[Mod[j,CurrentNumberStates[[i,1]]]==0,structure=structure*term;
term=epsTensor[];];
j++;];
If[Mod[Length[ind],CurrentNumberStates[[i,1]]]=!=0,Print["Problem in contracting ",partList];];
(*structure=structure*term;*)];];
i++;];


SA`Doc`Return[structure];

];

ContractIndizes[a_,b_]:=Block[{i,j},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "ContractIndizes";
SA`Doc`Info = "Tries to contract two sets of indices with a Delta function";
SA`Doc`Input={"a,b"->"The sets of indices"};
SA`Doc`GenerateEntry[];

tempA=a;tempB=b;term=1;
For[i=0,i<=Length[a]-1,contracted=False;
j=1;
While[j<=Length[tempB]&&contracted==False,If[Head[a[[Length[a]-i]]]=!=Head[tempB[[j]]],contracted=True;,j++;];];
If[contracted==True,term=term*(Delta[a[[Length[a]-i]],tempB[[j]]]/.{Cov[x_]->x,Con[x_]->x});
tempA=DeleteCases[tempA,a[[Length[a]-i]]];
tempB=Delete[tempB,j];];
i++;];
SA`Doc`Return[{tempA,tempB,term}];
];

ContractIndizesEps2[a_,b_]:=Block[{i,j},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "ContractIndizesEps2";
SA`Doc`Info = "Tries to contract two sets of indices with a epsilon function";
SA`Doc`Input={"a,b"->"The sets of indices"};
SA`Doc`GenerateEntry[];

tempA=a;tempB=b;term=1;
For[i=1,i<=Length[a],contracted=False;
j=1;
While[j<=Length[tempB]&&contracted==False,If[Head[a[[i]]]===Head[tempB[[j]]],contracted=True;,j++;];];
If[contracted==True,term=term*(epsTensor[a[[i]],tempB[[j]]]/.{Cov[x_]->x,Con[x_]->x});
tempA=DeleteCases[tempA,a[[i]]];
tempB=Delete[tempB,j];];
i++;];
SA`Doc`Return[{tempA,tempB,term}];
];

GenerateInvariantsTensor[group_,name_,dims_]:=Block[{i,j,k,inds={},dyn={}},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "GenerateInvariantsTensor";
SA`Doc`Info = "Finds the contractions of particles charged under a given gauge group using Susyno.";
SA`Doc`Input={"group"->"The dimension of the considered gauge group","name"->"The name of the gauge group","dims"->"The involved dimensions of the fields"};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[dims],
If[Abs[dims[[i]]]=!=1,
If[Head[dims[[i]]]===List,
dyn=Join[dyn,{dims[[i,2]]}];,
If[group===SU[2] && dims[[i]]===-2,
dyn=Join[dyn,{{-1}}];,
dyn=Join[dyn,{getDynkinLabels[dims[[i]],group]}];
];
];
inds=Join[inds,{name /. subGC[i]}];
];
i++;];
If[Length[dyn]===4,
If[Invariants[SusynoForm[group],Take[dyn,{1,2}]]=!={}&&Invariants[SusynoForm[group],Take[dyn,{3,4}]]=!={},
SA`Doc`Return[CG[group,Take[dyn,{1,2}]]@@Take[inds,{1,2}]CG[group,Take[dyn,{3,4}]]@@Take[inds,{3,4}]];
];
];
SA`Doc`Return[CG[group,dyn]@@inds];
];


SumOverExpandedIndizes[term_,partList_]:=SumOverExpandedIndizes[term,partList,False];
getFundamentalIndex[ind_]:=Block[{},
If[FreeQ[Gauge,ind]===False || FreeQ[AuxGauge,ind]===False,
Return[ind];,
Return[ToExpression[StringDrop[ToString[ind],{-1}]]];
];
];

ReplacementRuleAux[ind_]:={Delta[a_, ind]:>DELTAaux[a,ind],Delta[ind,a_]:>DELTAaux[a,ind],epsTensor[a_,ind]:>EPSaux[a,ind],epsTensor[a_,ind]:>EPSaux[a,ind],sum[ind,a__]:>SUMaux[ind,a]};

SumOverExpandedIndizes[term_,partList_,Matrix_]:=Block[{j,i,temp, temp1,pos,IndexNames={},IndexNamesSub={},iter,fin,SUB,posGauge,nr,suffix},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "SumOverExpandedIndizes";
SA`Doc`Info = "Performs the sum over expanded indices (i.e. those corresponding to a broken gauge group, e.g. 'sum[lef1,1,2] H[{lef1}]' gives 'H[{1}] + H[{2}]')";
SA`Doc`Input={"term"->"The considered term", "partList"->"The list of involved particles","Matrix"->""};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[partList],
If[partList[[i]]=!=None,
pos=Position[ListFields,partList[[i]]][[1,1]];
If[Head[GaugeListAux]===List,
(* For the case that there is an unbroken Subgroup, one has not to sum over 1..4 for SU(4) instance, but only for 1..2 and 2 contains then the 3 unbroken color charges; that's checked here *)
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],If[GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],1]]=!=True,ListFields[[pos,2,2,j,2]],GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],2]]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];,
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],ListFields[[pos,2,2,j,2]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];
];
];
i++;];

If[AuxGaugesPresent===True,
(* Perform the sum over the indices of the broken group; but replace at the same time the names of charge indices of the unbroken group by the names of the broken group *)
(* Make also use of the replacement rules of the generators *)
If[Matrix==False,
temp=term;
For[i=1, i<=Length[IndexNames],
(* get the numbering of the field summed over as well as the suffix *)
nr=ToExpression[StringTake[ToString[IndexNames[[i,1]]],{4}]];
suffix=If[StringLength[ToString[IndexNames[[i,1]]]]===4,"",StringTake[ToString[IndexNames[[i,1]]],{-1}]];
(* Replace also the delta's and eps's which involve the current variable summed over *)
If[FreeQ[UnbrokenSubgroups,getIndexFamilyName[IndexNames[[i,1]]]]===False,
temp=sum[ IndexNames[[i,1]],1,n]temp//.ReplacementRuleAux[ IndexNames[[i,1]]];
];
temp1 =Hold[Sum[temp,{iter,1,fin}]] /. {iter -> IndexNames[[i,1]], fin -> IndexNames[[i,2]]}  ;
(* temp = ReleaseHold[ReleaseHold[temp1]] /. subGeneratorAux//. UnbrokenSubgroups[[1,2]]-> (IndexNames[[i,1]] /. subNamesAux);  *)
temp = ReleaseHold[ReleaseHold[temp1]] (*/. UnbrokenSubgroups[[1,2]]\[Rule]SUFFIX[UnbrokenSubgroups[[1,2]]]/. SUFFIX[SUFFIX[x_]]\[Rule]SUFFIX[x] *)/. subGeneratorAux//. subGC[nr]//. SUFFIX[a_]:>ToExpression[ToString[a]<>suffix] /. DELTAaux->Delta /. EPSaux->epsTensor /.SUMaux->sum; 
i++;];,
temp=term;
For[i=1, i<=Length[IndexNames],
suffix=If[StringLength[ToString[IndexNames[[i,1]]]]===4,"",StringTake[ToString[IndexNames[[i,1]]],{-1}]];
If[FreeQ[UnbrokenSubgroups,getIndexFamilyName[ IndexNames[[i,1]]]]===False,
temp=temp//.ReplacementRuleAux[ IndexNames[[i,1]]];
];
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[Length[IndexNames]-i+1]]};
(* get the numbering of the field summed over *)
nr=ToExpression[StringTake[ToString[IndexNames[[i,1]]],{4}]];
(* temp=ReleaseHold[ReleaseHold[ temp1]]/. subGeneratorAux//.  UnbrokenSubgroups[[1,2]]-> (IndexNames[[i,1]] /. subNamesAux); *)
temp=ReleaseHold[ReleaseHold[ temp1]](*/. UnbrokenSubgroups[[1,2]]\[Rule]SUFFIX[UnbrokenSubgroups[[1,2]]]/. SUFFIX[SUFFIX[x_]]\[Rule]SUFFIX[x]*)/. subGeneratorAux//.   subGC[nr] //. SUFFIX[a_]:>ToExpression[ToString[a]<>suffix]/. DELTAaux->Delta /. EPSaux->epsTensor/.SUMaux->sum;
i++;];
];,
If[Matrix==False,
temp=term;
For[i=1, i<=Length[IndexNames],
temp1 =Hold[Sum[temp,{iter,1,fin}]] /. {iter -> IndexNames[[i,1]], fin -> IndexNames[[i,2]]};
temp = ReleaseHold[temp1]; 
i++;];,

temp=term;
For[i=1, i<=Length[IndexNames],
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[Length[IndexNames]-i+1]]};
temp=ReleaseHold[temp1];
i++;];
];
];

If[AuxGaugesPresent===True,
(* Function to decompose the gauge bosons of the broken group *)
temp=SplitGaugeBosonsAux[temp];
];

SA`Doc`Return[ReleaseHold[temp]];

];

SplitGaugeBosonsAux[term_]:=Block[{i,j,temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "SplitGaugeBosonsAux";
SA`Doc`Info = "Splits the gauge bosons of groups which don't get fully broken (e.g. for SU(4)->SU(3)).";
SA`Doc`Input={"term"->"The considered term"};
SA`Doc`GenerateEntry[];

temp=Expand[term];
For[i=1,i<=Length[GaugeListAux],
If[GaugeListAux[[i,1]]==True,
For[j=1,j<=4,
If[FreeQ[term,SGauge[[i]]/. subGC[j]]==False,
temp=temp /. (subGaugeBosonsAux /. {a->(generation/. subGC[j]), b->(lorentz/.subGC[j])}) /. {color -> (( Gauge[[i,3]] /. subGC[j]) /. subNamesAux)};
];
j++;];
];
i++;];
SA`Doc`Return[temp];
];

SplitGaugeBosonsAuxFabc[term_]:=Block[{i,j,temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "SplitGaugeBosonsAuxFabc";
SA`Doc`Info = "Splits the gauge bosons of groups which don't get fully broken (e.g. for SU(4)->SU(3)). Special function for terms involving the structure constants.";
SA`Doc`Input={"term"->"The considered term"}
SA`Doc`GenerateEntry[];

temp=Expand[term];
For[i=1,i<=Length[GaugeListAux],
If[GaugeListAux[[i,1]]==True,
For[j=1,j<=5,
If[FreeQ[term,SGauge[[i]]/. subGC[j]]==False,
temp=Expand[temp] //. (subGaugeBosonsAuxFabc /. {a->(generation/. subGC[j]), b->(lorentz/.subGC[j])}) /. {color -> (( Gauge[[i,3]] /. subGC[j]) /. subNamesAux)};
];
j++;];
];
i++;];
SA`Doc`Return[temp];
];

(*H*)(*Analogous routines as for GB,to be used in generating gauge transformations*)
SplitGhostsAux[term_]:=Block[{i,j,temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "SplitGhostsAux";
SA`Doc`Info = "Splits the ghosts bosons of groups which don't get fully broken (e.g. for SU(4)->SU(3)).";
SA`Doc`Input={"term"->"The considered term"};
SA`Doc`GenerateEntry[];

temp=Expand[term];
For[i=1,i<=Length[GaugeListAux],If[GaugeListAux[[i,1]]==True,For[j=1,j<=4,If[FreeQ[term,getGhost[Head[SGauge[[i]]]][{SGauge[[i,1,1]]}]/.subGC[j]]==False,temp=temp/.(subGhostsAux/.{a->(generation/.subGC[j]),b->(lorentz/.subGC[j])})/.{color->((Gauge[[i,3]]/.subGC[j])/.subNamesAux)};];
j++;];];
i++;];
SA`Doc`Return[temp];];

SplitGhostsAuxFabc[term_]:=Block[{i,j,temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "SplitGhostsAuxFabc";
SA`Doc`Info = "Splits the ghosts bosons of groups which don't get fully broken (e.g. for SU(4)->SU(3)).  Special function for terms involving the structure constants.";
SA`Doc`Input={"term"->"The considered term"};
SA`Doc`GenerateEntry[];

temp=Expand[term];
For[i=1,i<=Length[GaugeListAux],
If[GaugeListAux[[i,1]]==True,
For[j=1,j<=5,
If[FreeQ[term,getGhost[Head[SGauge[[i]]]][{SGauge[[i,1,1]]}]/.subGC[j]]==False,temp=Expand[temp]//.(subGhostsAuxFabc/.{a->(generation/.subGC[j]),b->(lorentz/.subGC[j])})/.{color->((Gauge[[i,3]]/.subGC[j])/.subNamesAux)} /. {gen1->col1};
];
j++;];];
i++;];
SA`Doc`Return[temp];];




(* ::Input::Initialization:: *)
(* ------------------------------------------- *)
(* Particle Properties *)
(* ------------------------------------------- *)


(* ::Input::Initialization:: *)

getGenerator[k_,dim_,lor_,p1_,p2_]:=If[Gauge[[k,2]]===U[1],dim,
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getGenerator";
SA`Doc`Info = "Wrapper function to obtain the generator for a given gauge group and  Irrep.";
SA`Doc`Input={"k"->"Position of the gauge group in 'Gauge'","dim"->"Dimension of the field under the gauge group","lor"->"The Lorentz index","p1,p2"->"The indices for the involved fields"};
SA`Doc`GenerateEntry[];

If[Gauge[[k,5]]===True,
SA`Doc`Return[ReleaseHold[Generator[Gauge[[k,2]],getDynkinLabels[dim,Gauge[[k,2]]],Gauge[[k,3]]][lor,p1,p2]]];,
SA`Doc`Return[Generator[Gauge[[k,2]],getDynkinLabels[dim,Gauge[[k,2]]]][getAdjointIndex[Gauge[[k,3]]]/. subGC[lor],Gauge[[k,3]]/.subGC[p1],Gauge[[k,3]]/.subGC[p2]]];
];
];

getStructureConstant[group_,p1_,p2_,p3_]:=Block[{erg},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getStructureConstant";
SA`Doc`Info = "Wrapper function to obtain the structure constant for a gauge group.";
SA`Doc`Input={"group"->"Position of the gauge group in 'Gauge'","p1,p2,p3"->"The indices for the involved fields"};
SA`Doc`GenerateEntry[];

If[Gauge[[group,2]]==1,SA`Doc`Return[0];];
Set[erg,FST[Gauge[[group,2]]][p1,p2,p3]];
SA`Doc`Return[erg];
];

(* getAdjointIndex[name_]:=ToExpression["adj"<>StringTake[ToString[name],3]]; *)
getAdjointIndex[name_]:=Block[{pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getAdjointIndex";
SA`Doc`Info = "Returns the adjoint index. (Most likely no longer needed!)";
SA`Doc`Input={"name"->"name of the gauge group"};
SA`Doc`GenerateEntry[];

pos=Position[Gauge,name][[1,1]];
If[Gauge[[pos,5]]===False,
SA`Doc`Return[name];
(* Return[ToExpression["adj"<>ToString[name]]]; *),
SA`Doc`Return[generation];
];
];

getIndexFamilyName[x_]:=Block[{i,j,pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getIndexFamilyName";
SA`Doc`Info = "Return the name of the gauge group for a given index carrying a number, e.g. col1->color";
SA`Doc`Input={"x"->"The considered index"};
SA`Doc`GenerateEntry[];

pos=Position[Table[StringTake[ToString[Gauge[[i,3]]],{1,3}],{i,1,Length[Gauge]}],StringTake[ToString[x],{1,3}]];
SA`Doc`Return[Gauge[[pos[[1,1]],3]]];

];

getCoeff[doub_,k_,lNr_,p1_,p2_]:=FieldDim[doub,k];

getIndexRange[x_]:=Block[{i,ind,result},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getIndexRange";
SA`Doc`Info = "Returns the range of a considered index";
SA`Doc`Input={"x"->"The considered index"};
SA`Doc`GenerateEntry[];

ind=getIndizes[x];
result={};
For[i=1,i<=Length[ind],
Switch[ind[[i]],
lorentz,0;,
generation,result=Join[result,{{generation,getGen[x]}}];,
_,result = Join[result,{{ind[[i]],getNumberStates[ind[[i]]]}}];
];
i++;];
SA`Doc`Return[result];
];

getScalar[x_]:=ToExpression["S"<>ToString[x]];
getSF[x_]:=Block[{pos,field},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getSF";
SA`Doc`Info = "Returns the superfield corresponding to a component field";
SA`Doc`Input={"x"->"The considered field"};
SA`Doc`GenerateEntry[];

field = getBlank[x];
If[FreeQ[SFields,field],
pos=Position[FFields,field];
If[pos=!={},
SA`Doc`Return[Fields[[pos[[1,1]]]][[3]]];
];,
pos=Position[SFields,field];
If[pos=!={},
SA`Doc`Return[Fields[[pos[[1,1]]]][[3]]];
];
];
];


getGhost[VBoson_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getGhost";
SA`Doc`Info = "Returns the ghost of a vector boson.";
SA`Doc`Input={"VBoson"->"The considered vector boson"};
SA`Doc`GenerateEntry[];

If[Head[VBoson]===conj,
SA`Doc`Return[ToExpression["g"<>StringDrop[ToString[RE[VBoson]],1]<>"C"]];,
SA`Doc`Return[ToExpression["g"<>StringDrop[ToString[VBoson],1]]];
];
]; 

getVectorBoson[Ghost_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getVectorBoson";
SA`Doc`Info = "Returns the vector boson of a ghost.";
SA`Doc`Input={"VBoson"->"The considered Ghost"};
SA`Doc`GenerateEntry[];

ghost=ToString[getBlank[Ghost]];
If[StringTake[ghost,-1]==="C",ghost =StringDrop[ghost,-1];];
SA`Doc`Return[ToExpression["V"<>StringDrop[ghost,1]]];
]; 

getAuxScalar[scalar_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getAuxScalar";
SA`Doc`Info = "Return the auxiliary field of a scalar.";
SA`Doc`Input={"scalar"->"The considered scalar"};
SA`Doc`GenerateEntry[];

If[Head[scalar]===conj,
SA`Doc`Return[conj[getFull[ToExpression["A"<>StringDrop[ToString[getBlank[scalar]],1]]]]];,
SA`Doc`Return[getFull[ToExpression["A"<>StringDrop[ToString[getBlank[scalar]],1]]]];
];
]; 

getAuxVector[vector_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getAuxVector";
SA`Doc`Info = "Return the auxiliary field of a vector.";
SA`Doc`Input={"vector"->"The considered vector"};
SA`Doc`GenerateEntry[];

If[Head[vector]===conj,
SA`Doc`Return[conj[ToExpression["A"<>StringDrop[ToString[RE[vector]],1]]]];,
SA`Doc`Return[ToExpression["A"<>StringDrop[ToString[vector],1]]];
];
]; 

getColorDim[field_]:=Block[{temp},
temp=Select[getIndizesWI[field],FreeQ[#,color]==False&];
If[temp==={},Return[1];,Return[temp[[1,2]]];];
]


(* ::Input::Initialization:: *)
UseSymmASymm=False;

SymmetriceIndices[Operator_,length_,SameInd_,preFac_]:=Block[{i,Op,Op2,GEN1,GEN2,OP,OP2},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "SymmetriceIndices";
SA`Doc`Info = "Takes an object and symmetrices/anti-symmetrices the indices of it";
SA`Doc`Input={"Operator"->"The considered object","length"->"the number of indices in total","SameInd"->"The indices whiche are of the smae kind", "preFac"->"The prefactor after shufflng the indices"};
SA`Doc`GenerateEntry[];

Op=Operator[]; Op2=Operator[];
For[i=1,i<=length,
Op=Append[Op,generation /. subGCRule[i]];
If[MemberQ[SameInd,i],
Op2=Append[Op2,(generation /. subGC[DeleteCases[SameInd,i][[1]]])];,
Op2=Append[Op2,(generation /. subGC[i])];
];
i++;];
ReleaseHold[Hold[SetDelayed[OP,preFac OP2 /; (OrderedQ[{(GEN1),(GEN2)}]==False&& UseSymmASymm==True)]] /. OP->Op /. OP2 ->Op2 /. GEN1 -> (generation /. subGC[SameInd[[1]]])/. GEN2 -> (generation /. subGC[SameInd[[2]]])];
SA`Doc`EndEntry[];
];

ExtractSymmetryOfParametersNS[Op_,listP_,ind_]:=Block[{i,j,same,sameDis,pos,org,rep,posDef,gens,symmetry},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "ExtractSymmetryOfParametersNS";
SA`Doc`Info = "Takes a parameters and checks if it is symmetric under the exchange of indices. This version is used for non-SUSY models.";
SA`Doc`Input={"Op"->"The considered object","listP"->"The list of involved fields","ind"->"The involved indices"};
SA`Doc`GenerateEntry[];

If[MemberQ[SA`SymmetryAlreadyDefined,Op],SA`Doc`Return[];];
same=Select[RE/@listP,(Count[RE/@listP,#]>1)&];
If[same==={}||FreeQ[FGauge,listP[[1]]]==False,SA`Doc`Return[];];
(* If[AtomQ[Op]&&FreeQ[Superpotential,Op],Return[];]; *)
sameDis=Intersection[same];
(* ind=MakeIndexStructure[listP]; *)
If[Times@@getGen/@sameDis===1,SA`Doc`Return[];];
For[i=1,i<=Length[sameDis],
If[getGen[sameDis[[i]]]===99,
gens=getGenSF[sameDis[[i]]];,
gens=getGen[sameDis[[i]]];
];
(* If[Extract[Fields,Position[Fields,sameDis[[i]]]\[LeftDoubleBracket]1,1\[RightDoubleBracket]]\[LeftDoubleBracket]2\[RightDoubleBracket]>1, *)
If[gens>1,
pos=Position[listP,sameDis[[i]]];
rep=ind /.Join[subGCRE[pos[[1,1]],pos[[2,1]]], subGCRE[pos[[2,1]],pos[[1,1]]]];
posDef=Position[ParameterDefinitions,Op];
If[rep===ind,
If[MemberQ[listP,conj[sameDis[[i]]]] && MemberQ[listP,sameDis[[i]]],symmetry=Hermitian;,symmetry=Symmetric;];
PrintDebug["   Defined ",Op," as ",symmetry];
DefineSymmetryOp[Op,symmetry,pos, listP];
If[posDef=!={},
ParameterDefinitions[[posDef[[1,1]],2]]=Join[ParameterDefinitions[[posDef[[1,1]],2]],{Symmetry->symmetry}];,
ParameterDefinitions=Join[ParameterDefinitions,{{Op,{Symmetry->symmetry}}}];
];,
If[rep===-ind,
If[MemberQ[listP,conj[sameDis[[i]]]] && MemberQ[listP,sameDis[[i]]],symmetry=AnitHermitian;,symmetry=AntiSymmetric;];
PrintDebug["   Defined ",Op," as ",symmetry];
DefineSymmetryOp[Op,symmetry,pos,listP];
If[posDef=!={},
ParameterDefinitions[[posDef[[1,1]],2]]=Join[ParameterDefinitions[[posDef[[1,1]],2]],{Symmetry->symmetry}];,
ParameterDefinitions=Join[ParameterDefinitions,{{Op,{Symmetry->symmetry}}}];
];,
Symmetry::Unknown="Symmetric of parameter `` can not be resolved. Indexstructure: ``";
(* Message[Symmetry::Unknown,Op,rep]; *)
];
];
];
i++;];
SA`Doc`EndEntry[];
];

ExtractSymmetryOfParameters[Op_,listP_]:=Block[{i,j,same,sameDis,pos,org,rep,ind,posDef,gens,symmetry},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "ExtractSymmetryOfParameters";
SA`Doc`Info = "Takes a parameters and checks if it is symmetric under the exchange of indices. This version is used for SUSY models.";
SA`Doc`Input={"Op"->"The considered object","listP"->"The list of involved fields","ind"->"The involved indices"};
SA`Doc`GenerateEntry[];

If[MemberQ[SA`SymmetryAlreadyDefined,Op],SA`Doc`Return[];];
same=Select[RE/@listP,(Count[RE/@listP,#]>1)&];
If[same==={}||FreeQ[FGauge,listP[[1]]]==False,SA`Doc`Return[];];
(* If[AtomQ[Op]&&FreeQ[Superpotential,Op],Return[];]; *)
sameDis=Intersection[same];
(* ind=MakeIndexStructure[listP]; *)
If[Times@@getGen/@sameDis===1,SA`Doc`Return[];];
ind=MakeIndexStructureRGE[listP];
For[i=1,i<=Length[sameDis],
If[getGen[sameDis[[i]]]===99,
gens=getGenSF[sameDis[[i]]];,
gens=getGen[sameDis[[i]]];
];
(* If[Extract[Fields,Position[Fields,sameDis[[i]]]\[LeftDoubleBracket]1,1\[RightDoubleBracket]]\[LeftDoubleBracket]2\[RightDoubleBracket]>1, *)
If[gens>1,
pos=Position[listP,sameDis[[i]]];
rep=ind /.Join[subGCRE[pos[[1,1]],pos[[2,1]]], subGCRE[pos[[2,1]],pos[[1,1]]]];
posDef=Position[ParameterDefinitions,Op];
If[rep===ind,
If[MemberQ[listP,conj[sameDis[[i]]]] && MemberQ[listP,sameDis[[i]]],symmetry=Hermitian;,symmetry=Symmetric;];
PrintDebug["   Defined ",Op," as ",symmetry];
DefineSymmetryOp[Op,symmetry,pos, listP];
If[posDef=!={},
ParameterDefinitions[[posDef[[1,1]],2]]=Join[ParameterDefinitions[[posDef[[1,1]],2]],{Symmetry->symmetry}];,
ParameterDefinitions=Join[ParameterDefinitions,{{Op,{Symmetry->symmetry}}}];
];,
If[rep===-ind,
If[MemberQ[listP,conj[sameDis[[i]]]] && MemberQ[listP,sameDis[[i]]],symmetry=AnitHermitian;,symmetry=AntiSymmetric;];
PrintDebug["   Defined ",Op," as ",symmetry];
DefineSymmetryOp[Op,symmetry,pos,listP];
If[posDef=!={},
ParameterDefinitions[[posDef[[1,1]],2]]=Join[ParameterDefinitions[[posDef[[1,1]],2]],{Symmetry->symmetry}];,
ParameterDefinitions=Join[ParameterDefinitions,{{Op,{Symmetry->symmetry}}}];
];,
Symmetry::Unknown="Symmetric of parameter `` can not be resolved. Indexstructure: ``";
(* Message[Symmetry::Unknown,Op,rep]; *)
];
];
];
i++;];
SA`Doc`EndEntry[];
];

DefineSymmetryOp[Op_,symmetry_,posIN_,listP_]:=Block[{len,pos,i,j},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "DefineSymmetryOp";
SA`Doc`Info = "Creates functions to handle the indices of a parameter according to the given symmetry.";
SA`Doc`Input={"Op"->"The conisdered parameters","symmetry"->"The given symmetry","posIN"->"List with the position of indices which are symmetric","listP"->"The list of involved particles"};
SA`Doc`GenerateEntry[];

SA`SymmetryAlreadyDefined = Join[SA`SymmetryAlreadyDefined,{Op}];
pos=Table[posIN[[i,1]],{i,1,Length[posIN]}];
len=getGen/@(RE/@listP);
If[FreeQ[len,99]==False,
len=getGenSF/@(RE/@listP);
];
 len=DeleteCases[len,1]; 
Switch[Length[len],
2,
Switch[symmetry,
Symmetric, 
	Op[b_,c_]:=Op[c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True);
	Tp[Op] =Op;
	Adj[Op] = conj[Op]; 
	If[MemberQ[ListSymmetricParameters,(Op /. conj[x_]->x)]==False,ListSymmetricParameters=Join[ListSymmetricParameters,{Op}];];,
AntiSymmetric, 
	Op[b_,c_]:=-Op[c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
	Op[b_,b_]:=0 /;(UseSymmASymm==True); 
	Tp[Op] = -Op;
	Adj[Op] = -conj[Op];
	If[MemberQ[ListAntiSymmetricParameters,(Op /. conj[x_]->x)]==False,ListAntiSymmetricParameters=Join[ListAntiSymmetricParameters,{Op}];];,
Hermitian,
	 conj[Op[b_,c_]]:=Op[c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True);  
	Tp[Op] := Conj[Op];
	Adj[Op] := Op;
];,

3,
Switch[pos,
{1,2},
Switch[symmetry,
Symmetric, 
	Op[b_,c_,a_]:=Op[c,b,a] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True);
	Op[n_Integer][b_,c_]:=Op[n][c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True);
	Tp[Op[n_Integer]]:=Op[n];
	Adj[Op[n_Integer]]:=conj[Op[n]];
	If[MemberQ[ListSymmetricParameters,(Op /. conj[x_]->x)]==False,ListSymmetricParameters=Join[ListSymmetricParameters,{Op}];];
For[j=1,j<=len[[3]],
	If[MemberQ[ListSymmetricParameters,(Op[j] /. conj[x_]->x)]==False,ListSymmetricParameters=Join[ListSymmetricParameters,{Op[j]}];];
j++;];,
AntiSymmetric, 
	Op[b_,c_,a_]:=-Op[c,b,a] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
	Op[n_Integer][b_,c_]:=-Op[n][c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
	Op[b_,b_,a_]:=0 /;( UseSymmASymm==True); 
	Op[n_Integer][b_,b_]:=0 /;( UseSymmASymm==True); 
	Tp[Op[n_Integer]]:=-Op[n];
	Adj[Op[n_Integer]]:=-conj[Op[n]];
	If[MemberQ[ListAntiSymmetricParameters,(Op /. conj[x_]->x)]==False,ListAntiSymmetricParameters=Join[ListAntiSymmetricParameters,{Op}];];
	For[j=1,j<=len[[3]],
	If[MemberQ[ListAntiSymmetricParameters,(Op[j] /. conj[x_]->x)]==False,ListAntiSymmetricParameters=Join[ListAntiSymmetricParameters,{Op[j]}];];
	j++;];,
Hermitian,
	conj[Op[b_,c_,a_]]:=Op[c,b,a] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
	conj[Op[n_Integer][b_,c_]]:=Op[n][c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
	Tp[Op[n_Integer]]:=Conj[Op[n]];
	Adj[Op[n_Integer]]:=Op[n];
];,
{1,3},
Switch[symmetry,
Symmetric, 
	Op[b_,a_,c_]:=Op[c,a,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True);
	If[MemberQ[ListSymmetricParameters,(Op /. conj[x_]->x)]==False,ListSymmetricParameters=Join[ListSymmetricParameters,{Op}];];,
AntiSymmetric, 
	Op[b_,a_,c_]:=-Op[c,a,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
	Op[b_,a_,b_]:=0 /;( UseSymmASymm==True); 
	If[MemberQ[ListAntiSymmetricParameters,(Op /. conj[x_]->x)]==False,ListAntiSymmetricParameters=Join[ListAntiSymmetricParameters,{Op}];];,
Hermitian,
	conj[Op[b_,a_,c_]]:=Op[c,a,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
];,
{2,3},
Switch[symmetry,
Symmetric, 
	Op[a_,b_,c_]:=Op[a,c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True);
	If[MemberQ[ListSymmetricParameters,(Op /. conj[x_]->x)]==False,ListSymmetricParameters=Join[ListSymmetricParameters,{Op}];];,
AntiSymmetric, 
	Op[a_,b_,c_]:=-Op[a,c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
	Op[a_,b_,b_]:=0 /;( UseSymmASymm==True); 
	If[MemberQ[ListAntiSymmetricParameters,(Op /. conj[x_]->x)]==False,ListAntiSymmetricParameters=Join[ListAntiSymmetricParameters,{Op}];];,
Hermitian,
	conj[Op[a_,b_,c_]]:=Op[a,c,b] /;(OrderedQ[{b,c}]==False && UseSymmASymm==True); 
];,
{1,2,3},
Switch[symmetry,
Symmetric, 
	Op[a_,c_,b_]:=Op[a,b,c] /;(OrderedQ[{c,b}]==False && UseSymmASymm==True);
	Op[b_,a_,c_]:=Op[a,b,c] /;(OrderedQ[{b,a}]==False && UseSymmASymm==True);
	Op[c_,b_,a_]:=Op[a,b,c] /;(OrderedQ[{c,a}]==False && UseSymmASymm==True);
	If[MemberQ[ListSymmetricParameters,(Op /. conj[x_]->x)]==False,ListSymmetricParameters=Join[ListSymmetricParameters,{Op}];];,
AntiSymmetric, 
	Op[a_,c_,b_]:=-Op[a,b,c] /;(OrderedQ[{c,b}]==False && UseSymmASymm==True); 
	Op[c_,b_,a_]:=-Op[a,b,c] /;(OrderedQ[{c,a}]==False && UseSymmASymm==True); 
	Op[b_,a_,c_]:=-Op[a,b,c] /;(OrderedQ[{b,a}]==False && UseSymmASymm==True); 
	Op[a_,b_,b_]:=0 /;( UseSymmASymm==True); 
	Op[a_,a_,b_]:=0 /;( UseSymmASymm==True); 
	Op[a_,b_,a_]:=0 /;( UseSymmASymm==True); 
	If[MemberQ[ListAntiSymmetricParameters,(Op /. conj[x_]->x)]==False,ListAntiSymmetricParameters=Join[ListAntiSymmetricParameters,{Op}];];,
Hermitian,
	conj[Op[a_,c_,b_]]:=Op[a,b,c] /;(OrderedQ[{c,b}]==False && UseSymmASymm==True); 
	conj[Op[c_,b_,a_]]:=Op[a,b,c] /;(OrderedQ[{c,a}]==False && UseSymmASymm==True); 
	conj[Op[b_,a_,c_]]:=Op[a,b,c] /;(OrderedQ[{b,a}]==False && UseSymmASymm==True); 
];
];
];
SA`Doc`EndEntry[];
];

CheckSymmetry[Op_,part_,sameInd_]:=Block[{pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CheckSymmetry";
SA`Doc`Info = "Takes a parameters and checks if it is symmetric under the exchange of indices. This is mainly a wrapper for 'ExtractSymmetryOfParameters' which in addition checks if a parameter is real. ";
SA`Doc`Input={"Op"->"The considered object","part"->"The list of involved fields","ind"->"The involved indices"};
SA`Doc`GenerateEntry[];

ExtractSymmetryOfParameters[Op,part]; 

If[FreeQ[Transpose[ParameterDefinitions][[1]],Op]==False,
pos=Position[Transpose[ParameterDefinitions][[1]],Op][[1,1]];
If[(Real/.Extract[ParameterDefinitions,pos][[2]])===True && FreeQ[realVar,Op],realVar=Join[realVar,{Op}]];
];
SA`Doc`EndEntry[];
];

CheckSymmetryLarger[Op_,part_,same_,len_]:=Block[{pos,subs},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CheckSymmetryLarger";
SA`Doc`Info = "Takes a parameters and checks if it is symmetric under the exchange of indices. This is mainly a wrapper for 'ExtractSymmetryOfParameters' which in addition checks if a parameter is real. ";
SA`Doc`Input={"Op"->"The considered object","part"->"The list of involved fields","same"->"NO LONGER USED", "len"->"NO LONGER USED"};
SA`Doc`GenerateEntry[];

 ExtractSymmetryOfParameters[Op,part];
If[FreeQ[Transpose[ParameterDefinitions][[1]],Op]==False,
pos=Position[Transpose[ParameterDefinitions][[1]],Op][[1,1]];
If[(Real/.Extract[ParameterDefinitions,pos][[2]])===True && FreeQ[realVar,Op],realVar=Join[realVar,{Op}]];
subs=Flatten[Map[Subsets[#,{2}]&,same],1];
]; 
SA`Doc`EndEntry[];
];


genTest[Op_,listP_,AddSB_]:=Block[{i,res,struct,gens,genstruct,temp, SBHeader,listPGen},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "genTest";
SA`Doc`Info = "Checks if a given parameter needs to carry generation indices (depending on the involved fields) and adds them.";
SA`Doc`Input={"Op"->"The name of the parameters","listP"->"The list of involved fields","AddSB"->"Add a soft-breaking term?"};
SA`Doc`GenerateEntry[];

If[Depth[Op]==2,
newHead=Op[[0]];Opc=Op[[1]];AddHead=True;,
AddHead=False; Opc = Op;
];


If[FreeQ[getType/@(RE/@listP),NoField],
listPGen = DeleteCases[(listP /. conj[x_]->x),_?((getGen[RE[#]]<2)&)];,
listPGen = DeleteCases[(listP /. conj[x_]->x),_?((getGenSF[RE[#]]<2)&)];
];
If[listPGen=!={},
sameIndices = Flatten/@Table[Position[Count[listPGen/. a_?(TrueQ[#=!=Intersection[listPGen][[i]]] && Head[#]=!=List&)->NIX,#]&/@listPGen,_?((#>1)&),3],{i,1,Length[Intersection[listPGen]]}];
];
If[AddSB==True,
Switch[Length[listP],
4, SBHeader = Q;,
3, SBHeader= T;,
2, SBHeader = B;,
1, SBHeader = L;
];
Switch[Length[listPGen],
4,  CheckSymmetryLarger[SBHeader[Opc],listP,sameIndices,4];,
3,  CheckSymmetryLarger[SBHeader[Opc],listP,sameIndices,3];,
2,  CheckSymmetry[SBHeader[Opc],listP,sameIndices];,
1,  CheckSymmetry[SBHeader[Opc],listP,sameIndices];,
0,  CheckSymmetry[SBHeader[Opc],listP,sameIndices];
];

];

Switch[Length[listPGen],
4, CheckSymmetryLarger[Opc,listP,sameIndices,4];,
3, CheckSymmetryLarger[Opc,listP,sameIndices,3];,
2,  CheckSymmetry[Opc,listP,sameIndices];,
1,  CheckSymmetry[Opc,listP,sameIndices];,
0,  CheckSymmetry[Opc,listP,sameIndices];
];

(* If[FreeQ[Fields,RE[listP[[1]]]]\[Equal]False, *)
If[Select[RE/@listP,FreeQ[Fields,#]&]==={},
gens = Table[Extract[Fields,Position[Fields,RE[listP[[i]]]][[1,1]]][[2]],{i,1,Length[listP]}];,
gens = Table[getGen[listP[[i]]],{i,1,Length[listP]}];
];
pT = Table[If[gens[[i]]>1,genf[i],0],{i,1,Length[listP]}];
gens = DeleteCases[gens,1];


If[FreeQ[Transpose[ParameterDefinitions][[1]],Opc]==False,
Switch[(Form/.Extract[ParameterDefinitions,Position[ParameterDefinitions,Opc][[1,1]]][[2]]),
Scalar,
		res=Opc; genStruct=1; gens={};,
Diagonal,
		res=DeleteCases[Opc@@pT,0] /. A_[]->A;genStruct=DeleteCases[DeltaF@@pT,0] /. DeltaF[]->1 /. DeltaF[x_]->1;,
_,
		res=DeleteCases[Opc@@pT,0] /. A_[]->A;genStruct = 1;
];,
res=DeleteCases[Opc@@pT,0] /. A_[]->A;
genStruct = 1;	
];
genStruct= genStruct /. {DeltaF[a_,b_]->Delta[a,b], DeltaF[a_,b_,c_]->Delta[a,b] Delta[b,c] Delta[a,c]};


(*
If[FreeQ[parameters,Opc]\[Equal]True,
parameters=Join[parameters,{{Opc,Table[generation,{Length[gens]}],gens}}];
If[AddSB\[Equal]True,parameters=Join[parameters,{{SBHeader[Opc],Table[generation,{Length[gens]}],gens}}];];
];
*)

If[MemberQ[Table[parameters[[i,1]],{i,1,Length[parameters]}],Opc]==False,
parameters=Join[parameters,{{Opc,Table[generation,{Length[gens]}],gens}}];
];
If[AddSB==True && MemberQ[Table[parameters[[i,1]],{i,1,Length[parameters]}],SBHeader[Opc]]==False,
parameters=Join[parameters,{{SBHeader[Opc],Table[generation,{Length[gens]}],gens}}];
];



If[Length[DeleteCases[pT,0]]<=1,
Tp[Opc]=Opc;Adj[Opc]=conj[Opc];
VectorParameters=Join[VectorParameters,{Opc,SBHeader[Opc]}];
Tp[SBHeader[Opc]]=SBHeader[Opc];Adj[SBHeader[Opc]]=conj[SBHeader[Opc]];
];

If[AddHead==True,
SA`Doc`Return[newHead[res]*genStruct];,
SA`Doc`Return[res*genStruct];
];
];

getGenSF[part_]:=Extract[Extract[Fields,Position[Fields,part][[1,1]]],2];
getGen[part_]:=getGen[part,SA`CurrentStates];
getGenALL[part_]:=getGen[part,ALL];
getFla[part_]:=getFla[part,SA`CurrentStates];
getFlaALL[part_]:=getFla[part,ALL];

getGen[part_,states_]:=Block[{pos, particle,partTemp,j,cparticles},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getGen";
SA`Doc`Info = "Returns the number of generations of a givnen particle";
SA`Doc`Input={"part"->"Name of the particles","states"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

partTemp= getBlank[DeleteCases[getBlank[part],x_?NumberQ,4]];
particle = getParticleName[partTemp];
cparticles=Table[Particles[states][[j,1]],{j,1,Length[Particles[states]]}];
If[FreeQ[cparticles,getBlank[particle]]==False,
(* pos = Position[Particles[states],getBlank[particle]]; *)
pos = Position[cparticles,getBlank[particle]];
If[pos=!={},
SA`Doc`Return[Evaluate[Extract[Particles[states],pos[[1,1]]][[3]]/. GetGen -> getGen]];,
Message[Particle::unknown ,part];
SA`Doc`Return[0];
];,
If[FreeQ[SFields,particle]==False,
SA`Doc`Return[Fields[[Position[SFields,particle][[1,1]],2]]];
];
If[FreeQ[FFields,particle]==False,
SA`Doc`Return[Fields[[Position[FFields,particle][[1,1]],2]]];
];
SA`Doc`Return[99];
];
]/; (FreeQ[part,getGen]==True);

getFla[part_,states_]:=Block[{pos, particle,partTemp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getFla";
SA`Doc`Info = "Returns the number of flavours of a given particle";
SA`Doc`Input={"part"->"Name of the particles","states"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

partTemp= getBlank[DeleteCases[getBlank[part],x_?NumberQ,4]];
particle = getParticleName[partTemp];
If[FreeQ[Particles[states],getBlank[particle]]==False,
pos = Position[Particles[states],getBlank[particle]];
If[pos=!={},
If[Length[Extract[Particles[states],pos[[1,1]]]]==6,
SA`Doc`Return[Evaluate[Extract[Particles[states],pos[[1,1]]][[6]]/. GetGen -> getGen]];,
SA`Doc`Return[1];
];,
Message[Particle::unknown ,part];
SA`Doc`Return[0];
];,
SA`Doc`Return[1];
];
]/; (FreeQ[part,getGen]==True);


(*
getGenOne[x_]:=Block[{part},
If[FreeQ[GaugeMassES,getBlank[x]]\[Equal]False,
part=Extract[GaugeMassESorg,Position[GaugeMassES,getBlank[x]][[1,1]]];,
part=getBlank[x];
];
If[FreeQ[OnlyOneGen,part]\[Equal]False,
Return[1];,
Return[getGen[part]];
];
];
*)

getGenStart[part_]:=Block[{pos, particle},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getGenStart";
SA`Doc`Info = "Returns the number of the first generation of a given particle (only needed for effective theories)";
SA`Doc`Input={"part"->"Name of the particles"};
SA`Doc`GenerateEntry[];

particle = getBlank[DeleteCases[getBlank[part],x_?NumberQ,4]];
particle = getParticleName[particle];
pos = Position[Particles[Current],particle];
If[pos=!={},
SA`Doc`Return[Evaluate[Extract[Particles[Current],pos[[1,1]]][[2]]/. GetGen -> getGen]];,
If[FreeQ[SFields,particle]==False,
SA`Doc`Return[1];
];
If[FreeQ[FFields,particle]==False,
SA`Doc`Return[1];
];
Message[Particle::unknown ,part];
(* Print["ERROR (getGenStart)  ",part, particle]; *)
SA`Doc`Return[0];
];
] /; (FreeQ[part,getGen]==True);


GetGen[x_]:= getGen[x] /; (SetGenerations==True);
GetGenStart[x_]:= getGenStart[x] /; (SetGenerations==True);


(* ::Input::Initialization:: *)

getNumberStatesAdjoint[group_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getNumberStatesAdjoint";
SA`Doc`Info = "Returns the name of states in the adjoint representation of a given group";
SA`Doc`Input={"group"->"The considered gauge group"};
SA`Doc`GenerateEntry[];

Switch[Head[group],
U,SA`Doc`Return[1];,
SU,SA`Doc`Return[group[[1]]^2-1];
];
];

(*
getNumberStates[charge_]:=Block[{cCharge,pos, particle,i},
cCharge = DeleteCases[charge,x_?NumberQ];
If[StringTake[ToString[cCharge],3]==="adj",
cCharge=ToExpression[StringDrop[ToString[cCharge],3]];
pos = Position[Gauge,cCharge][[1,1]];
Return[(Extract[Gauge,pos][[2,1]]^2-1)];,
If[FreeQ[Gauge,cCharge],
cCharge=ToExpression[StringDrop[ToString[cCharge],-1]];
]; 
pos = Position[Gauge,cCharge][[1,1]];
Return[(Extract[Gauge,pos][[2,1]])];
];
];
*)

getNumberStates[charge_]:=Block[{cCharge,pos,particle,i,GaugeHere},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getNumberStates";
SA`Doc`Info = "Returns the name of states in the fundamental representation of a given group";
SA`Doc`Input={"charge"->"The considered gauge group"};

SA`Doc`GenerateEntry[];

cCharge=DeleteCases[charge,x_?NumberQ];
(*H*)(*If AuxGaugesPresent,one has to take into account also the unbroken subgroup*)
If[AuxGaugesPresent===True,GaugeHere=Join[Gauge,AuxGauge];,GaugeHere=Gauge];
If[StringTake[ToString[cCharge],3]==="adj",
cCharge=ToExpression[StringDrop[ToString[cCharge],3]];
pos=Position[GaugeHere,cCharge][[1,1]];
SA`Doc`Return[(Extract[GaugeHere,pos][[2,1]]^2-1)];,
If[FreeQ[GaugeHere,cCharge],
cCharge=ToExpression[StringDrop[ToString[cCharge],-1]];];
pos=Position[GaugeHere,cCharge][[1,1]];
SA`Doc`Return[(Extract[GaugeHere,pos][[2,1]])];
];
];


getNumberGenerators[charge_]:=((Extract[Gauge, Position[Gauge,charge][[1,1]]][[2,1]])^2-1);

getSumFields[field_,nr_]:=Times@@(sum[#[[1]]/.subGC[nr],1,#[[2]]]&/@ListFields[[field,3,2]]);



getType[part_]:=getType[part,False,SA`CurrentStates];
getTypeOld[part_]:=getType[part,False,ALL];
getType[part_,True]:=getType[part,True,SA`CurrentStates];

 getType[part_,init_,states_]:=Block[{pos, particle},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getType";
SA`Doc`Info = "Returns the generic type of a given particle";
SA`Doc`Input={"part"->"Name of the particles","init"->"is it a particle present during initialisation only?","states"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

particle = getParticleName[part];
If[init==True,
If[FreeQ[typeList,particle]==False,
SA`Doc`Return[Extract[typeList,Position[typeList,particle][[1,1]]][[2]]];,
SA`Doc`Return[NoField];
];
];

If[FreeQ[vacuum,particle]==True && FreeQ[typeList,particle],SA`Doc`Return[NoField];];
If[FreeQ[Particles[states],RE[particle]]==False,
pos = Drop[DeleteCases[Position[Particles[states],particle,3,1][[1]],0],-1];
SA`Doc`Return[Extract[Particles[states],pos][[4]]];,
If[FreeQ[typeList,particle]==False,
SA`Doc`Return[Extract[typeList,Position[typeList,particle][[1,1]]][[2]]];
];
SA`Doc`Return[NoField];
];
];



(* ::Input::Initialization:: *)

getParticleName[part_]:=
If[MemberQ[diracFermions[SA`CurrentStates],getBlank[part]]==True,
Return[Select[getBlank[part]/.diracSub[SA`CurrentStates],#=!=0&,1][[1]]];,
If[MemberQ[diracFermions[ALL],getBlank[part]]==True,
Return[Select[getBlank[part]/.diracSub[ALL],#=!=0&,1][[1]]];,
Return[getBlank[part]];
];
];

getParticleNameDirac[part_]:=
If[MemberQ[weylFermions[SA`CurrentStates],getBlank[part]]==True,
Return[(getBlank[part]/.diracSubBack1[SA`CurrentStates] /. diracSubBack2[SA`CurrentStates])];,
If[MemberQ[weylFermions[ALL],getBlank[part]]==True,
Return[(getBlank[part]/.diracSubBack1[ALL] /. diracSubBack2[ALL])];,
Return[getBlank[part]];
];
];




getFull[part_]:=getFull[part,SA`CurrentStates];
getFullOld[part_]:=getFull[part,ALL];
getFullSF[part_]:=SFields[[Position[SFields,getBlankSF[part]][[1,1]]]];

getFull[part_,states_]:=Block[{pos,particle,indizes,sub},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getFull";
SA`Doc`Info = "Returns the full form (i.e. including all indices) of a particle";
SA`Doc`Input={"part"->"Name of the particles","states"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

If[FreeQ[diracFermions[ALL],getBlank[part]],sub={};,sub=Join[diracSubBack1[ALL],diracSubBack2[ALL]]];
If[FreeQ[diracFermions[states],getBlank[part]]==False,sub=Join[diracSubBack1[states],diracSubBack2[states]]];
If[FreeQ[Particles[states],getParticleName[part]],SA`Doc`Return[part]];
pos = Drop[DeleteCases[Position[Particles[states],getParticleName[part],3,1][[1]],0],-1];
particle=Extract[Particles[states],pos][[1]];
indizes = Extract[Particles[states],pos][[5]];
If[indizes=!={},indizes=Transpose[indizes][[1]]];
If[indizes != {},particle=particle[indizes]];
If[(Head[part]===conj)||(Head[part]===bar),
If[(Head[part]===conj),
SA`Doc`Return[conj[particle/.sub]];,
SA`Doc`Return[bar[particle/.sub]];
];,
SA`Doc`Return[particle/.sub];
];
];

getFull2[part_]:=getFull2[part,SA`CurrentStates];
getFull2[part_,states_]:=Block[{pos,particle,indizes,sub,head},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getFull2";
SA`Doc`Info = "Returns the full form (i.e. including all indices) of a particle. This versio includes also superfields.";
SA`Doc`Input={"part"->"Name of the particles","states"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

If[(Head[part]===conj)||(Head[part]===bar),head=Head[part];,head=Evaluate;];
If[FreeQ[SFields,getBlankSF[part]]==False,SA`Doc`Return[head[SFields[[Position[SFields,getBlankSF[part]][[1,1]]]]]]];
If[FreeQ[FFields,getBlankSF[part]]==False,SA`Doc`Return[head[FFields[[Position[FFields,getBlankSF[part]][[1,1]]]]]]];

If[FreeQ[diracFermions[ALL],getBlank[part]],sub={};,sub=Join[diracSubBack1[states],diracSubBack2[states]]];
If[FreeQ[Particles[states],getParticleName[part]],SA`Doc`Return[part]];
pos = Drop[DeleteCases[Position[Particles[states],getParticleName[part],3,1][[1]],0],-1];
particle=Extract[Particles[states],pos][[1]];
indizes = Extract[Particles[states],pos][[5]];
indizes=Flatten[DeleteCases[{indizes},x_Integer] /. {a_,b_Integer}->a];
If[indizes != {},particle=particle[indizes]];
If[(Head[part]===conj)||(Head[part]===bar),
If[(Head[part]===conj),
SA`Doc`Return[conj[particle/.sub]];,
SA`Doc`Return[bar[particle/.sub]];
];,
SA`Doc`Return[particle/.sub];
];
];


(* ::Input::Initialization:: *)
getIndizes[part_]:= Block[{list},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getIndizes";
SA`Doc`Info = "Returns the indices of particles";
SA`Doc`Input={"part"->"Name of the particles"};
SA`Doc`GenerateEntry[];

If[FreeQ[Particles[Current],getParticleName[part]],
(* Print["error get Indizes", part]; *)
SA`Doc`Return[{n}];,
list=Extract[Particles[Current],Position[Particles[Current],getParticleName[part]][[1,1]]][[5]];
];
If[list==={},SA`Doc`Return[list];,SA`Doc`Return[Transpose[list][[1]]];];
];

getIndizesWI[part_]:=Block[{list},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getIndizesWI";
SA`Doc`Info = "Returns the indices and the index ranges of particles";
SA`Doc`Input={"part"->"Name of the particles"};
SA`Doc`GenerateEntry[];

If[FreeQ[Particles[Current],getParticleName[part]],
(* Print["error getIndizesWI",part]; *)
SA`Doc`Return[{n}];,
SA`Doc`Return[Extract[Particles[Current],Position[Particles[Current],getParticleName[part]][[1,1]]][[5]]];
];
];


getIndizesOld[part_]:= Block[{list},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getIndizesOld";
SA`Doc`Info = "Returns the indices of particles which is not part of the current eigenstates";
SA`Doc`Input={"part"->"Name of the particles"};
SA`Doc`GenerateEntry[];

If[FreeQ[Particles[ALL],getParticleName[part]],
(* Print["error getIndizesOld",part]; *)
SA`Doc`Return[{n}];,
list=Extract[Particles[ALL],Position[Particles[ALL],getParticleName[part]][[1,1]]][[5]]
];
If[list==={},SA`Doc`Return[list];,SA`Doc`Return[Transpose[list][[1]]];];
];

getIndizesOldWI[part_]:= Block[{list},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getIndizesOldWI";
SA`Doc`Info = "Returns the indices and index ranges of particles which is not part of the current eigenstates";
SA`Doc`Input={"part"->"Name of the particles"};

SA`Doc`GenerateEntry[];

If[FreeQ[Particles[ALL],getParticleName[part]],
(* Print["error getIndizesOldWI",part]; *)
SA`Doc`Return[{n}];,
SA`Doc`Return[Extract[Particles[ALL],Position[Particles[ALL],getParticleName[part]][[1,1]]][[5]]];
];
];


getDescriptionField[y_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getDescriptionField";
SA`Doc`Info = "Returns the description from particles.m of a given particle";
SA`Doc`Input={"y"->"Name of the particles"};
SA`Doc`GenerateEntry[];

temp=getEntryField[y,Description];
If[Head[temp]===String,
SA`Doc`Return[temp];,
SA`Doc`Return[ToString[y]];
];
];

getEntryFieldAux[y_,Type_]:=Block[{pos,field,i,states,des},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getEntryFieldAux";
SA`Doc`Info = "Returns an information from particles.m of an auxiliary particle";
SA`Doc`Input={"y"->"Name of the particles","Type"->"Type of information"};
SA`Doc`GenerateEntry[];

field=y;
If[FreeQ[WeylFermionAndIndermediate,field]==False,
pos=Position[Transpose[WeylFermionAndIndermediate][[1]],field];
];
If[Head[pos]===List,If[FreeQ[WeylFermionAndIndermediate[[pos[[1,1]]]][[2]],Type],
SA`Doc`Return[None];,
SA`Doc`Return[Type/. WeylFermionAndIndermediate[[pos[[1,1]]]][[2]]];
];,
SA`Doc`Return[None];]
;]


getElectricCharge[x_conj]:=-getElectricCharge[RE[x]];
getElectricCharge[x_bar]:=-getElectricCharge[RE[x]];
getElectricCharge[x_]:=getEntryField[x,ElectricCharge] /; (getType[x]=!=A);

getDescriptionParameter[y_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getDescriptionParameter";
SA`Doc`Info = "Returns the description from parameters.m of a given parameter";
SA`Doc`Input={"y"->"Name of the parameters"};
SA`Doc`GenerateEntry[];

temp=getEntryParameter[y,Description];
If[Head[temp]===String,
SA`Doc`Return[temp];,
SA`Doc`Return[ToString[y]];
];
];

getDescription[y_]:=getDescriptionParameter[y];

getDescriptionField[y_,gen_,fla___]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getDescriptionField";
SA`Doc`Info = "Returns the description of a field and adds a generation and flavour number";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index"};
SA`Doc`GenerateEntry[];

temp = getDescriptionField[y];
If[getGen[y]>1,
If[getFla[y]>1,
SA`Doc`Return[temp<>" "<>ToString[gen]<>" "<>ToString[fla]];,
SA`Doc`Return[temp<>" "<>ToString[gen]];
];,
SA`Doc`Return[temp];
];
];

getLaTeXField[y_,gen_,fla___]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getLaTeXField";
SA`Doc`Info = "Returns the LaTeX name of a field and adds a generation and flavour number";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index"};
SA`Doc`GenerateEntry[];

temp = getLaTeXField[y];
If[getGen[y]>1,
If[getFla[y]>1,
SA`Doc`Return["{"<>temp<>"}_{"<>ToString[gen]<>ToString[fla]<>"}"];,
SA`Doc`Return["{"<>temp<>"}_"<>ToString[gen]];
];,
SA`Doc`Return[temp];
];
];

getLaTeXField[y_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getLaTeXField";
SA`Doc`Info = "Returns the LaTeX of a field";
SA`Doc`Input={"y"->"The considered field"};
SA`Doc`GenerateEntry[];

temp=getEntryField[RE[y],LaTeX];
If[Head[temp]===List,
If[Head[y]===bar || Head[y]===conj,
SA`Doc`Return[temp[[2]]];,
SA`Doc`Return[temp[[1]]];
];,
If[Head[temp]===String,
If[Head[y]===bar,
SA`Doc`Return["\\bar{"<>temp<>"}"];,
If[Head[y]===conj,
SA`Doc`Return[temp<>"^*"];,
SA`Doc`Return[temp];
];
];,
If[Head[y]===bar,
SA`Doc`Return["\\bar{"<>ToString[y]<>"}"];,
If[Head[y]===conj,
SA`Doc`Return[ToString[y]<>"^*"];,
SA`Doc`Return[ToString[y]];
];
];
];
];
];

getLaTeXParameter[y_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getLaTeXParameter";
SA`Doc`Info = "Returns the LaTeX of a parameter";
SA`Doc`Input={"y"->"The considered parameter"};
SA`Doc`GenerateEntry[];

temp=getEntryParameter[y,LaTeX];
If[Head[temp]===String,
SA`Doc`Return[temp];,
SA`Doc`Return[ToString[y]];
];
];

getOutputNameAnti[y_,gen_,fla___]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getOutputNameAnti";
SA`Doc`Info = "Returns the output name of an anti-field and adds a generation and flavour number";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index"};
SA`Doc`GenerateEntry[];

temp = getOutputName[y,gen,fla];
If[AntiField[y]===y,
SA`Doc`Return[ToExpression[temp]];,
If[getType[y]===F,
SA`Doc`Return[ToExpression[ToString[temp]<>"bar"]];,
(* Return[ToExpression["c"<>ToString[temp]]]; *)
SA`Doc`Return[ToExpression[ToString[temp]<>"c"]];
];
];
];

getOutputNameParameter[x_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getOutputNameParameter";
SA`Doc`Info = "Returns the output name of a parameter";
SA`Doc`Input={"x"->"The considered parameter"};
SA`Doc`GenerateEntry[];

temp=getEntryParameter[x,OutputName];
If[temp===None, SA`Doc`Return[x];, SA`Doc`Return[temp];];
];

getOutputName[y_]:=getEntryField[y,OutputName];
getOutputName[y_,gen_,fla___]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getOutputName";
SA`Doc`Info = "Returns the output name of an anti-field and adds a generation and flavour number";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index"};
SA`Doc`GenerateEntry[];

temp = getOutputName[y];
If[temp===None || temp===NONE, SA`Doc`Return[temp];];
If[gen==0,
If[Head[temp]===List,
SA`Doc`Return[ToExpression[temp[[1]]]];,
SA`Doc`Return[ToExpression[temp]];
];,
If[Head[temp]===List,
temp=temp[[1]];
];
If[getGen[y]==1,
SA`Doc`Return[ToExpression[temp]];,
If[getFla[y]>1,
SA`Doc`Return[ToExpression[temp<>ToString[gen]<>ToString[fla]]];,
SA`Doc`Return[ToExpression[temp<>ToString[gen]]];
];
];
];
];

getMass[y_,gen_]:=getMassWidth[y,gen,1,"M"];
getWidth[y_,gen_]:=getMassWidth[y,gen,1,"W"];
getMass[y_,gen_,fla_]:=getMassWidth[y,gen,fla,"M"];
getWidth[y_,gen_,fla_]:=getMassWidth[y,gen,fla,"W"];
getMassWidth[y_,gen_,fla_,letter_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getMassWidth";
SA`Doc`Info = "Returns the mass and width of a field and adds a generation and flavour number";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index","letter"->"A prefix for the particle name"};
SA`Doc`GenerateEntry[];

If[FreeQ[massless,y]==False,SA`Doc`Return[0]];
If[getMassNumerical[y,gen]===0,SA`Doc`Return[0];];
If[letter==="W" , If[getWidthNumerical[y,gen,fla]===0,SA`Doc`Return[0];];];
If[getMassNumerical[y,gen,fla]===0,SA`Doc`Return[0];];
temp = letter<>ToString[y];
If[gen==0,
SA`Doc`Return[ToExpression[temp]];,
If[getGen[y]==1,
SA`Doc`Return[ToExpression[temp]];,
If[getFla[y]>1,
SA`Doc`Return[ToExpression[temp<>ToString[gen]<>ToString[fla]]];,
SA`Doc`Return[ToExpression[temp<>ToString[gen]]];
];
];
];
];

getMassWidthOutputName[y_,gen_,fla_,letter_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getMassWidthOutputName";
SA`Doc`Info = "Returns the mass and width of a field and adds a generation and flavour number. The ouput name of the particle is used to get the names for the mass and width.";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index","letter"->"A prefix for the particle name"};
SA`Doc`GenerateEntry[];

If[FreeQ[massless,y]==False,SA`Doc`Return[0]];
If[getMassNumerical[y,gen]===0,SA`Doc`Return[0];];
If[getMassNumerical[y,gen,fla]===0,SA`Doc`Return[0];];
If[letter==="W" , If[getWidthNumerical[y,gen,fla]===0,Return[0];];];
temp = letter<>ToString[y];
outname=getOutputName[y];
If[Head[outname]===List,
temp = letter<>outname[[1]];,
temp = letter<>outname;
];
If[gen==0,
SA`Doc`Return[ToExpression[temp]];,
If[getGen[y]==1,
SA`Doc`Return[ToExpression[temp]];,
If[getFla[y]>1,
SA`Doc`Return[ToExpression[temp<>ToString[gen]<>ToString[fla]]];,
SA`Doc`Return[ToExpression[temp<>ToString[gen]]];
];
];
];
];


getPDGList[y_]:=getPDG[y,0];
getPDG[x_]:=getPDG[x,0];
getPDG[y_,gen_,fla___]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getPDG";
SA`Doc`Info = "Returns the PDG of a given particle for a fixed generation and flavour number.";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index"};
SA`Doc`GenerateEntry[];

If[UsePDGIX ===True,
temp = getEntryField[y,PDG.IX];,
temp = getEntryField[y,PDG];
];
If[gen==0,
SA`Doc`Return[temp];,
If[getGen[y]==1,
If[Head[temp]===List,
SA`Doc`Return[temp[[1]]];,
SA`Doc`Return[temp];
];,
If[getFla[y]>1,
SA`Doc`Return[temp[[1+(gen-1)*getFla[y]+(fla-1)]]];,
SA`Doc`Return[temp[[gen]]];
];
];
];
];

getEntryParameter[y_,Type_]:=Block[{pos,field,i,states,des},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getEntryParameter";
SA`Doc`Info = "Returns a specific information from parameters.m ofor a given parameter";
SA`Doc`Input={"y"->"Name of the parameter","Type"->"Type of information"};
SA`Doc`GenerateEntry[];

field = y;
If[FreeQ[Transpose[ParameterDefinitions][[1]],field]==False,
pos = Position[Transpose[ParameterDefinitions][[1]],field];
];
If[Head[pos]===List,
If[FreeQ[ParameterDefinitions[[pos[[1,1]]]][[2]],Type],
SA`Doc`Return[None];,
SA`Doc`Return[Type /. ParameterDefinitions[[pos[[1,1]]]][[2]]];
];,
SA`Doc`Return[None];
];
];

getEntryField[y_,Type_]:=Block[{pos,field,i,states,des},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getEntryField";
SA`Doc`Info = "Returns a specific information from particles.m ofor a given particle";
SA`Doc`Input={"y"->"Name of the particle","Type"->"Type of information"};
SA`Doc`GenerateEntry[];

field = y;
For[i=1,i<=Length[NameOfStates],
If[FreeQ[ParticleDefinitions[NameOfStates[[i]]],field]==False,
pos = Position[Transpose[ParticleDefinitions[NameOfStates[[i]]]][[1]],field];
states = NameOfStates[[i]];
];
i++;];

If[Head[pos]===List,
If[FreeQ[ParticleDefinitions[states][[pos[[1,1]]]][[2]],Type],
SA`Doc`Return[None];,
SA`Doc`Return[Type /. ParticleDefinitions[states][[pos[[1,1]]]][[2]]];
];,
SA`Doc`Return[None];
];
];

Options[getMassNumerical]={ ReturnEquation->False};
getMassNumerical[y_,gen_,fla_,opt___ ]:=getMassNumericalFunc[y,gen,fla, ReturnEquation/.{opt}/. Options[getMassNumerical]];

getMassNumericalFunc[x_,gen_,fla_,formula_]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getMassNumericalFunc";
SA`Doc`Info = "Returns a numerical value for the mass of a given particle (and fixed generation and flavour index). ";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index","formula"->"Includes given expressions"};
SA`Doc`GenerateEntry[];

If[getGen[x]==1,
temp = Mass[x] /. Flatten[Table[Masses[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]] /. subNum;,
If[getFla[x]>1,
temp = Mass[x[gen,fla]] /. Flatten[Table[Masses[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]]/. subNum;,
temp = Mass[x[gen]] /. Flatten[Table[Masses[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]]/. subNum;
];
];
If[NumberQ[temp],
SA`Doc`Return[temp];,
If[Head[temp]===Mass || Head[temp]===MassRead,
SA`Doc`Return[100];,
If[formula==True,
If[getGen[x]==1,
temp = Mass[x] /. Flatten[Table[Masses[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]];,
If[getFla[x]>1,
temp = Mass[x[gen,fla]] /. Flatten[Table[Masses[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]];,
temp = Mass[x[gen]] /. Flatten[Table[Masses[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]];
];
];
];
SA`Doc`Return[temp];

];
];
];

getWidthNumerical[x_,gen_,fla___]:=Block[{temp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getWidthNumerical";
SA`Doc`Info = "Returns a numerical value for the width of a given particle (and fixed generation and flavour index). ";
SA`Doc`Input={"y"->"The considered field","gen,fla"->"generation and flavour index"};
SA`Doc`GenerateEntry[];

If[getGen[x]==1,
temp = WidthUsed[x] /. Flatten[Table[Width[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]];,
If[getFla[x]>1,
temp = WidthUsed[x[gen,fla]] /. Flatten[Table[Width[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]];,
temp = WidthUsed[x[gen]] /. Flatten[Table[Width[NameOfStates[[i]]],{i,1,Length[NameOfStates]}]];
];
];
If[NumberQ[temp],
SA`Return[temp];,
If[Head[temp]===WidthUsed,
SA`Return[1];,
SA`Return[External];
];
];
];





(* ::Input::Initialization:: *)
getBlank[part_]:=RE[part] /.{x_[{a__}][b_]->x,x_[{a__}]->x, x_[b_Integer]->x}; 
getBlankSF[part_]:=RE[part] /.{x_[{a__}][{b__}]->x,x_[{a__}]->x};

ExtractInt[part_]:=(Cases[part,x_Integer] /. {}-> {1})[[1]];

getPropagatorType[x_]:=Switch[getType[x],
F,
	Return[Straight];,
S,
	Return[ScalarDash];,
V,
	Return[Sine];,
G,
	Return[GhostDash];
];

getDim[matrix_]:=If[
FreeQ[dimMatrizesAll,matrix]==False,
Return[Extract[dimMatrizesAll,Position[dimMatrizesAll,matrix][[1,1]]][[2]]];,
Return[0];
];


getRParitySF[x_]:=Block[{temp,pos,field,sign=1},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getRParitySF";
SA`Doc`Info = "Returns the global symmetry of a superfield. Note, this must no longer be the R-parity!";
SA`Doc`Input={"SF"->"The considered superfield"};
SA`Doc`GenerateEntry[];

pos=Position[Fields,x][[1,1]];
field = Fields[[pos]][[1]];
If[Head[field]===List,
field=DeleteCases[Cases[field,y_Symbol,99],conj][[1]];
(* If[FreeQ[Fields[[pos]][[1]],conj]\[Equal]False,sign=-1;];,
If[Head[field]===conj,field=field[[1]]; sign=-1;]; *)
];
field = field /. conj[y_]->y;
SA`Doc`Return[getRParity[getScalar[field],GaugeES]];
];

getRParity[name_,Eigenstates_]:=Block[{temp,pos, part,sign},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getRParity";
SA`Doc`Info = "Returns the first global charge of a given field. Note, this must no longer be the R-parity!";
SA`Doc`Input={"name"->"The considered particle","Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

(* If[FreeQ[name,conj] && FreeQ[name,bar],sign=1;,sign=-1;]; *)

If[Length[Global]>0 && FreeQ[Global,Z[2]]==False,
If[FreeQ[Global,RParity]==False,
SA`Doc`Return[SA`ChargeGlobal[name,RParity]];,
pos=Position[Global,Z[2]][[1,1]];
SA`Doc`Return[SA`ChargeGlobal[name,Global[[pos,2]]]];
];
];

If[Length[Global]>0 && FreeQ[Global,RSymmetry]==False,
If[EvenQ[SA`ChargeGlobal[name,RSymmetry]]===True,
SA`Doc`Return[1];,
SA`Doc`Return[-1];
];
];
(*
part = getBlank[getBlankSF[name]];
If[FreeQ[WeylFermionAndIndermediate,part],
temp = ParticleDefinitions[Eigenstates];,
temp =WeylFermionAndIndermediate;
];
pos = Position[temp,part];
If[pos=!={},
pos=pos[[1,1]];
Return[(RParity /. temp[[pos]][[2]])];,
Return[None];
];
*)
SA`Doc`Return[None];
];

getSecondParity[name_,Eigenstates_,sym_]:=Block[{temp,pos, part,sign},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getSecondParity";
SA`Doc`Info = "Returns the global charge of a given field under a given symmetry.";
SA`Doc`Input={"name"->"The considered particle","Eigenstates"->"The considered eigenstates","sym"->"The considered symmetry"};
SA`Doc`GenerateEntry[];

pos=Position[Global,sym][[1,1]];
SA`Doc`Return[SA`ChargeGlobal[name,Global[[pos,2]]]];
];

getDimParameter[x_]:=Extract[parameters,Position[parameters,x][[1,1]]][[3]];

getPartCode[parts_]:=Block[{i,partCode},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getPartCode";
SA`Doc`Info = "Returns an integer to uniquely identify the generic type of a vertex";
SA`Doc`Input={"parts"->"List of fields"};
SA`Doc`GenerateEntry[];

partCode=0;
For[i=1,i<=Length[parts],
Switch[getType[parts[[i]] /. Der[x_]->x],
A,partCode+=10000;,
F,partCode+=1000;,
S,partCode+=100;,
V,partCode+=10;,
G,partCode+=1;
];
i++;
];
SA`Doc`Return[partCode];
];

GetEntryDef[Field_,ES_,Entry_]:=Block[{i,pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "GetEntryDef";
SA`Doc`Info = "Returns an entry from the particle definitions for a given particle";
SA`Doc`Input={"Field"->"The considered field","ES"->"The considered eigenstates","Entry"->"The kind of information"};
SA`Doc`GenerateEntry[];

pos=Position[ParticleDefinitions[ES],getParticleNameDirac[Field]];
If[pos==={},
SA`Doc`Return[Non];,
SA`Doc`Return[Entry /. ParticleDefinitions[ES][[pos[[1,1]]]][[2]]];
];
];

B[conj[x_]]:=conj[B[x]];
T[conj[x_]]:=conj[T[x]];
L[conj[x_]]:=conj[L[x]];



AntiField[x_]:=If[FermionQ[x] || GhostQ[x],Return[bar[x]];,Return[conj[x]];] /; (FreeQ[x,FieldToInsert] && FreeQ[x,External] && FreeQ[x,Internal]);
GhostQ[x_]:=If[getType[x]===G,Return[True];,Return[False];];
FermionQ[x_]:=If[getType[x]===F,Return[True];,Return[False];];
NoFermionQ[x_]:=If[getType[x]===F,Return[False];,Return[True];];




(* ::Input::Initialization:: *)
MakeTypeListParticles[ES_]:=Block[{i,diracTemp},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "MakeTypeListParticles";
SA`Doc`Info = "Generates for given eigenstates the lists of all particles sorted by their generic type (PART[X] with X={S,V,F,G,A})";
SA`Doc`Input={"ES"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

SA`CurrentStates=ES;

PART[S]={}; PART[V]={}; PART[F]={}; PART[G]={};PART[A]={};

diracTemp=diracSub[ES];

For[i=1,i<=Length[Particles[ES]],
Switch[Particles[ES][[i,4]],
S, PART[S] = Join[PART[S],{{Particles[ES][[i,1]],Particles[ES][[i,3]], Particles[ES][[i,5]],TrueQ[Particles[ES][[i,1]]== conj[Particles[ES][[i,1]]]]}}];,
F, pos=Position[diracTemp,Particles[ES][[i,1]]];
	If[Length[pos]>0,
	PART[F]=Join[PART[F],{{Extract[diracTemp,pos[[1,1]]][[1]],Particles[ES][[i,3]], Particles[ES][[i,5]], MemberQ[MajoranaPart,Particles[ES][[i,1]]/.diracSubBack1[ES] /. diracSubBack2[ES]]}}];
	diracTemp=Delete[diracTemp,pos[[1,1]]];
	];,
V, PART[V] = Join[PART[V],{{Particles[ES][[i,1]],Particles[ES][[i,3]], Particles[ES][[i,5]],TrueQ[Particles[ES][[i,1]]== conj[Particles[ES][[i,1]]]]}}];,
G, PART[G] = Join[PART[G],{{Particles[ES][[i,1]],Particles[ES][[i,3]], Particles[ES][[i,5]],TrueQ[Particles[ES][[i,1]]== conj[Particles[ES][[i,1]]]]}}];,
A, PART[A] = Join[PART[A],{{Particles[ES][[i,1]],Particles[ES][[i,3]], Particles[ES][[i,5]],False}}];
];
i++;];

SA`Doc`EndEntry[];
];

CheckConservationGlobal[listP_]:=Block[{res,i},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CheckConservationGlobal";
SA`Doc`Info = "Checks if an interaction of a set of particles is in agreement with all global symmetries";
SA`Doc`Input={"listP"->"The considered list of particles"};
SA`Doc`GenerateEntry[];

res=CheckChargeConservationGlobal[listP,#]&/@Table[Global[[i,2]],{i,1,Length[Global]}];
If[FreeQ[res,False],SA`Doc`Return[True];,SA`Doc`Return[False];];
];

CheckChargeConservationGlobal[listP_,group_]:=Block[{i,charges,pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CheckChargeConservationGlobal";
SA`Doc`Info = "Checks if an interaction of a set of particles is in agreement with all specfic global symmetry";
SA`Doc`Input={"listP"->"The considered list of particles","group"->"The considered symmetry"};

SA`Doc`GenerateEntry[];

charges =SA`ChargeGlobal[#,group]&/@listP;
pos=Position[Global,group][[1,1]];

Switch[Head[Global[[pos,1]]],
Z,
	If[Times@@charges===1,SA`Doc`Return[True];,SA`Doc`Return[False];];,
U,
	(* If[Mod[Plus@@charges,1]===0,Return[True];,Return[False];];, *)
	If[group===RSymmetry && SA`CheckGlobalLagLevel===False,
	If[Plus@@charges===2,SA`Doc`Return[True];,SA`Doc`Return[False];];,
	If[Plus@@charges===0,SA`Doc`Return[True];,SA`Doc`Return[False];];
	];,
_,
	If[Mod[Plus@@charges,1]===0,SA`Doc`Return[True];,SA`Doc`Return[False];];
];

];


GenerateCGCsForBrokenGroups[contraction_,partListIN_,particles_,invFields_,withHead_,coup_]:=Block[{i,j,k,IndexTypes={},partList={},pos,temp,result,repsNC,group},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "GenerateCGCsForBrokenGroups";
SA`Doc`Info = "Generates the Celbsch Gordon coefficients for broken groups basaed on CGCs in the unbroken phase. Loops over all gauges and calls 'getCGCbroken' with the correc input. It further processes the output of 'getCGCbroken' and stores it in dedicated variables.";
SA`Doc`Input={"contraction"->"Contraction in the unbroken phase","partListIN"->"List of the involved particles","particles"->"The product of all particles with all indices as well as the sums over indices","invFields"->"A list of involved fields with bar and conj removed","withHead"->"A list of involved fields with bar or conj","coup"->"Name of the coupling"};
SA`Doc`GenerateEntry[];

(* Print[contraction,partListIN,particles,invFields,withHead,coup]; *)
For[i=1,i<=Length[partListIN],
If[FreeQ[ListFields,RE[partListIN[[i]]]]==False,
partList=Join[partList,{partListIN[[i]]}];,
If[FreeQ[SFields,RE[partListIN[[i]]]]==False,
pos=Position[SFields,RE[partListIN[[i]]]][[1,1]];,
If[FreeQ[FFields,RE[partListIN[[i]]]]==False,
pos=Position[FFields,RE[partListIN[[i]]]][[1,1]];,
If[FreeQ[SFields,RE[partListIN[[i]]]]==False,
pos=Position[SFields,RE[partListIN[[i]]]][[1,1]];
];
];
];
If[Head[partListIN[[i]]]===conj,
partList=Join[partList,{conj[ListFields[[pos,1]]]}];,
partList=Join[partList,{ListFields[[pos,1]]}];
];
];
i++;];
For[i=1,i<=Length[partList],
If[FreeQ[ListFields,RE[partList[[i]]]]==False,
pos=Position[ListFields,RE[partList[[i]]]][[1,1]];
IndexTypes = Join[IndexTypes,Select[Gauge,(FreeQ[ListFields[[pos]],#[[3]]]==False &&#[[2]]=!=U[1])&]];
];
If[Head[partList[[i]]]===conj,sign=Join[sign,{-1}];,sign=Join[sign,{1}];];
i++;];
IndexTypes=Intersection[Table[IndexTypes[[i,3]],{i,1,Length[IndexTypes]}]];
structure=1;


(* For[i=1,i\[LessEqual]Length[IndexTypes],
pos=Position[Gauge,IndexTypes[[i]]][[1,1]];
If[Gauge[[pos,5]]===True, *)
If[FreeQ[Select[Gauge,FreeQ[IndexTypes,#[[3]]]===False &],True]===False,
result=getCGCbroken[contraction,particles,invFields,withHead];
If[Intersection[Flatten[result]]=!={0},
SA`NonZeroEntries = Join[SA`NonZeroEntries,{{InvMat[SA`RnR], Take[Position[result,x_?((Abs[#]=!=0 && NumberQ[#])&)][[1]],{1,Length[Dimensions[result]]}]}}];,
LagInput::ZeroCoupling="The contraction of `` vanishes";
Message[LagInput::ZeroCoupling,withHead];
];
Off[Part::"pspec"];
Off[Part::"pkspec1"];
ReleaseHold[Hold[Set[LHS[a__Integer],RHS[[a]]]]/. LHS -> InvMat[SA`RnR] /. RHS -> result ];
ReleaseHold[Hold[Set[LHS,RHS]]/. LHS -> InvMatFull[SA`RnR] /. RHS -> result ];
ReleaseHold[Hold[Set[LHS[a__Integer],RHS[a]]]/. RHS -> InvMat[SA`RnR] /. LHS -> CGCBroken[withHead,coup ] ];
subCGCBroken=Join[subCGCBroken,{CGCBroken[withHead,coup ] ->InvMat[SA`RnR]}];
CheckSymmetryCGCBroken[withHead,SA`RnR];
CheckStandardCGC[SA`RnR];

On[Part::"pspec"];
On[Part::"pkspec1"];
SA`RnR++;
];
(* i++;]; *)
SA`Doc`EndEntry[];
];

CheckStandardCGC[nr_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CheckStandardCGC";
SA`Doc`Info = "Checks if a CGC is one of the very simple cases where dedicated symbols exist for.";
SA`Doc`Input={"nr"->"The number of the considered CGC"};
SA`Doc`GenerateEntry[];

Switch[InvMatFull[nr],
{{1,0},{0,1}},InvMat[nr][a__]=Delta[a];,
{{1,0,0},{0,1,0},{0,0,1}},InvMat[nr][a__]=Delta[a];,
{{0,1},{-1,0}},InvMat[nr][a__]=epsTensor[a];,
{{0,-1},{1,0}},InvMat[nr][a__]=-epsTensor[a];,
{{{{1,0},{0,1}},{{0,0},{0,0}}},{{{0,0},{0,0}},{{1,0},{0,1}}}}, InvMat[nr][a_,b_,c_,d_]=Delta[a,b]Delta[c,d];
];

SA`Doc`EndEntry[];
];

CheckSymmetryCGCBroken[fields_,nr_]:=Block[{j,pos},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "CheckSymmetryCGCBroken";
SA`Doc`Info = "Checks if a CGC is symmetric under the exchange of indices.";
SA`Doc`Input={"fields"->"The involved particles","nr"->"The number of the considered CGC"};
SA`Doc`GenerateEntry[];

reps=fields;
repsDoub=Intersection[Select[fields,(Count[fields,#]>1)&]];
If[repsDoub==={},SA`Doc`Return[];];
Switch[Length[Dimensions[InvMatFull[nr]]],
2,
	If[(Table[CGCBroken[fields][i,j],{i,1,Dimensions[InvMatFull[nr]][[1]]},{j,1,Dimensions[InvMatFull[nr]][[1]]}]==Transpose[Table[CGCBroken[fields][i,j],{i,1,Dimensions[InvMatFull[nr]][[1]]},{j,1,Dimensions[InvMatFull[nr]][[1]]}]]),
	CGCBroken[fields][a_,b_]:= CGCBroken[fields][b,a] /;(OrderedQ[{a,b}]==False);
	InvMat[nr][a_,b_]:= InvMat[nr][b,a] /;(OrderedQ[{a,b}]==False);,
If[(Table[CGCBroken[fields][i,j],{i,1,Dimensions[InvMatFull[nr]][[1]]},{j,1,Dimensions[InvMatFull[nr]][[1]]}]==-Transpose[Table[CGCBroken[fields][i,j],{i,1,Dimensions[InvMatFull[nr]][[1]]},{j,1,Dimensions[InvMatFull[nr]][[1]]}]]),
	CGCBroken[fields][a_,b_]:= -CGCBroken[fields][b,a] /;(OrderedQ[{a,b}]==False);
	InvMat[nr][a_,b_]:= -InvMat[nr][b,a] /;(OrderedQ[{a,b}]==False);
];
	];,
3,
For[j=1,j<=Length[repsDoub],
pos=Position[reps,repsDoub[[j]]];
Switch[Length[pos],
2,
Switch[pos,
{{1},{2}},
If[Length[Intersection[Flatten[Table[CGCBroken[fields][i,i,k],{i,1,Dimensions[InvMatFull[nr]][[j]]},{k,1,Dimensions[InvMatFull[nr]][[3]]}]]]]>1,
CGCBroken[fields][a_,b_,c_]:= CGCBroken[fields][b,a,c] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,b_,c_]:=InvMat[nr][b,a,c] /;(OrderedQ[{a,b}]==False);,
CGCBroken[fields][a_,b_,c_]:=- CGCBroken[fields][b,a,c] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,b_,c_]:=- InvMat[nr][b,a,c] /;(OrderedQ[{a,b}]==False);
];,
{{1},{3}},
If[Length[Intersection[Flatten[Table[CGCBroken[fields][i,k,i],{i,1,Dimensions[InvMatFull[nr]][[j]]},{k,1,Dimensions[InvMatFull[nr]][[2]]}]]]]>1,
CGCBroken[fields][a_,c_,b_]:= CGCBroken[fields][b,c,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,c_,b_]:=InvMat[nr][b,c,a] /;(OrderedQ[{a,b}]==False);,
CGCBroken[fields][a_,c_,b_]:=-CGCBroken[fields][b,c,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,c_,b_]:=-InvMat[nr][b,c,a] /;(OrderedQ[{a,b}]==False);
];,
{{2},{3}},
If[Length[Intersection[Flatten[Table[CGCBroken[fields][k,i,i],{i,1,Dimensions[InvMatFull[nr]][[j]]},{k,1,Dimensions[InvMatFull[nr]][[1]]}]]]]>1,
CGCBroken[fields][c_,a_,b_]:= CGCBroken[fields][c,b,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][c_,a_,b_]:=InvMat[nr][c,b,a] /;(OrderedQ[{a,b}]==False);,
CGCBroken[fields][c_,a_,b_]:=- CGCBroken[fields][c,b,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][c_,a_,b_]:=- InvMat[nr][c,b,a] /;(OrderedQ[{a,b}]==False);
];
];,
3,
If[Length[Intersection[Flatten[Table[CGCBroken[fields][i,i,k],{i,1,Dimensions[InvMatFull[nr]][[j]]},{k,1,Dimensions[InvMatFull[nr]][[3]]}]]]]>1,
CGCBroken[fields][c_,a_,b_]:= CGCBroken[fields][c,b,a] /;(OrderedQ[{a,b}]==False);
CGCBroken[fields][a_,c_,b_]:= CGCBroken[fields][b,c,a] /;(OrderedQ[{a,b}]==False);
CGCBroken[fields][a_,b_,c_]:= CGCBroken[fields][b,a,c] /;(OrderedQ[{a,b}]==False);
InvMat[nr][c_,a_,b_]:= InvMat[nr][c,b,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,c_,b_]:=InvMat[nr][b,c,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,b_,c_]:= InvMat[nr][b,a,c] /;(OrderedQ[{a,b}]==False);,
CGCBroken[fields][c_,a_,b_]:= -CGCBroken[fields][c,b,a] /;(OrderedQ[{a,b}]==False);
CGCBroken[fields][a_,c_,b_]:= -CGCBroken[fields][b,c,a] /;(OrderedQ[{a,b}]==False);
CGCBroken[fields][a_,b_,c_]:= -CGCBroken[fields][b,a,c] /;(OrderedQ[{a,b}]==False);
InvMat[nr][c_,a_,b_]:= -InvMat[nr][c,b,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,c_,b_]:= -InvMat[nr][b,c,a] /;(OrderedQ[{a,b}]==False);
InvMat[nr][a_,b_,c_]:= -InvMat[nr][b,a,c] /;(OrderedQ[{a,b}]==False);
];
];
j++;];
];

SA`Doc`EndEntry[];


];

getCGCbroken[contraction_,particles_,invFields_,withHead_]:=Block[{i,j,names={a,b,c,d},pos,subs={},temp,result,reps={},subInv={},nameNr,dims={},group,sub2,subC={},checkC},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getCGCbroken";
SA`Doc`Info = "Generates the Celbsch Gordon coefficients for broken groups basaed on a given contraction in the unbroken phase. For that, the following steps are performed:\n
1) it generates substitutions to map the fields in the broken and unbroken case (e.g. in the broken phase the triplet is a 2x2 matrix with entries involving (T^0,T^+,T^-), while it is a vector with entries T_i in the unbroken case. Thus, mapping between both are needed.). \n
2) The substitutions is done and the sum over the charges is performed\n
3) The entries of searched for CGC are given by the coefficients in front of the different field combinations \n
NOTE: I'm not very happy with this version/approach and it might be useful to improve this routine. It works for SU(2) but was never tested for SU(3) or higher.";
SA`Doc`Input={"contraction"->"Contraction in the unbroken phase","particles"->"The fields as given in the Lagrangian","invFields"->"A list of involved fields with bar and conj removed","withHead"->"A list of involved fields with bar or conj","coup"->"Name of the coupling"};
SA`Doc`GenerateEntry[];

(* Print[contraction, " ",particles," ",invFields," ",withHead]; *)

nameNr=1;
sub2={};
For[j=1,j<=Length[invFields],
i=1;
If[FreeQ[FFields,invFields[[j]]],
pos=Position[SFields,invFields[[j]]][[1,1]];
If[Head[SFieldsMultiplets[[pos]] ]===List,
checkC=Intersection[Select[Flatten[SFieldsMultiplets[[pos]] ]/. x_?NumericQ->1,(FreeQ[Flatten[SFieldsMultiplets[[pos]] ],#]==False&& Head[#]=!=conj &&FreeQ[Flatten[SFieldsMultiplets[[pos]] ],conj[#]]==False && FreeQ[realVar,#])&]/. conj[x_]->x];
If[ checkC=!={},
subC=Join[subC,{conj[checkC[[1]][d_]]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"][d]-I ToExpression[ToString[checkC[[1]]]<>"I"][d]),checkC[[1]][d_]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"][d]+I ToExpression[ToString[checkC[[1]]]<>"I"][d])}];
subC=Join[subC,{conj[checkC[[1]]]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"]-I ToExpression[ToString[checkC[[1]]]<>"I"]),checkC[[1]]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"]+I ToExpression[ToString[checkC[[1]]]<>"I"])}];
];
subs=Join[subs,{Replace[DeleteDuplicates[Cases[Flatten[SFieldsMultiplets[[pos]] /.subC/.Plus->List] (*/. conj[x_]\[RuleDelayed]ToExpression[ToString[x]<>"c"]*)/.conj[x_]->x/. x_?NumericQ->1,x_Symbol]], x_Symbol:>(x[names[[nameNr]]]->names[[nameNr]][i++]),2]}];
subInv=Join[subInv,{conj[invFields[[j]][{b__}][{genf[j],d___}]]->conj[invFields[[j]][{b}][{genf[j],d}][names[[nameNr]]]],conj[invFields[[j]][{genf[j],d___}]]->conj[invFields[[j]][{genf[j],d}][names[[nameNr]]]],conj[invFields[[j]][{b__}][{genf[j],d___}][c_Integer]]->conj[invFields[[j]][{b}][{genf[j],d}][c][names[[nameNr]]]],conj[invFields[[j]][{genf[j],d___}][c_Integer]]->conj[invFields[[j]][{genf[j],d}][c][names[[nameNr]]]]}];
subInv=Join[subInv,{invFields[[j]][{b__}][{genf[j],d___}]->invFields[[j]][{b}][{genf[j],d}][names[[nameNr]]],invFields[[j]][{genf[j],d___}]->invFields[[j]][{genf[j],d}][names[[nameNr]]],invFields[[j]][{b__}][{genf[j],d___}][c_Integer]->invFields[[j]][{b}][{genf[j],d}][c][names[[nameNr]]],invFields[[j]][{genf[j],d___}][c_Integer]->invFields[[j]][{genf[j],d}][c][names[[nameNr]]]}];
dims=Join[dims,{i-1}];
nameNr++;,
subInv=Join[subInv,{invFields[[j]][{b__}][{genf[j],d___}]->1,invFields[[j]][{genf[j],d___}]->1,invFields[[j]][{b__}][{genf[j],d___}][c_Integer]->1,invFields[[j]][{genf[j],d___}][c_Integer]->1}];
];,
pos=Position[FFields,invFields[[j]]][[1,1]];
If[Head[FFieldsMultiplets[[pos]] ]===List,
subs=Join[subs,{Replace[DeleteDuplicates[Cases[Flatten[FFieldsMultiplets[[pos]] ] (*/. conj[x_]\[RuleDelayed]ToExpression[ToString[x]<>"c"]*)/.conj[x_]->x/. x_?NumericQ->1,x_Symbol]], x_Symbol:>(x[names[[nameNr]]]->names[[nameNr]][i++]),2]}];
subInv=Join[subInv,{invFields[[j]][{b__}][{genf[j],d___}]->invFields[[j]][{b}][{genf[j],d}][names[[nameNr]]],invFields[[j]][{genf[j],d___}]->invFields[[j]][{genf[j],d}][names[[nameNr]]],invFields[[j]][{b__}][{genf[j],d___}][c_Integer]->invFields[[j]][{b}][{genf[j],d}][c][names[[nameNr]]],invFields[[j]][{genf[j],d___}][c_Integer]->invFields[[j]][{genf[j],d}][c][names[[nameNr]]]}];
dims=Join[dims,{i-1}];
nameNr++;,
subInv=Join[subInv,{invFields[[j]][{b__}][{genf[j],d___}]->1,invFields[[j]][{genf[j],d___}]->1,invFields[[j]][{b__}][{genf[j],d___}][c_Integer]->1,invFields[[j]][{genf[j],d___}][c_Integer]->1}];
];
];
j++;];
subInv=Flatten[subInv];

temp=SumOverExpandedIndizes[contraction*particles /. sum[a__]->1 /.A_[{b__}][c_Integer]->A[{b}] /.A_[{b__}][{d__}][c_Integer]->A[{b}][{d}]    /. subInv  ,invFields] /. A_[{b__}][c_Integer]->A/. A_[{b__}]->A (*/.conj[x_]\[Rule]x*) /.(a_?NumericQ b_Symbol)[c_Symbol]->a b[c] /.(a_?NumericQ conj[b_Symbol])[c_Symbol]->a conj[b[c]] /.subC/.conj[x_]->x ;
temp = temp /. conj[x_[y_]]:>ToExpression[ToString[x]<>"c"][y] //. Flatten[subs] /. Delta[a__]->1 /. epsTensor[a__]->1 /.Lam[__]->1 /. CG[a__][b__]->1 (*/. conj[x_]\[Rule]x*);
temp=temp/.sub2;

Switch[Length[dims],
2,
result=Table[Coefficient[temp,a[i]b[j]],{i,1,dims[[1]]},{j,1,dims[[2]]}];,
3,
result=Table[Coefficient[temp,a[i]b[j]c[k]],{i,1,dims[[1]]},{j,1,dims[[2]]},{k,1,dims[[3]]}];,
4,
result=Table[Coefficient[temp,a[i]b[j]c[k] d[l]],{i,1,dims[[1]]},{j,1,dims[[2]]},{k,1,dims[[3]]},{l,1,dims[[4]]}];
];
(* Print["particles",result]; *)
SA`Doc`Return[result];
];

getGeneratorsBroken:=Block[{i,j,k},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getGeneratorsBroken";
SA`Doc`Info = "Creates the generators for the broken gauge groups.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[Gauge],
If[Gauge[[i,5]]==True&&Gauge[[i,2]]=!=U[1],
For[j=1,j<=Length[SFields],
If[SFields[[j]]=!=0,
If[SA`DynL[getBlank[SFields[[j]]],i]=!={0},
Off[Part::"pspec"];
Off[Part::"pkspec1"];
ReleaseHold[Hold[Set[LHS[a__Integer],RHS[[a]]]]/. LHS ->GeneratorBrokenScalar[i,j]/. RHS -> getGeneratorNum[j,i,S] ];
On[Part::"pspec"];
On[Part::"pkspec1"];,
GeneratorBrokenScalar[i,j]=0;
];
];
j++;];

For[j=1,j<=Length[FFields],
If[FFields[[j]]=!=0,
If[SA`DynL[getBlank[FFields[[j]]],i]=!={0},
Off[Part::"pspec"];
Off[Part::"pkspec1"];
ReleaseHold[Hold[Set[LHS[a__Integer],RHS[[a]]]]/. LHS ->GeneratorBrokenFermion[i,j]/. RHS -> getGeneratorNum[j,i,F] ];
On[Part::"pspec"];
On[Part::"pkspec1"];,
GeneratorBrokenFermion[i,j]=0;
];
];
j++;];

];
i++;];

SA`Doc`Return[result];
];
KovariantDerivative[fieldNr_,gNr_,p1_,p2_,LorNr_]:=part[SGauge[[gNr]],LorNr] getGenerator[gNr,FieldDim[fieldNr,gNr],LorNr,p1,p2]*
(* Gauge[[gNr,4]] *) makeDelta[fieldNr,p1,p2,{Gauge[[gNr,3]]}];

getGeneratorNum[fieldNr_,gNr_,type_]:=Block[{i,j,temp,pos,checkC,result,subC={},subs={},subInv={},nameNr,names={a,b,c,d},dims={}},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "getGeneratorNum";
SA`Doc`Info = "Extracts the generator matrix for a given field and (broken) gauge group. The result is used in the RGE calculation for non-SUSY RGEs (to get tA and ThS).";
SA`Doc`Input={"fieldNr"->"The position of the considered field in the array 'Fields'","gNr"->"The position of the considered gauge in the array 'Gauge'","type"->"The generic type of the particle"};
SA`Doc`GenerateEntry[];

subC={};
subs={};
subInv={};
If[type===S,
invFields={getBlank[SFields[[fieldNr]]],getBlank[SFields[[fieldNr]]]};,
invFields={getBlank[FFields[[fieldNr]]],getBlank[FFields[[fieldNr]]]};
];
nameNr=1;
sub2={};
pos=fieldNr;
subInv={getBlank[(part[SGauge[[gNr]],3] /. sum[a__]->1)][{aa_,lor3}]->c[aa]};
For[j=1,j<=Length[invFields],
i=1;
If[type===S,
If[Head[SFieldsMultiplets[[pos]] ]===List,
checkC=Intersection[Select[Flatten[SFieldsMultiplets[[pos]] ]/. x_?NumericQ->1,(FreeQ[Flatten[SFieldsMultiplets[[pos]] ],#]==False&& Head[#]=!=conj &&FreeQ[Flatten[SFieldsMultiplets[[pos]] ],conj[#]]==False && FreeQ[realVar,#])&]/. conj[x_]->x];
If[ checkC=!={},
subC=Join[subC,{conj[checkC[[1]][d_]]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"][d]-I ToExpression[ToString[checkC[[1]]]<>"I"][d]),checkC[[1]][d_]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"][d]+I ToExpression[ToString[checkC[[1]]]<>"I"][d])}];
subC=Join[subC,{conj[checkC[[1]]]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"]-I ToExpression[ToString[checkC[[1]]]<>"I"]),checkC[[1]]->1/Sqrt[2](ToExpression[ToString[checkC[[1]]]<>"R"]+I ToExpression[ToString[checkC[[1]]]<>"I"])}];
];
subs=Join[subs,{Replace[DeleteDuplicates[Cases[Flatten[SFieldsMultiplets[[pos]] /.subC/.Plus->List] (*/. conj[x_]\[RuleDelayed]ToExpression[ToString[x]<>"c"]*)/.conj[x_]->x/. x_?NumericQ->1,x_Symbol]], x_Symbol:>(x[names[[nameNr]]]->names[[nameNr]][i++]),2]}];
subInv=Join[subInv,{conj[invFields[[j]][{x__}][{genf[j],d___}]]->conj[invFields[[j]][{x}][{genf[j],d}][names[[nameNr]]]],conj[invFields[[j]][{genf[j],d___}]]->conj[invFields[[j]][{genf[j],d}][names[[nameNr]]]],conj[invFields[[j]][{x__}][{genf[j],d___}][c_Integer]]->conj[invFields[[j]][{x}][{genf[j],d}][c][names[[nameNr]]]],conj[invFields[[j]][{genf[j],d___}][c_Integer]]->conj[invFields[[j]][{genf[j],d}][c][names[[nameNr]]]]}];
subInv=Join[subInv,{invFields[[j]][{x__}][{genf[j],d___}]->invFields[[j]][{x}][{genf[j],d}][names[[nameNr]]],invFields[[j]][{genf[j],d___}]->invFields[[j]][{genf[j],d}][names[[nameNr]]],invFields[[j]][{x__}][{genf[j],d___}][c_Integer]->invFields[[j]][{x}][{genf[j],d}][c][names[[nameNr]]],invFields[[j]][{genf[j],d___}][c_Integer]->invFields[[j]][{genf[j],d}][c][names[[nameNr]]]}];
dims=Join[dims,{i-1}];
nameNr++;,
subInv=Join[subInv,{invFields[[j]][{x__}][{genf[j],d___}]->1,invFields[[j]][{genf[j],d___}]->1,invFields[[j]][{x__}][{genf[j],d___}][c_Integer]->1,invFields[[j]][{genf[j],d___}][c_Integer]->1}];
];,
pos=Position[FFields,invFields[[j]]][[1,1]];
If[Head[FFieldsMultiplets[[pos]] ]===List,
subs=Join[subs,{Replace[DeleteDuplicates[Cases[Flatten[FFieldsMultiplets[[pos]] ] (*/. conj[x_]\[RuleDelayed]ToExpression[ToString[x]<>"c"]*)/.conj[x_]->x/. x_?NumericQ->1,x_Symbol]], x_Symbol:>(x[names[[nameNr]]]->names[[nameNr]][i++]),2]}];
subInv=Join[subInv,{invFields[[j]][{x__}][{genf[j],d___}]->invFields[[j]][{x}][{genf[j],d}][names[[nameNr]]],invFields[[j]][{genf[j],d___}]->invFields[[j]][{genf[j],d}][names[[nameNr]]],invFields[[j]][{x__}][{genf[j],d___}][c_Integer]->invFields[[j]][{x}][{genf[j],d}][c][names[[nameNr]]],invFields[[j]][{genf[j],d___}][c_Integer]->invFields[[j]][{genf[j],d}][c][names[[nameNr]]]}];
dims=Join[dims,{i-1}];
nameNr++;,
subInv=Join[subInv,{invFields[[j]][{b__}][{genf[j],d___}]->1,invFields[[j]][{genf[j],d___}]->1,invFields[[j]][{b__}][{genf[j],d___}][c_Integer]->1,invFields[[j]][{genf[j],d___}][c_Integer]->1}];
];
];
j++;];
dims=Join[dims,{Gauge[[gNr,2,1]]^2-1}];
If[type===S,
tempKD=(conj[part[SFields[[fieldNr]],1]]  KovariantDerivative[fieldNr,gNr,1,2,3]part[SFields[[fieldNr]],2]);,
tempKD=(conj[part[FFields[[fieldNr]],1]]  KovariantDerivative[fieldNr,gNr,1,2,3]part[FFields[[fieldNr]],2]);
];

temp=SumOverExpandedIndizes[tempKD/. sum[a__]->1 /.A_[{b__}][c_Integer]->A[{b}] /.A_[{b__}][{d__}][c_Integer]->A[{b}][{d}]    /. subInv  ,invFields] /. A_[{b__}][c_Integer]->A/. A_[{b__}]->A (*/.conj[x_]\[Rule]x*) /.(a_?NumericQ b_Symbol)[c_Symbol]->a b[c] /.(a_?NumericQ conj[b_Symbol])[c_Symbol]->a conj[b[c]] /.subC/.conj[x_]->x /.Flatten[subs];
temp=Sum[temp,{gen3,1,dims[[3]]}]/.Delta[__]->1;


result=Table[Coefficient[temp,a[i]b[j]c[k]],{k,1,dims[[3]]},{i,1,dims[[1]]},{j,1,dims[[2]]}];
SA`Doc`Return[result];

];

GetNormalizationFactors[invFields_]:=Block[{i,j,pos,IndexTypes={},partList={},subs,nameNr,factors=1,names={a,b,c,d}},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "GetNormalizationFactors";
SA`Doc`Info = "Calculates the normalization of field. (NO LONGER USED AS FAR AS I CAN SEE!)";
SA`Doc`Input={"invFields"->"List of involved fields"};
SA`Doc`GenerateEntry[];

For[j=1,j<=Length[invFields],
If[FreeQ[FFields,invFields[[j]]],
pos=Position[SFields,invFields[[j]]][[1,1]];
If[Head[SFieldsMultiplets[[pos]]]===List,
factors=factors*NM[SFieldsMultiplets[[pos]] /.Replace[DeleteDuplicates[Cases[Flatten[SFieldsMultiplets[[pos]] ] /. x_?NumericQ->1,x_Symbol]], x_Symbol:>(x->1),2]]@@(SFields[[pos]][[0,1]] /. subGC[j]);
];,
pos=Position[FFields,invFields[[j]]][[1,1]];
If[Head[FFieldsMultiplets[[pos]]]===List,
factors=factors*NM[FFieldsMultiplets[[pos]] /.Replace[DeleteDuplicates[Cases[Flatten[FFieldsMultiplets[[pos]] ] /. x_?NumericQ->1,x_Symbol]], x_Symbol:>(x->1),2]]@@(FFields[[pos]][[0,1]] /. subGC[j]);
];
];
j++;];
SA`Doc`Return[factors];
];
NM[a_][b__Integer]:=a[[b]];
NM[{1,1}][b__]=1;
NM[{1,1,1}][b__]=1;


SetGroupConstants[field_,group_,casimir_,dynkin_,generator_,mul_,dim_,dynL_,addInd_,addInd2_]:=Block[{},
SA`Doc`File = "Package/mathParticleProp.nb";
SA`Doc`Name = "SetGroupConstants";
SA`Doc`Info = "Wrapper function to set all the groups constants for a given particle.";
SA`Doc`Input={"field"->"The considered particles","group...dynL"->"All the properties","addInd"->"Adding the possibility that the field in the function definitions can carry indices"};
SA`Doc`GenerateEntry[];

SA`Casimir[field,group]=casimir;
SA`Dynkin[field,group]=dynkin;
Generator[field,group]=generator;
SA`MulFactor[field,group]=mul;
SA`DimensionGG[field,group]=dim;
SA`DynL[field,group]=dynL;
If[addInd===True,
SA`Casimir[field[a__],group]=casimir;
SA`Dynkin[field[a__],group]=dynkin;
];
If[addInd2===True,
SA`Casimir[field[a__][b__],group]=casimir;
SA`Dynkin[field[a__][b__],group]=dynkin;
];

SA`Doc`EndEntry[];
];






