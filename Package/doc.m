(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* Documentation System *)


(* starts the documentation system *)
SA`Doc`Start[opt___]:=Block[{},
SA`Doc`AllRoutines={};
SA`Doc`Index=1;
SA`Doc`Flow[SA`Doc`Index]={};

SA`Doc`GenerateEntry[opt2___] :=Block[{},
If[FreeQ[SA`Doc`AllRoutines,SA`Doc`Name],
SA`Doc`AllRoutines = Join[SA`Doc`AllRoutines,{{SA`Doc`Name,SA`Doc`File,SA`Doc`Info,SA`Doc`Input}}];
];

SA`Doc`Flow[SA`Doc`Index]=Join[SA`Doc`Flow[SA`Doc`Index],{{FunctionName->SA`Doc`Name,Calls->{}}}];
SA`Doc`Index++; 
SA`Doc`Flow[SA`Doc`Index]={};
];

SA`Doc`EndEntry[opt2___] :=Block[{last},
last=SA`Doc`Flow[SA`Doc`Index-1][[-1]] /. ((Calls->{A___}) :>(Calls->Join[A,SA`Doc`Flow[SA`Doc`Index]]));
SA`Doc`Flow[SA`Doc`Index-1]=Join[SA`Doc`Flow[SA`Doc`Index-1][[1;;-2]],{last}];
SA`Doc`Index--;
];


];

(* Prints the flow on the screen *)
(*
SA`Doc`ShowFlow[opt___]:=Block[{ii},
For[ii=1,ii\[LessEqual]Length[SA`Doc`Flow[1]],
SA`Doc`Print`skip=0;
SA`Doc`PrintEntry[SA`Doc`Flow[1][[ii]]//. (Calls\[Rule]A_ )\[RuleDelayed](Calls\[Rule]DeleteDuplicates[A]),FlowDepth/.{opt}/.{FlowDepth\[Rule]99}];
ii++;
];
];


SA`Doc`PrintEntry[entry_,depth_]:=Block[{i,calls,details,detailBox,options},
SA`Doc`Print`skip++;
skipping = "";
For[i=1,i\[LessEqual]SA`Doc`Print`skip,
skipping = skipping<>"      ";
i++;];

details = Select[SA`Doc`AllRoutines,#[[1]] \[Equal] (FunctionName /.entry)&][[1]];
options="";
If[Length[details[[4]]]>0,
options="Input:";
];
For[i=1,i\[LessEqual]Length[details[[4]]],
options=options<>"\n   "<>details[[4,i,1]]<>": "<>details[[4,i,2]];
i++;];
detailBox = Framed[Column[{Style[details[[1]]<>": "<>details[[2]], Bold],details[[3]],options}]];
 If[SA`Doc`Print`skip\[LessEqual]depth, 
Print[skipping,"\[RightArrow]  ",Mouseover[FunctionName /.entry,detailBox]];
 ]; 
calls = DeleteDuplicates[(Calls /.entry)];
For[i=1,i\[LessEqual]Length[calls],
SA`Doc`PrintEntry[calls[[i]],depth];
i++;];
SA`Doc`Print`skip--;
];
*)

SA`Doc`ShowFlow[opt___]:=Block[{ii},
For[ii=1,ii<=Length[SA`Doc`Flow[1]],
Print[SA`Doc`Flow[1][[ii]]//. (Calls->A_ ):>(Calls->DeleteDuplicates[A])//. (Calls->A_ ):>(Calls->DeleteDuplicates[A]) //. (Calls->A_):>Column[DeleteDuplicates[A]] //.{FunctionName->B_,C_}:>OpenerView[{Mouseover[B,DescriptionBox[B]],C}] //. OpenerView[{A_,Column[{}]}]->A];
ii++;
];
];



DescriptionBox[function_]:=Block[{},
details = Select[SA`Doc`AllRoutines,#[[1]] == function&][[1]];
options="";
If[Length[details[[4]]]>0,
options="Input:";
];
For[i=1,i<=Length[details[[4]]],
options=options<>"\n   "<>details[[4,i,1]]<>": "<>details[[4,i,2]];
i++;];
detailBox = Framed[Column[{Style[details[[1]]<>": "<>details[[2]], Bold],details[[3]],options}]];
Return[detailBox];
];

SA`Doc`ShowRoutines[opt___]:=Block[{},
For[i=1,i<=Length[SA`Doc`AllRoutines],
Print["Function Name: ",SA`Doc`AllRoutines[[i,1]]];
Print["Function defined in file: ",SA`Doc`AllRoutines[[i,2]]];
Print["Function description: ",SA`Doc`AllRoutines[[i,3]]];
Print["------------------------------------------------"];

i++;];
];

(* Necessary to stop the documentation of a routine which ends with a Return *)
SA`Doc`Return[x___]:=Block[{},
SA`Doc`EndEntry[];
Return[Return[x];];
];

