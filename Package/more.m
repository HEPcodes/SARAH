(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)

(* Begin["`More`"] *)

(*-----------------------------------------------*)
(* Additional Functions *)
(*-----------------------------------------------*)


(* ------------- Check Gauge Anomalies ----------*)


CheckAnomalies :=Block[{i,j,gaugeNr,gaugeNr2,gauges},


SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CheckAnomalies";
SA`Doc`Info = "Checks for gauge anomlies, gaugexgravity anomaly and  witten anomaly.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

gauges=DeleteCases[DeleteCases[Head/@Table[Gauge[[i,2]],{i,1,Length[Gauge]}],U],SU];

(*
If[gauges=!={},
Anomalies::NoSUN="Calculation of gauge anomalies works so far only for SU(N) groups";
Message[Anomalies::NoSUN];
Return[];
];
*)

PrintDebug["Checking Anomalies"];
Print["Checking for anomalies: ",Dynamic[DynamicCheckAnomalies]];

GenerateQuadraticAndCubicDynkins;
GetMultiplicites;



(* three times same couplings *)

If[SupersymmetricModel=!=False,
FieldsToCheck=Fields;,
FieldsToCheck=FermionFields;
];
DynamicCheckAnomalies={};
DynamicCheckAnomaliesChecked="Checked: ";
For[gaugeNr=1,gaugeNr<=Length[Gauge],
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"("<>ToString[Gauge[[gaugeNr,3]]] <>")^3"}];
If[Head[Gauge[[gaugeNr,2]]]===SU || Head[Gauge[[gaugeNr,2]]]===U ,
sumAno=Sum[SA`Dynkin3[FieldsToCheck[[j,gaugeNr+3]],Gauge[[gaugeNr,2,1]]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr,3]]],{j,1,Length[FieldsToCheck]}];,
sumAno=0;
];
If[Simplify[sumAno]===0, 
PrintDebug["     No (",Gauge[[gaugeNr,3]] ,")^3 Gauge Anomaly"];,
If[Cases[sumAno,x_?SymbolQS,2]==={},
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")^3 Gauge Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")^3 Gauge Anomaly depends on choice of " <> ToString[Cases[sumAno,x_?SymbolQS,2]] <>": "<>ToString[InputForm[sumAno]] ];
];
];
If[Gauge[[gaugeNr,2]]===U[1],
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"("<>ToString[Gauge[[gaugeNr,3]]] <>")x(gravity)^2"}];
sumAno=Sum[FieldsToCheck[[j,gaugeNr+3]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr,3]]],{j,1,Length[FieldsToCheck]}];
If[Simplify[sumAno]===0,
PrintDebug["     No (",Gauge[[gaugeNr,3]] ,")x(gravity)^2 Anomaly"];,
If[Cases[sumAno,x_?SymbolQS,2]==={},
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")x(gravity)^2 Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")x(gravity)^2 Anomaly depends on choice of " <> ToString[Cases[sumAno,x_?SymbolQS,2]]<>": "<>ToString[InputForm[sumAno]] ];
];
];
 ];
gaugeNr++;];

(* two times same couplings *)

For[gaugeNr=1,gaugeNr<=Length[Gauge],
If[Gauge[[gaugeNr,2]]===U[1],
For[gaugeNr2=1,gaugeNr2<=Length[Gauge],
If[gaugeNr=!=gaugeNr2,
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"("<>ToString[Gauge[[gaugeNr2,3]]] <>")^2 x "<>ToString[Gauge[[gaugeNr,3]]]}];
sumAno=Sum[FieldsToCheck[[j,gaugeNr+3]]*SA`Dynkin2[FieldsToCheck[[j,gaugeNr2+3]],Gauge[[gaugeNr2,2,1]]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr2,3]]],{j,1,Length[FieldsToCheck]}];
If[Simplify[sumAno]===0, 
PrintDebug["     No (",Gauge[[gaugeNr2,3]] ,")^2 x ",Gauge[[gaugeNr,3]], " Gauge Anomaly"];,
If[Cases[sumAno,x_?SymbolQS,2]==={},
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")^2 x ",Gauge[[gaugeNr,3]]," Gauge Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")^2 x ",Gauge[[gaugeNr,3]]," Gauge Anomaly depends on choice of " <> ToString[Cases[sumAno,x_?SymbolQS,2]]<>": "<>ToString[InputForm[sumAno]]];
];
];

];
gaugeNr2++;];
];
gaugeNr++;];

(* three different couplings *)

For[gaugeNr=1,gaugeNr<=Length[Gauge],
For[gaugeNr2=gaugeNr+1,gaugeNr2<=Length[Gauge],
For[gaugeNr3=gaugeNr2+1,gaugeNr3<=Length[Gauge],
If[Gauge[[gaugeNr,2]]===U[1] && Gauge[[gaugeNr2,2]]===U[1]  && Gauge[[gaugeNr3,2]]===U[1],
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{ToString[Gauge[[gaugeNr2,3]]] <>" x "<>ToString[Gauge[[gaugeNr,3]]]<>" x "<>ToString[Gauge[[gaugeNr3,3]]]}];

sumAno=Sum[FieldsToCheck[[j,gaugeNr+3]]*FieldsToCheck[[j,gaugeNr2+3]]*FieldsToCheck[[j,gaugeNr3+3]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr2,3]]],{j,1,Length[FieldsToCheck]}];


If[Simplify[sumAno]===0,
If[Cases[sumAno,x_?SymbolQS,2]==={},
PrintDebug["     No (",Gauge[[gaugeNr2,3]] ,")x(",Gauge[[gaugeNr,3]] ,")x(",Gauge[[gaugeNr3,3]] ,")  Gauge Anomaly"];,
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")x(",Gauge[[gaugeNr,3]] ,")x(",Gauge[[gaugeNr3,3]] ,") Gauge Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")x(",Gauge[[gaugeNr,3]] ,")x(",Gauge[[gaugeNr3,3]] ,") Gauge Anomaly depends on choice of "<>ToString[Cases[sumAno,x_?SymbolQS,2]]<>": "<>ToString[InputForm[sumAno]]];
];
];

];
gaugeNr3++;];
gaugeNr2++;];
gaugeNr++;];



(* Witten Anomaly *)

For[gaugeNr=1,gaugeNr<=Length[Gauge],
If[Gauge[[gaugeNr,2]]===SU[2],
sumDoub=Plus@@Table[If[Abs[FieldsToCheck[[j,3+gaugeNr]]]===2,SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr,3]]],0],{j,1,Length[FieldsToCheck]}];
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"Witten Anomaly"<>ToString[Gauge[[gaugeNr,3]]]}];
If[EvenQ[sumDoub]===True, 
PrintDebug["     No Witten Anomaly (",Gauge[[gaugeNr,3]] ,")"];,
Print["     WARNING!  Odd number of doublets: Witten Anomaly (",Gauge[[gaugeNr,3]] ,")!"];
];
];
gaugeNr++;];
CheckU1mixing;

SA`Doc`EndEntry[];
];

SymbolQS[x_]:=If[Head[x]===Symbol,Return[True],Return[False]]


(* ::Input::Initialization:: *)

InitChargeFactors:=Block[{i,i1,j,k},

SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "InitChargeFactors";
SA`Doc`Info = "Initialses a charge factor of each field under Abelian gauge groups.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];



For[i1=1,i1<=Length[Gauge],
For[i=1,i<=Length[Fields],
If[Head[SFields[[i]] //.A_[{b__}]->A]===conj,sign=-1;,sign=+1;];
If[Gauge[[i1,2]]===U[1],
ChargeFactorField[i1,Fields[[i,3]]]=Fields[[i,3+i1]];
ChargeFactorField[i1,SFields[[i]] /. conj[x_]->x//.A_[{b__}]->A]=sign Fields[[i,3+i1]];
ChargeFactorField[i1,FFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=sign Fields[[i,3+i1]];,
If[FieldDim[i,i1]==1,
ChargeFactorField[i1,Fields[[i,3]]]=0;,
If[FieldDim[i,i1]>1,
nrInd=TestDim[FieldDim[i,i1],Gauge[[i1,2,1]]];
ChargeFactorField[i1,Fields[[i,3]]]=nrInd[[2]]-nrInd[[3]];
ChargeFactorField[i1,FFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=sign(nrInd[[2]]-nrInd[[3]]);
ChargeFactorField[i1,SFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=sign(nrInd[[2]]-nrInd[[3]]);,
nrInd=TestDim[-FieldDim[i,i1],Gauge[[i1,2,1]]];
ChargeFactorField[i1,Fields[[i,3]]]=-(nrInd[[2]]-nrInd[[3]]);
ChargeFactorField[i1,FFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=- sign (nrInd[[2]]-nrInd[[3]]);
ChargeFactorField[i1,SFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=-sign (nrInd[[2]]-nrInd[[3]]);
];
];
];
i++;];
i1++;];

SA`Doc`EndEntry[];
];
CheckChargeConservation:=Block[{i,j,i1,sum,violation,sign,rpv=False,violationDiscrete=False},

SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CheckChargeConservation";
SA`Doc`Info = "Checks the conservation of terms in the given superpotential with respect to gauge quantum numbers. ";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];


violation=False;
gauges=DeleteCases[DeleteCases[Head/@Table[Gauge[[i,2]],{i,1,Length[Gauge]}],U],SU];
If[gauges=!={},
ChargeConservation::NoSUN="Check of charge conservation works so far only for SU(N) groups";
Message[ChargeConservation::NoSUN];
SA`Doc`Return[];
];
PrintDebug["  checking charge conservation"];
Print["  checking charge conservation: ", Dynamic[DynamicCheckingCCSup]];

InitChargeFactors;

DynamicCheckingCCSup = "check local symmetries";
For[i=1,i<=Length[SuperPotential],
For[i1=1,i1<=Length[Gauge],
sum=0;
For[j=1,j<=Length[SuperPotential[[i,2]]],
sum +=ChargeFactorField[i1,SuperPotential[[i,2,j]]];
j++;];
If[FullSimplify[sum]=!=0,
If[Gauge[[i1,2]]===U[1],
If[Cases[sum,x_?SymbolQS,2]==={},
Message[Superpotential::ChargeViolation,Gauge[[i1,3]],SuperPotential[[i,2]]];,
Message[Superpotential::MaybeChargeViolation,Gauge[[i1,3]],SuperPotential[[i,2]],Cases[sum,x_?SymbolQS,2]];
];
violation=True;,
If[Mod[sum,Gauge[[i1,2,1]]]=!=0, 
Message[Superpotential::ChargeViolation,Gauge[[i1,3]],SuperPotential[[i,2]]];
violation=True;
];
];
];
i1++;];

DynamicCheckingCCSup = "check global symmetries";
For[i1=1,i1<=Length[Global],
If[CheckChargeConservationGlobal[SuperPotential[[i,2]],Global[[i1,2]]]==False,
violationDiscrete=True;
Message[Superpotential::ViolationGlobal,Global[[i1,2]],SuperPotential[[i,2]]];
];
i1++;];
i++;];

DynamicCheckingCCSup = "";
If[violation==False,
PrintDebug["     No violation of charge conservation in superpotential"];
DynamicCheckingCCSup="local symmetries okay. ";
];

(*
If[rpv\[Equal]False && RParityConservation\[Equal]True,
Print["     No violation of R-Parity in superpotential"];
];
*)
If[violationDiscrete==False && Length[Global]>0,
PrintDebug["     No violation of a global in superpotential"];
DynamicCheckingCCSup=DynamicCheckingCCSup<>"global symmetries okay.";
];

SA`Doc`EndEntry[];
];

CheckLagTermChargeConservation[term_]:=CheckLagTermChargeConservation[term,True];

(*
CheckLagTermChargeConservation[term_,printout_]:=Block[{i1,sum=0,j,violation},
violation=False;
For[i1=1,i1\[LessEqual]Length[Gauge],
sum=0;
For[j=1,j\[LessEqual]Length[term],
If[Head[term[[j]]]===conj ||Head[term[[j]]]===bar, 
sum -=ChargeFactorField[i1,RE[term[[j]]]];,
sum +=ChargeFactorField[i1,RE[term[[j]]]];
];
j++;];
If[FullSimplify[sum]=!=0,
If[Gauge[[i1,2]]===U[1],
If[printout\[Equal]True,
If[Cases[sum,x_?SymbolQS,2]==={},
Message[Lagrange::ChargeViolation,Gauge[[i1,3]]];,
Message[Lagrange::MaybeChargeViolation,Gauge[[i1,3]],Cases[sum,x_?SymbolQS,2]];
];
];
violation=True;,
If[Mod[sum,Gauge[[i1,2,1]]]=!=0, 
If[printout\[Equal]True,Message[Lagrange::ChargeViolation,Gauge[[i1,3]]];];
violation=True;
];
];
]; 
i1++;];
If[violation\[Equal]True,
Return[False];,
Return[True];
];
];
*)

CheckLagTermChargeConservation[term_,printout_]:=Block[{i1,sum=0,j,violation,reps},

SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CheckLagTermChargeConservation";
SA`Doc`Info = "Checks the conservation of a term defined in the model file (e.g. the potential of a non-SUSY model) with respect to gauge quantum numbers. ";
SA`Doc`Input={"term"->"The considered term","printout"->"Should error messages be printed?"};
SA`Doc`GenerateEntry[];

violation=False;
For[i1=1,i1<=Length[Gauge],
sum=0;
reps={};
For[j=1,j<=Length[term],
If[Head[term[[j]]]===conj ||Head[term[[j]]]===bar, 
reps=Join[reps,{ConjugatedRep[SA`DynL[RE[term[[j]]],Gauge[[i1,3]]],Gauge[[i1,2]]]}];
sum -=ChargeFactorField[i1,RE[term[[j]]]];,
reps=Join[reps,{SA`DynL[RE[term[[j]]],Gauge[[i1,3]]]}];
sum +=ChargeFactorField[i1,RE[term[[j]]]];
];
j++;];

If[FullSimplify[sum]=!=0,
If[Gauge[[i1,2]]===U[1],
If[printout==True,
If[Cases[sum,x_?SymbolQS,2]==={},
Message[Lagrange::ChargeViolation,Gauge[[i1,3]],term];,
Message[Lagrange::MaybeChargeViolation,Gauge[[i1,3]],Cases[sum,x_?SymbolQS,2]];
];
];
violation=True;,

If[Invariants[SusynoForm[Gauge[[i1,2]]],DeleteCases[reps/. {-1}->{1},{0}]]==={},
If[printout==True,Message[Lagrange::ChargeViolation,Gauge[[i1,3]],term];];
violation=True;
];

];
]; 
i1++;];
SA`Doc`EndEntry[];

If[violation==True,
Return[False];,
Return[True];
];
];



CreateParameterList:=Block[{temp,temp2,i,j,description,pos,initpar={}},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CreateParameterList";
SA`Doc`Info = "This creates a list with definitions for all parameters: it combines the local (model specific) parameters.m with the global parameters.m";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];


temp = ParameterDefinitions;
ParameterDefinitions={};

For[i=1,i<=Length[temp],
If[FreeQ[initpar,temp[[i,1]]],
description = Description /. temp[[i,2]];

If[description===Description || description === None || FreeQ[ParameterDefinitionsMain,description],
ParameterDefinitions =Join[ParameterDefinitions,{temp[[i]]}];,
temp2=temp[[i,2]];
pos = Position[ParameterDefinitionsMain,description][[1,1]];
For[j=1,j<=Length[ParameterDefinitionsMain[[pos,1]]],
If[FreeQ[temp2,ParameterDefinitionsMain[[pos,1,j,1]]],
temp2 = Join[temp2,{ParameterDefinitionsMain[[pos,1,j]]}];
];
j++;];
ParameterDefinitions =Join[ParameterDefinitions,{{temp[[i,1]],temp2}}];
];
initpar = Join[initpar,{temp[[i,1]]}];
];
i++;];

SA`LHList=Select[Table[{ParameterDefinitions[[i,1]],(LesHouches /.ParameterDefinitions[[i,2]])},{i,1,Length[ParameterDefinitions]}],(FreeQ[#,LesHouches])&] ;

SA`Doc`EndEntry[];
];



CreateParticlesList:=Block[{temp,temp2,tempFin,i,j,k,description,pos},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CreateParticlesList";
SA`Doc`Info = "This creates a list with definitions for all particles: it combines the local (model specific) particles.m with the global particles.m";
SA`Doc`Input = {};
SA`Doc`GenerateEntry[];

For[k=1,k<=Length[NameOfStates]+1,
If[k>Length[NameOfStates],
temp = WeylFermionAndIndermediate;,
temp = ParticleDefinitions[NameOfStates[[k]]];
];
tempFin={};

If[Head[temp]===List,
For[i=1,i<=Length[temp],
description = Description /. temp[[i,2]];

If[description===Description || description === None || FreeQ[ParticleDefinitionsMain,description],
tempFin =Join[tempFin,{temp[[i]]}];,
temp2=temp[[i,2]];
pos = Position[ParticleDefinitionsMain,description][[1,1]];
For[j=1,j<=Length[ParticleDefinitionsMain[[pos,1]]],
If[FreeQ[temp2,ParticleDefinitionsMain[[pos,1,j,1]]],
temp2 = Join[temp2,{ParticleDefinitionsMain[[pos,1,j]]}];
];
j++;];
tempFin =Join[tempFin,{{temp[[i,1]],temp2}}];
];
i++;];
If[k>Length[NameOfStates],
WeylFermionAndIndermediate = tempFin;,
ParticleDefinitions[NameOfStates[[k]]] = tempFin;
];
];
k++;];

SA`Doc`EndEntry[];
];


CheckU1mixing:=Block[{i,temp,pos,listU1,mulfac,i1,i2,pos1,pos2,sum},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CheckU1mixing";
SA`Doc`Info = "Checks if several Abelian gauge groups are present which are not orthogonal. ";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];


nonDiagonalU1=False;
mulfac=Table[{0},{Length[Fields]}];
listU1=Select[Gauge,(#[[2]]===U[1])&];
If[Length[listU1]>1,
Print["Checking U(1)'s for orthogonality"];
For[i=1,i<=Length[Fields],
states=Fields[[i,2]];
For[k=1,k<=AnzahlGauge,
If[(k=!=gaugeNr) && (Gauge[[k,2]]=!=U[1]), 
states *= Abs[FieldDim[i,k]];
];
k++;];
mulfac[[i]]=states;
i++;];

For[i1=1,i1<=Length[listU1],
pos1=Position[Gauge,listU1[[i1,1]]][[1,1]];
For[i2=i1+1,i2<=Length[listU1],
pos2=Position[Gauge,listU1[[i2,1]]][[1,1]];
sum=Sum[mulfac[[j]] Fields[[j,3+pos1]]Fields[[j,3+pos2]],{j,1,Length[Fields]}];
If[FullSimplify[sum]=!=0,
Print["   U(1)'s not orthogonality: ",Gauge[[pos1,3]]," and ",Gauge[[pos2,3]]];
nonDiagonalU1 = True;
];
i2++;];
i1++;];
];

SA`Doc`EndEntry[];
];


CheckChargeConservationInteraction[fields_]:=Block[{i,temp,cc=True,sum},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CheckChargeConservationInteraction";
SA`Doc`Info = "Checks if a specific term in the superpotential is in agreement with gauge symmertries. ";
SA`Doc`Input={"fields"->"List of involved fields"};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[Gauge],
(* If[(Head[Gauge[[i,2]]]=== SU || Head[Gauge[[i,2]]]=== U ) , *)
If[Head[Gauge[[i,2]]]=== U  ,
sum=Plus@@(ChargeFactorField[i,#]&/@fields);
If[(sum=!=0 && SU[sum] =!= Gauge[[i,2]]),cc=False;];,
If[CheckSusynoGaugeInvariant[fields,i]===False,
cc=False;
];
];
i++;];

SA`Doc`EndEntry[];
Return[cc];
];

CheckPossibleTermsSuperPotential:=Block[{i,allfieldCombis,allowed,temp={},singlets,present,notpresent},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CheckPossibleTermsSuperPotential";
SA`Doc`Info = "Checks if all terms in the superpotential are present which  are allowd by local and global symmetries. ";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

Print["Checking for additional terms in the superpotential"];
(* Print["    (Note, additional discrete symmetries are not yet considered)"]; *)
allfieldCombis=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[Fields][[3]],Transpose[Fields][[3]],Transpose[Fields][[3]]}],{1,3}]];
allowed = Intersection[Select[allfieldCombis,(CheckChargeConservationInteraction[#]==True)&]];
allowed=Select[allowed,(CheckConservationGlobal[#]==True)&];
(* singlets = Cases[allowed,{s_}];
For[i=1,i\[LessEqual]Length[singlets],
allowed = Join[allowed ,{{singlets[[i,1]],singlets[[i,1]]},{singlets[[i,1]],singlets[[i,1]],singlets[[i,1]]}}];
i++]; *)
(*
For[i=1,i\[LessEqual]Length[allowed],
If[RParityConservation\[Equal]True,
If[Times@@(getRParitySF/@allowed[[i]])===1,
temp=Join[temp,{allowed[[i]]}];
];,
temp=Join[temp,{allowed[[i]]}];
];
i++;]; *)
temp=allowed;
temp=(C@@#)&/@temp;
present=(C@@#)&/@Transpose[SuperPotential][[2]];

notpresent=Complement[temp,present];
(*
If[notpresent=!={},
If[RParityConservation\[Equal]True,
Message[PossibleTerms::NoRParity,(List@@#)&/@notpresent];,
Message[PossibleTerms::IncludeRParity,(List@@#)&/@notpresent];
];,
If[RParityConservation\[Equal]True,
Print["    All terms allowed by gauge invariance and R-parity conservation are present"];,
Print["    All terms allowed by gauge invariance are present"];
];
];
*)


If[notpresent=!={},
Message[PossibleTerms::IncludeGlobal,(List@@#)&/@notpresent];,
Print["    All terms allowed by gauge invariance and global symmetries are present"];
];

SA`Doc`EndEntry[];
];


CheckPossibleTermsPotential:=Block[{i,allfieldCombis,allowed,temp={},singlets,present,notpresent},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "CheckPossibleTermsPotential";
SA`Doc`Info = "Checks if all terms in the potential of a non-SUSY model are present which  are allowd by local and global symmetries. Note, Lorentz invariance is not checked! Needs to be improved.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

Print["Checking for additional terms in the potential"];
allfieldCombisScalars1=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]]}],{1}]];
allfieldCombisScalars2=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]]}],{2}]];
allfieldCombisScalars2=Join[allfieldCombisScalars2,Map[{conj[#[[1]]],#[[2]]}&,allfieldCombisScalars2]];
allfieldCombisScalars30=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]]}],{3}]];
allfieldCombisScalars3=allfieldCombisScalars30;
allfieldCombisScalars3=Join[allfieldCombisScalars3,Map[{conj[#[[1]]],#[[2]],#[[3]]}&,allfieldCombisScalars30]];
allfieldCombisScalars3=Join[allfieldCombisScalars3,Map[{#[[1]],conj[#[[2]]],#[[3]]}&,allfieldCombisScalars30]];
allfieldCombisScalars3=Join[allfieldCombisScalars3,Map[{#[[1]],#[[2]],conj[#[[3]]]}&,allfieldCombisScalars30]];
allfieldCombisScalars40=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]]}],{4}]];
allfieldCombisScalars4=allfieldCombisScalars40;
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],#[[2]],#[[3]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],conj[#[[2]]],#[[3]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],#[[2]],conj[#[[3]]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],#[[2]],#[[3]],conj[#[[4]]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],conj[#[[2]]],#[[3]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],#[[2]],conj[#[[3]]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],#[[2]],#[[3]],conj[#[[4]]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],conj[#[[2]]],conj[#[[3]]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],conj[#[[2]]],#[[3]],conj[#[[4]]]}&,allfieldCombisScalars40]];

allfieldCombisFermions1=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[FermionFields][[3]],Transpose[FermionFields][[3]],Transpose[FermionFields][[3]]}],{1}]];
allfieldCombisFermions2=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[FermionFields][[3]],Transpose[FermionFields][[3]],Transpose[FermionFields][[3]]}],{2}]];

allfieldCombisFermions1Scalar2={};
For[i=1,i<=Length[allfieldCombisFermions2],
For[j=1,j<=Length[allfieldCombisScalars1],
allfieldCombisFermions1Scalar2=Join[allfieldCombisFermions1Scalar2,{{allfieldCombisScalars1[[j,1]],allfieldCombisFermions2[[i,1]],allfieldCombisFermions2[[i,2]]},{conj[allfieldCombisScalars1[[j,1]]],allfieldCombisFermions2[[i,1]],allfieldCombisFermions2[[i,2]]},
{conj[allfieldCombisScalars1[[j,1]]],conj[allfieldCombisFermions2[[i,1]]],allfieldCombisFermions2[[i,2]]},
{conj[allfieldCombisScalars1[[j,1]]],allfieldCombisFermions2[[i,1]],conj[allfieldCombisFermions2[[i,2]]]}}];
j++;];
i++;];

allfieldCombisFermions2=Join[allfieldCombisFermions2,Map[{conj[#[[1]]],#[[2]]}&,allfieldCombisFermions2]];
allfieldCombisFermions2=DeleteCases[DeleteCases[allfieldCombisFermions2,{conj[x_],x_}],{x_,conj[x_]}];

allowed = Intersection[Select[allfieldCombisScalars4,(CheckLagTermChargeConservation[#,False]==True)&]];
allowed = Join[allowed,Intersection[Select[allfieldCombisScalars3,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisScalars2,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisScalars1,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisFermions1,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisFermions2,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisFermions1Scalar2,(CheckLagTermChargeConservation[#,False]==True)&]]];

allowed=Intersection[(C@@#)&/@allowed];
SA`CheckGlobalLagLevel=True;
allowed=Select[allowed,(CheckConservationGlobal[#]==True)&];
SA`CheckGlobalLagLevel=False;
present=(C@@#)&/@Join[SA`LagTermsNonSUSY,conj/@SA`LagTermsNonSUSY];

notpresent=Complement[allowed,present];
(* Print[notpresent]; *)
If[notpresent=!={},
Message[PossibleTerms::NonSUSY,(List@@#)&/@notpresent];
Print["  Please note: this function is not working perfect for non-susy models. Double checking the results is mandatory!"];,
Print["    All terms allowed by gauge invariance are present"];
];

SA`Doc`EndEntry[];
];


WriteTemplatesParFiles:=Block[{i,j,eig},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "WriteTemplatesParFiles";
SA`Doc`Info = "Generates template files for parameters.m and particles.m. This is helpful if a new model is written and one wants to see what needs to be changed in particles.m and parameters.m. Moreover, it already makes some proposals for the new entries.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];


Print[StyleForm["Generate templates for parameters.m and particles.m for this model","Subsection"]];
missingPar=Select[Transpose[parameters][[1]],FreeQ[Transpose[DeleteCases[ParameterDefinitions,{a_,{Symmetry->b_}}]][[1]],#]&];
existingPar=Complement[Transpose[parameters][[1]],missingPar];
allMiscEntry={1};

(* Parameters *)

outParFile=OpenWrite[ToFileName[$sarahCurrentModelDir,"parameters.m.Template"]];
Print["Writing template for parameters.m to ", ToFileName[$sarahCurrentModelDir,"parameters.m.Template"]];
WriteString[outParFile,"(* SARAH generated template for parameters.m file for "<>ModelName<>"*)\n"];
Minutes=If[Date[][[5]]<10,"0"<>ToString[Date[][[5]]],ToString[Date[][[5]]]];
WriteString[outParFile, "(* File created at "<>ToString[Date[][[4]]]<>":"<>Minutes<>" on "<>ToString[Date[][[3]]]<>"."<>ToString[Date[][[2]]]<>"."<>ToString[Date[][[1]]]<>"  *) \n"];
WriteString[outParFile,"(* IMPORTANT: *)\n"];
WriteString[outParFile,"(* check/adjust in particular the lines which contain \"CHECK!\" *)\n"];
WriteString[outParFile,"(* the correct information is needed there to have correct results! *)\n\n\n"];

WriteString[outParFile,"ParameterDefinitions = { \n \n"];

WriteString[outParFile,"(* ----------- Already defined parameters in existing parameters.m ----------- *) \n\n"];
For[i=1,i<=Length[existingPar],
WriteTemplatePar[existingPar[[i]],True];
If[i<Length[existingPar] || missingPar=!={},WriteString[outParFile,", \n\n"];,WriteString[outParFile," \n"];];
i++;];

If[Length[missingPar]>0,
WriteString[outParFile,"\n\n(*  ----------- Additional parameters in the model ---------- *) \n\n"];
];


For[i=1,i<=Length[missingPar],
WriteTemplatePar[missingPar[[i]],False];
If[i<Length[missingPar] ,WriteString[outParFile,", \n\n"];,WriteString[outParFile," \n"];];
i++;];

WriteString[outParFile,"} \n"];
Close[outParFile];

(* Particles *)

outParFile=OpenWrite[ToFileName[$sarahCurrentModelDir,"particles.m.Template"]];
Print["Writing template for particles.m to ", ToFileName[$sarahCurrentModelDir,"particles.m.Template"]];
WriteString[outParFile,"(* SARAH generated template for particles.m file for "<>ModelName<>" *)\n"];
Minutes=If[Date[][[5]]<10,"0"<>ToString[Date[][[5]]],ToString[Date[][[5]]]];
WriteString[outParFile, "(* File created at "<>ToString[Date[][[4]]]<>":"<>Minutes<>" on "<>ToString[Date[][[3]]]<>"."<>ToString[Date[][[2]]]<>"."<>ToString[Date[][[1]]]<>"  *) \n\n"];
WriteString[outParFile,"(* IMPORTANT: *)\n"];
WriteString[outParFile,"(* check/adjust in particular the lines which contain \"CHECK!\" *)\n"];
WriteString[outParFile,"(* the correct information is needed there to have correct results! *)\n\n\n"];

For[j=Length[NameOfStates],j>0,
eig=NameOfStates[[j]];
ConsideredEig=eig;
WriteString[outParFile,"(* ###############            "<>ToString[eig]<>"       ################# *) \n\n"];
missingFields=Intersection[Select[Select[Transpose[Particles[eig]][[1]],(getType[#,False,eig]=!=A && getType[#,False,eig]=!=NoField)&]/. diracSubBack[eig] /. bar[x_]->x,FreeQ[Transpose[ParticleDefinitions[eig]][[1]],#]&]];
existingFields=Complement[Select[Transpose[Particles[eig]][[1]],(getType[#,False,eig]=!=A && getType[#,False,eig]=!=NoField)&]/. diracSubBack[eig] /. bar[x_]->x,missingFields];


allFANr=Select[Flatten[ParticleDefinitions[eig]],FreeQ[#,FeynArtsNr]==False&] /. ((a_->b_Integer)->b);
allPDGs=Flatten[Select[Flatten[ParticleDefinitions[eig]],FreeQ[#,PDG]==False && FreeQ[#,IX]&]  /. (a_->b_)->b];



WriteString[outParFile,"ParticleDefinitions["<>ToString[eig]<>"] = { \n \n"];

WriteString[outParFile,"(* ----------- Already defined particles in existing particles.m -------------- *) \n\n"];
For[i=1,i<=Length[existingFields],
WriteTemplateParticle[existingFields[[i]],True];
If[i<Length[existingFields] || missingFields=!={},WriteString[outParFile,", \n\n"];,WriteString[outParFile," \n"];];
i++;];

If[Length[missingFields]>0,
WriteString[outParFile,"\n\n(*  ----------- Additional particles in the model ---------- *) \n\n"];
];
For[i=1,i<=Length[missingFields],
WriteTemplateParticle[missingFields[[i]],False];
If[i<Length[missingFields] ,WriteString[outParFile,", \n\n"];,WriteString[outParFile," \n"];];
i++;];

WriteString[outParFile,"}; \n\n\n\n\n"];
j--;];

existingFields=Join[Select[Transpose[Particles[ALL]][[1]],getType[#,False,ALL]===F&],Select[Transpose[Particles[ALL]][[1]],(getType[#,False,ALL]===S && FreeQ[Flatten[Table[Transpose[Particles[NameOfStates[[i]]]][[1]],{i,1,Length[NameOfStates]}]],#])&]];missingFields=Select[existingFields,FreeQ[WeylFermionAndIndermediate,#]&];
existingFields=Select[existingFields,FreeQ[missingFields,#]&];

WriteString[outParFile,"(* ###############            Weyl Spinors and intermediate states       ################# *) \n\n"];
existingFields=Join[Select[Transpose[Particles[ALL]][[1]],getType[#,False,ALL]===F&],Select[Transpose[Particles[ALL]][[1]],(getType[#,False,ALL]===S && FreeQ[Flatten[Table[Transpose[Particles[NameOfStates[[i]]]][[1]],{i,1,Length[NameOfStates]}]],#])&]];
If[SupersymmetricModel===True,
existingFields=Join[existingFields,Flatten[{Transpose[SuperFields][[1]],Extract[#,{1}]&/@Gauge,{FFields,SGauge,FGauge,SFields}//.A_[{b__}]->A}]];,
existingFields=Join[existingFields,Flatten[{Intersection[DeleteCases[Flatten[{Transpose[FermionFields][[3]],Transpose[ScalarFields][[3]],{FFields,SGauge,SFields}//.A_[{b__}]->A}],0]]}]];
];
missingFields=Select[existingFields,FreeQ[WeylFermionAndIndermediate,#]&];
existingFields=Select[existingFields,FreeQ[missingFields,#]&];


WriteString[outParFile,"WeylFermionAndIndermediate = { \n \n"];

WriteString[outParFile,"(* ----------- Already defined particles in existing particles.m -------------- *) \n\n"];
For[i=1,i<=Length[existingFields],
WriteTemplateParticleAux[existingFields[[i]],True];
If[i<Length[existingFields] || missingFields=!={},WriteString[outParFile,", \n\n"];,WriteString[outParFile," \n"];];
i++;];

If[Length[missingFields]>0,
WriteString[outParFile,"\n\n(*  ----------- Additional particles in the model ---------- *) \n\n"];
];
For[i=1,i<=Length[missingFields],
WriteTemplateParticleAux[missingFields[[i]],False];
If[i<Length[missingFields] ,WriteString[outParFile,", \n\n"];,WriteString[outParFile," \n"];];
i++;];


WriteString[outParFile,"}; \n\n\n\n\n"];
Close[outParFile];


];

WriteTemplatePar[par_,existing_]:=Block[{entries,i,j,pos,entry},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "WriteTemplatePar";
SA`Doc`Info = "Writes the entries to the template file for parameters.m";
SA`Doc`Input={"par"->"the considered parameter","existing"->"does information about the parameter already exist or is it a new parameter?"};
SA`Doc`GenerateEntry[];

entries={Description,Dependence,DependenceNum,DependenceOptional,DependenceSPheno,Form,GUTnormalization,Real,Value,LesHouches,LaTeX,OutputName};
WriteString[outParFile,"{"<>ToString[InputForm[par]]<>",{ \n"];
For[i=1,i<=Length[entries],
If[(entries[[i]]=!=GUTnormalization ||FreeQ[Gauge,par]===False) || (entries[[i]]=!=Form ||Length[getDimPar]===2) ,
If[getAutoEntryPar[par,entries[[i]],existing]=!=False,
If[i<Length[entries],
WriteString[outParFile,"     "<>getAutoEntryPar[par,entries[[i]],existing]<>", \n"];,
WriteString[outParFile,"     "<>getAutoEntryPar[par,entries[[i]],existing]<>"}}"];
];
];
];
i++;];
];

WriteTemplateParticle[particle_,existing_]:=Block[{entries,i,j,pos,entry},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "WriteTemplatePar";
SA`Doc`Info = "Writes the entries to the template file for particles.m";
SA`Doc`Input={"par"->"the considered particle","existing"->"does information about the particle already exist or is it a new particle?"};
SA`Doc`GenerateEntry[];

entries={Description,Goldstone,FeynArtsNr,LaTeX,Mass,MassDependence,OutputName,PDG,ElectricCharge,Width};
WriteString[outParFile,"{"<>ToString[InputForm[particle]]<>",{ \n"];
For[i=1,i<=Length[entries],
If[(entries[[i]]=!=Goldstone )|| (getType[particle,False,ALL]===V && FreeQ[SGauge,particle]===True) , 
If[getAutoEntryParticle[particle,entries[[i]],existing,False]=!=False,
If[i<Length[entries],
WriteString[outParFile,"     "<>getAutoEntryParticle[particle,entries[[i]],existing,False]<>", \n"];,
WriteString[outParFile,"     "<>getAutoEntryParticle[particle,entries[[i]],existing,False]<>"}}"];
];
 ];
]; 
i++;];
SA`Doc`EndEntry[];
];

WriteTemplateParticleAux[particle_,existing_]:=Block[{entries,i,j,pos,entry},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "WriteTemplatePar";
SA`Doc`Info = "Writes the auxiliary entries (Weyl spinors, intermediate states, superfields) to the template file for particles.m";
SA`Doc`Input={"par"->"the considered particle","existing"->"does information about the particle already exist or is it a new particle?"};
SA`Doc`GenerateEntry[];

entries={Description,LaTeX};
WriteString[outParFile,"{"<>ToString[InputForm[particle]]<>",{ \n"];
For[i=1,i<=Length[entries],
If[(entries[[i]]=!=Goldstone )|| (getType[particle,False,ALL]===V && FreeQ[SGauge,particle]===True) , 
If[getAutoEntryParticle[particle,entries[[i]],existing,True]=!=False,
If[i<Length[entries],
WriteString[outParFile,"     "<>getAutoEntryParticle[particle,entries[[i]],existing,True]<>", \n"];,
WriteString[outParFile,"     "<>getAutoEntryParticle[particle,entries[[i]],existing,True]<>"}}"];
];
 ];
]; 
i++;];
SA`Doc`EndEntry[];
];

getAutoEntryPar[par_,name_,existing_]:=Block[{val},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "getAutoEntryPar";
SA`Doc`Info = "Auto generates a proposal for the definition of a new parameter";
SA`Doc`Input={"par"->"The considered parameter","name"->"Name of the entry","existing"->"Does information already exist?"};
SA`Doc`GenerateEntry[];

If[existing,
val=getEntryParameter[par,name];
If[val===None && (name===Dependence ||name===DependenceNum || name===DependenceOptional ||name===DependenceSPheno),SA`Doc`Return[ToString[name]<>" -> "<>ToString[InputForm[val]]];];,
val=None
];

If[val=!=None,
Switch[name,
LaTeX,
SA`Doc`Return[ToString[name]<>" -> \""<>StringReplace[ToString[val],"\\"->"\\\\"]<>"\""];,
Dependence|DependenceNum|DependenceOptional|DependenceSPheno,
If[getDimParameter[par]==Dimensions[val] || Head[val]=!=List,
SA`Doc`Return[ToString[name]<>" -> "<>ToString[InputForm[val]]];,
SA`Doc`Return[ToString[name]<>" -> None    (* Removed dependence with wrong dimensions *)"];
];,
_,
SA`Doc`Return[ToString[name]<>" -> "<>ToString[InputForm[val]]];
];,
Switch[name,
LaTeX,
SA`Doc`Return[ToString[name]<>" -> \""<>StringReplace[AutoNameLaTeX[par],"\\"->"\\\\"]<>"\"  (* auto generated LaTeX name *)"];,
OutputName,
SA`Doc`Return[ToString[name]<>" -> "<>AutoNameOutput[par]<>"  (* auto generated Output name *)"];,
LesHouches,
If[existing===False,
SA`Doc`Return[ToString[name]<>" -> "<>AutoLesHouches[par]<>"  (* auto generated Les Houches entry *)"];,
SA`Doc`Return[False];
];,
Real,
If[FreeQ[DEFINITION[NameOfStates[[-1]]][VEVs],par]===False,
SA`Doc`Return[ToString[name]<>" -> True (* Assuming new VEVs to be real \t\t\t\t => CHECK! *)"];,
SA`Doc`Return[ToString[name]<>" -> "<>ToString[MemberQ[realVar,par]]];
];,
_,
(* Return[ToString[name]<>" -> "<>"None"]; *)
SA`Doc`Return[False];
];
];
];

getAutoEntryParticle[par_,name_,existing_,auxF_]:=Block[{val},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "getAutoEntryParticle";
SA`Doc`Info = "Auto generates a proposal for the definition of a new particle";
SA`Doc`Input={"par"->"The considered parameter","name"->"Name of the entry","existing"->"Does information already exist?","auxF"->"Is it an auxiliary field (Weyl spinor, superfield)?"};
SA`Doc`GenerateEntry[];

If[existing,
If[auxF===True,
val=getEntryFieldAux[par,name];,
val=getEntryField[par,name];
];,
val=None
];

If[name===PDG || name===PDG.IX,
If[Length[val]=!=getGen[par,ALL],val=None;];
];

If[val=!=None,
Switch[name,
LaTeX | OutputName,
If[Length[val]===2,
SA`Doc`Return[ToString[name]<>" -> {\""<>StringReplace[ToString[val[[1]]],"\\"->"\\\\"]<>"\",\""<>StringReplace[ToString[val[[2]]],"\\"->"\\\\"]<>"\"}"];,
SA`Doc`Return[ToString[name]<>" -> \""<>StringReplace[ToString[val],"\\"->"\\\\"]<>"\""];
];,
_,
SA`Doc`Return[ToString[name]<>" -> "<>ToString[InputForm[val]]];
];,
Switch[name,
LaTeX,
SA`Doc`Return[ToString[name]<>" -> \""<>StringReplace[AutoNameLaTeX[par],"\\"->"\\\\"]<>"\"   (* auto generated LaTeX name *)"];,
PDG,
SA`Doc`Return[ToString[name]<>" -> "<>AutoPDG[par,getEntryField[par,name]/. a_Integer->{a}]<>If[existing===True,"   (* adjusted number of PDGs to number of generations  *)","   (* auto generated PDGs  *)"]];,
OutputName,
SA`Doc`Return[ToString[name]<>" -> \""<>AutoNameOutput[par]<>"\"   (* auto generated Output name *)"];,
FeynArtsNr,
SA`Doc`Return[ToString[name]<>" -> "<>AutoFeynArts[par]<>"   (* auto generated FeynArts number *)"];,
Mass,
SA`Doc`Return[ToString[name]<>" -> LesHouches"];,
Width,
SA`Doc`Return[ToString[name]<>" -> Automatic"];,
Goldstone,
If[existing==False,
SA`Doc`Return[ToString[name]<>" -> None  (* don't forget to put the correct Goldstone here!\t\t\t\t => CHECK! *)"];,
SA`Doc`Return[False];
];,
ElectricCharge,
If[(FreeQ[Particles[NameOfStates[[-1]]],par]===False ||FreeQ[diracSub[NameOfStates[[-1]]],par]===False) && ConsideredEig===NameOfStates[[-1]],
SA`Doc`Return[ToString[name]<>" -> 0 (* this is just a dummy value for the electric charge! \t\t\t\t => CHECK! *)"];,
SA`Doc`Return[False];
];,
_,
(* Return[ToString[name]<>" -> "<>"None"]; *)
SA`Doc`Return[False];
];
];
];

AutoFeynArts[x_]:=Block[{val},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "AutoFeynArts";
SA`Doc`Info = "Auto generates a proposal a FeynArts number of a new particle";
SA`Doc`Input={"x"->"the consiered field"};
SA`Doc`GenerateEntry[];

val=Max[allFANr];
allFANr=Join[allFANr,{val+1}];
SA`Doc`Return[ToString[val++]];
];
AutoPDG[x_,existing_]:=Block[{max,i,val},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "AutoFeynArts";
SA`Doc`Info = "Auto generates a proposal a PDG number of a new particle";
SA`Doc`Input={"x"->"the considered field", "existing"->"Is it an already existing field?"};
SA`Doc`GenerateEntry[];

max=Max[allPDGs];
If[getType[x]===G,SA`Doc`Return["{0}"]];
If[existing===None,
val=Table[max+i,{i,1,getGen[x,ALL]}];,
If[Length[existing]<getGen[x,ALL],
val=Join[Flatten[existing],Table[max+i,{i,1,getGen[x,ALL]-Length[existing]}]];,
val=Take[Flatten[existing],{1,getGen[x,ALL]}];
];
];
allPDGs=Join[allPDGs,val];
SA`Doc`Return[ToString[val]];
];

AutoLesHouches[x_]:=Block[{i,max},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "AutoFeynArts";
SA`Doc`Info = "Auto generates a proposal a Les Houches block of a new parameter";
SA`Doc`Input={"x"->"the consiered field"};
SA`Doc`GenerateEntry[];

If[getDimParameter[x]==={}||getDimParameter[x]==={1},
max=Max[allMiscEntry];
allMiscEntry=Join[allMiscEntry,{max+1}];
SA`Doc`Return["{"<>ToUpperCase[ModelName]<>","<>ToString[max]<>"}"];,
SA`Doc`Return[ToUpperCase[StringReplace[ToString[FullForm[x /. Mass->M]],{"["->"","]"->"","\\"->""}]]];
];
];

AutoNameOutput[x_]:=Block[{temp},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "AutoFeynArts";
SA`Doc`Info = "Auto generates a proposal an ouptut name of a new parameter";
SA`Doc`Input={"x"->"the consiered field"};
SA`Doc`GenerateEntry[];


Switch[Head[x],
T,SA`Doc`Return["T"<>AutoNameOutput[x[[1]]]<>""];,
B,SA`Doc`Return["B"<>AutoNameOutput[x[[1]]]<>""];,
L,SA`Doc`Return["L"<>AutoNameOutput[x[[1]]]<>""];,
Mass,SA`Doc`Return["M"<>AutoNameOutput[x[[1]]]<>""];
];
temp=StringReplace[ToLowerCase[ToString[FullForm[x /. Mass->M]]],{"["->"","]"->"","\\"->"","alpha"->"al","beta"->"bet","gamma"->"ga","delta"->"del","epsilon"->"ep","rho"->"rh","sigma"->"sig","lambda"->"lam","omega"->"om","kappa"->"kap","bar"->"b"}];
If[StringLength[temp]>8,temp=StringTake[temp,{1,7}];];

SA`Doc`Return[temp];
];


AutoNameLaTeX[x_]:=Block[{temp,i,basis,rest},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "AutoFeynArts";
SA`Doc`Info = "Auto generates a proposal a LaTeX name of a new parameter";
SA`Doc`Input={"x"->"the consiered field"};
SA`Doc`GenerateEntry[];

If[Head[x]=!=String,
If[FreeQ[parameters,x]===False,
Switch[Head[x],
T,SA`Doc`Return["T_{"<>AutoNameLaTeX[x[[1]]]<>"}"];,
B,SA`Doc`Return["B_{"<>AutoNameLaTeX[x[[1]]]<>"}"];,
L,SA`Doc`Return["L_{"<>AutoNameLaTeX[x[[1]]]<>"}"];,
Mass,SA`Doc`Return["M_{"<>AutoNameLaTeX[x[[1]]]<>"}"];
];,
basis=StringTake[ToString[x],{1}];
rest=StringReplace[StringTake[ToString[x],{2,-1}],{"["->"","]"->"","\\"->""}];
If[(FreeQ[SuperFields,x] && FreeQ[Extract[#,{1}]&/@Gauge,x]) || SupersymmetricModel===False,
Switch[basis,
"V",SA`Doc`Return[AutoNameLaTeX[rest]];,
"F",SA`Doc`Return[AutoNameLaTeX[rest]];,
"f",SA`Doc`Return["\\tilde{"<>AutoNameLaTeX[rest]<>"}"];,
"S",SA`Doc`Return["\\tilde{"<>AutoNameLaTeX[rest]<>"}"];,
"g",SA`Doc`Return["\\eta_{"<>AutoNameLaTeX[rest]<>"}"];,
_,SA`Doc`Return[AutoNameLaTeX[ToLowerCase[StringReplace[ToString[FullForm[x]],{"["->"","]"->"","\\"->""}]]]];
];,
SA`Doc`Return["\\hat{"<>AutoNameLaTeX[ToString[x]]<>"}"];
];
];
temp=StringReplace[ToString[FullForm[x]],{"["->"","]"->"","\\"->""}];,
temp=x;
];
If[StringLength[temp]<2,
SA`Doc`Return[temp];
];
If[StringTake[temp,{1}]==="m" && StringTake[temp,{-1}]==="2",
SA`Doc`Return["m^2_{"<>AutoNameLaTeX[StringDrop[StringDrop[temp,{1}],{-1}]]<>"}"];
];

If[StringPosition[temp,"bar"]=!={} || StringPosition[temp,"Bar"]=!={},
SA`Doc`Return["\\bar{"<>AutoNameLaTeX[StringReplace[temp,{"bar"->"","Bar"->""}]]<>"}"];
];


If[StringTake[temp,{-2,-1}]==="pp",
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,{-2,-1}]]<>"}^{++}"]
];

If[StringTake[temp,{-2,-1}]==="mm",
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,{-2,-1}]]<>"}^{--}"]
];

If[StringTake[temp,{-2,-1}]==="pm",
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,{-2,-1}]]<>"}^{\\pm}"]
];

If[StringTake[temp,{-2,-1}]==="mp",
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,{-2,-1}]]<>"}^{\\mp}"]
];

(*
If[StringTake[temp,{-1}]==="p",
Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}^{+}"]
];

If[StringTake[temp,{-1}]==="m",
Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}^{-}"]
];

If[StringTake[temp,{-1}]==="l",
Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}_{L}"]
];

If[StringTake[temp,{-1}]==="r",
Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}_{R}"]
];

If[StringTake[temp,{-1}]==="c",
Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}^{*}"]
];

*)

If[StringTake[temp,{-1}]==="0",
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}^0"]
];


If[StringTake[temp,{-1}]==="L",
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}_L"]
];

If[StringTake[temp,{-1}]==="R",
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,{-1}]]<>"}_R"]
];


Greek={"alpha","beta","gamma","delta","epsilon","mu","rho","sigma","tau","eta","lambda","xi","omega","chi","kappa","phi","nu"};
GreekSub=Greek;
Greek=Join[Greek,{"Alpha","Beta","Gamma","Delta","Epsilon","Mu","Rho","Sigma","Tau","Eta","Lambda","Xi","Omega","Chi","Kappa","Phi","Nu"}];
GreekSub=Join[GreekSub,{"alpha","beta","Gamma","Delta","epsilon","mu","rho","Sigma","tau","eta","lambda","xi","Omega","chi","kappa","Phi","nu"}];


i=1;
found=False;
While[i<=Length[Greek] && found==False,
pos=StringPosition[temp,Greek[[i]]];
If[pos=!={},
found=True,
i++;
];
];
If[found,
If[pos[[1,1]]===1 && pos[[1,2]]===StringLength[temp],
SA`Doc`Return["\\"<>GreekSub[[i]]];
];

If[pos[[1,1]]===1,
SA`Doc`Return["{\\"<>GreekSub[[i]]<>"}_{"<>AutoNameLaTeX[StringDrop[temp,pos[[1]]]]<>"}"];
];

If[pos[[1,2]]===StringLength[temp],
SA`Doc`Return["{"<>AutoNameLaTeX[StringDrop[temp,pos[[1]]]]<>"}_{\\"<>GreekSub[[i]]<>"}"];
];
SA`Doc`Return["{"<>AutoNameLaTeX[StringTake[temp,{1,pos[[1,1]]-1}]]<>"}_{\\"<>GreekSub[[i]]<>"}^{"<>AutoNameLaTeX[StringTake[temp,{pos[[1,2]]+1,-1}]]<>"}"];
];

If[StringTake[temp,{1}]==="y",
SA`Doc`Return["Y_{"<>AutoNameLaTeX[StringDrop[temp,{1}]]<>"}"]
];

If[StringTake[temp,{1}]==="g",
SA`Doc`Return["g_{"<>AutoNameLaTeX[StringDrop[temp,{1}]]<>"}"]
];

If[StringTake[temp,{1}]==="v",
SA`Doc`Return["v_{"<>AutoNameLaTeX[StringDrop[temp,{1}]]<>"}"]
];

SA`Doc`Return[temp];

];


Get2to2scattering:=Block[{AllScalars,pairs,lag,ScatterMatrix},
SA`Doc`File = "Package/more.nb";
SA`Doc`Name = "Get2to2scattering";
SA`Doc`Info = "Generates the scattering matrix for 2->2 involving external scalars in the s->infinity approximation.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

AllScalars=Transpose[Select[Particles[GaugeES],#[[4]]==S&]][[1]];
AllScalars=Join[AllScalars,conj/@AllScalars];
AllScalars=Select[AllScalars,FreeQ[getIndizes[#],color]&];
AllScalars=Select[AllScalars,FreeQ[RemoveParticlesFromScattering,#]&];

pairs=Intersection[Map[Sort[#]&,Tuples[AllScalars,{2}],{1}]];
lag=LagSSSS[GaugeES];
ScatterMatrix=Table[If[pairs[[i2,2]]===pairs[[i2,1]],1/Sqrt[2],1]If[pairs[[i1,2]]===pairs[[i1,1]],1/Sqrt[2],1]D[D[D[D[lag,pairs[[i1,1]]],pairs[[i1,2]]],pairs[[i2,1]]],pairs[[i2,2]]],{i1,1,Length[pairs]},{i2,1,Length[pairs]}]  /. Delta[a_Integer,b_Symbol]->1/. Delta[b_Integer,a_Symbol]->1;

SA`Doc`Return[ScatterMatrix];
];






(* End[] *)

