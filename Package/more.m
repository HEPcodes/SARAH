(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)




(* Begin["`More`"] *)

(*-----------------------------------------------*)
(* Additional Functions *)
(*-----------------------------------------------*)


(* ------------- Check Gauge Anomalies ----------*)


CheckAnomalies :=Block[{i,j,gaugeNr,gaugeNr2,gauges},

gauges=DeleteCases[DeleteCases[Head/@Table[Gauge[[i,2]],{i,1,Length[Gauge]}],U],SU];

(*
If[gauges=!={},
Anomalies::NoSUN="Calculation of gauge anomalies works so far only for SU(N) groups";
Message[Anomalies::NoSUN];
Return[];
];
*)

PrintDebug["Checking Anomalies"];
Print["Checking for anomalies: ",Dynamic[DynamicCheckAnomalies]];

GenerateQuadraticAndCubicDynkins;
GetMultiplicites;



(* three times same couplings *)

If[SupersymmetricModel=!=False,
FieldsToCheck=Fields;,
FieldsToCheck=FermionFields;
];
DynamicCheckAnomalies={};
DynamicCheckAnomaliesChecked="Checked: ";
For[gaugeNr=1,gaugeNr<=Length[Gauge],
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"("<>ToString[Gauge[[gaugeNr,3]]] <>")^3"}];
If[Head[Gauge[[gaugeNr,2]]]===SU || Head[Gauge[[gaugeNr,2]]]===U ,
sumAno=Sum[SA`Dynkin3[FieldsToCheck[[j,gaugeNr+3]],Gauge[[gaugeNr,2,1]]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr,3]]],{j,1,Length[FieldsToCheck]}];,
sumAno=0;
];
If[Simplify[sumAno]===0, 
PrintDebug["     No (",Gauge[[gaugeNr,3]] ,")^3 Gauge Anomaly"];,
If[Cases[sumAno,x_?SymbolQS,2]==={},
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")^3 Gauge Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")^3 Gauge Anomaly depends on choice of " <> ToString[Cases[sumAno,x_?SymbolQS,2]] <>": "<>ToString[InputForm[sumAno]] ];
];
];
If[Gauge[[gaugeNr,2]]===U[1],
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"("<>ToString[Gauge[[gaugeNr,3]]] <>")x(gravity)^2"}];
sumAno=Sum[FieldsToCheck[[j,gaugeNr+3]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr,3]]],{j,1,Length[FieldsToCheck]}];
If[Simplify[sumAno]===0,
PrintDebug["     No (",Gauge[[gaugeNr,3]] ,")x(gravity)^2 Anomaly"];,
If[Cases[sumAno,x_?SymbolQS,2]==={},
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")x(gravity)^2 Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr,3]] ,")x(gravity)^2 Anomaly depends on choice of " <> ToString[Cases[sumAno,x_?SymbolQS,2]]<>": "<>ToString[InputForm[sumAno]] ];
];
];
 ];
gaugeNr++;];

(* two times same couplings *)

For[gaugeNr=1,gaugeNr<=Length[Gauge],
If[Gauge[[gaugeNr,2]]===U[1],
For[gaugeNr2=1,gaugeNr2<=Length[Gauge],
If[gaugeNr=!=gaugeNr2,
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"("<>ToString[Gauge[[gaugeNr2,3]]] <>")^2 x "<>ToString[Gauge[[gaugeNr,3]]]}];
sumAno=Sum[FieldsToCheck[[j,gaugeNr+3]]*SA`Dynkin2[FieldsToCheck[[j,gaugeNr2+3]],Gauge[[gaugeNr2,2,1]]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr2,3]]],{j,1,Length[FieldsToCheck]}];
If[Simplify[sumAno]===0, 
PrintDebug["     No (",Gauge[[gaugeNr2,3]] ,")^2 x ",Gauge[[gaugeNr,3]], " Gauge Anomaly"];,
If[Cases[sumAno,x_?SymbolQS,2]==={},
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")^2 x ",Gauge[[gaugeNr,3]]," Gauge Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")^2 x ",Gauge[[gaugeNr,3]]," Gauge Anomaly depends on choice of " <> ToString[Cases[sumAno,x_?SymbolQS,2]]<>": "<>ToString[InputForm[sumAno]]];
];
];

];
gaugeNr2++;];
];
gaugeNr++;];

(* three different couplings *)

For[gaugeNr=1,gaugeNr<=Length[Gauge],
For[gaugeNr2=gaugeNr+1,gaugeNr2<=Length[Gauge],
For[gaugeNr3=gaugeNr2+1,gaugeNr3<=Length[Gauge],
If[Gauge[[gaugeNr,2]]===U[1] && Gauge[[gaugeNr2,2]]===U[1]  && Gauge[[gaugeNr3,2]]===U[1],
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{ToString[Gauge[[gaugeNr2,3]]] <>" x "<>ToString[Gauge[[gaugeNr,3]]]<>" x "<>ToString[Gauge[[gaugeNr3,3]]]}];

sumAno=Sum[FieldsToCheck[[j,gaugeNr+3]]*FieldsToCheck[[j,gaugeNr2+3]]*FieldsToCheck[[j,gaugeNr3+3]]*SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr2,3]]],{j,1,Length[FieldsToCheck]}];


If[Simplify[sumAno]===0,
If[Cases[sumAno,x_?SymbolQS,2]==={},
PrintDebug["     No (",Gauge[[gaugeNr2,3]] ,")x(",Gauge[[gaugeNr,3]] ,")x(",Gauge[[gaugeNr3,3]] ,")  Gauge Anomaly"];,
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")x(",Gauge[[gaugeNr,3]] ,")x(",Gauge[[gaugeNr3,3]] ,") Gauge Anomaly!"];,
Print["     WARNING!  (",Gauge[[gaugeNr2,3]] ,")x(",Gauge[[gaugeNr,3]] ,")x(",Gauge[[gaugeNr3,3]] ,") Gauge Anomaly depends on choice of "<>ToString[Cases[sumAno,x_?SymbolQS,2]]<>": "<>ToString[InputForm[sumAno]]];
];
];

];
gaugeNr3++;];
gaugeNr2++;];
gaugeNr++;];



(* Witten Anomaly *)

For[gaugeNr=1,gaugeNr<=Length[Gauge],
If[Gauge[[gaugeNr,2]]===SU[2],
sumDoub=Plus@@Table[If[Abs[FieldsToCheck[[j,3+gaugeNr]]]===2,SA`MulFactor[FieldsToCheck[[j,3]],Gauge[[gaugeNr,3]]],0],{j,1,Length[FieldsToCheck]}];
DynamicCheckAnomalies=Join[DynamicCheckAnomalies,{"Witten Anomaly"<>ToString[Gauge[[gaugeNr,3]]]}];
If[EvenQ[sumDoub]===True, 
PrintDebug["     No Witten Anomaly (",Gauge[[gaugeNr,3]] ,")"];,
Print["     WARNING!  Odd number of doublets: Witten Anomaly (",Gauge[[gaugeNr,3]] ,")!"];
];
];
gaugeNr++;];
CheckU1mixing;

];

SymbolQS[x_]:=If[Head[x]===Symbol,Return[True],Return[False]]



InitChargeFactors:=Block[{i,i1,j,k},
For[i1=1,i1<=Length[Gauge],
For[i=1,i<=Length[Fields],
If[Head[SFields[[i]] //.A_[{b__}]->A]===conj,sign=-1;,sign=+1;];
If[Gauge[[i1,2]]===U[1],
ChargeFactorField[i1,Fields[[i,3]]]=Fields[[i,3+i1]];
ChargeFactorField[i1,SFields[[i]] /. conj[x_]->x//.A_[{b__}]->A]=sign Fields[[i,3+i1]];
ChargeFactorField[i1,FFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=sign Fields[[i,3+i1]];,
If[FieldDim[i,i1]==1,
ChargeFactorField[i1,Fields[[i,3]]]=0;,
If[FieldDim[i,i1]>1,
nrInd=TestDim[FieldDim[i,i1],Gauge[[i1,2,1]]];
ChargeFactorField[i1,Fields[[i,3]]]=nrInd[[2]]-nrInd[[3]];
ChargeFactorField[i1,FFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=sign (nrInd[[2]]-nrInd[[3]]);
ChargeFactorField[i1,SFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=sign (nrInd[[2]]-nrInd[[3]]);,
nrInd=TestDim[-FieldDim[i,i1],Gauge[[i1,2,1]]];
ChargeFactorField[i1,Fields[[i,3]]]=-(nrInd[[2]]-nrInd[[3]]);
ChargeFactorField[i1,FFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=- sign (nrInd[[2]]-nrInd[[3]]);
ChargeFactorField[i1,SFields[[i]]/. conj[x_]->x//.A_[{b__}]->A]=-sign (nrInd[[2]]-nrInd[[3]]);
];
];
];
i++;];
i1++;];

];
CheckChargeConservation:=Block[{i,j,i1,sum,violation,sign,rpv=False,violationDiscrete=False},
violation=False;
gauges=DeleteCases[DeleteCases[Head/@Table[Gauge[[i,2]],{i,1,Length[Gauge]}],U],SU];
If[gauges=!={},
ChargeConservation::NoSUN="Check of charge conservation works so far only for SU(N) groups";
Message[ChargeConservation::NoSUN];
Return[];
];
PrintDebug["  checking charge conservation"];
Print["  checking charge conservation: ", Dynamic[DynamicCheckingCCSup]];

InitChargeFactors;

DynamicCheckingCCSup = "check local symmetries";
For[i=1,i<=Length[SuperPotential],
For[i1=1,i1<=Length[Gauge],
sum=0;
For[j=1,j<=Length[SuperPotential[[i,2]]],
sum +=ChargeFactorField[i1,SuperPotential[[i,2,j]]];
j++;];
If[FullSimplify[sum]=!=0,
If[Gauge[[i1,2]]===U[1],
If[Cases[sum,x_?SymbolQS,2]==={},
Message[Superpotential::ChargeViolation,Gauge[[i1,3]],SuperPotential[[i,2]]];,
Message[Superpotential::MaybeChargeViolation,Gauge[[i1,3]],SuperPotential[[i,2]],Cases[sum,x_?SymbolQS,2]];
];
violation=True;,
If[Mod[sum,Gauge[[i1,2,1]]]=!=0, 
Message[Superpotential::ChargeViolation,Gauge[[i1,3]],SuperPotential[[i,2]]];
violation=True;
];
];
];
i1++;];

DynamicCheckingCCSup = "check global symmetries";
For[i1=1,i1<=Length[Global],
If[CheckChargeConservationGlobal[SuperPotential[[i,2]],Global[[i1,2]]]==False,
violationDiscrete=True;
Message[Superpotential::ViolationGlobal,Global[[i1,2]],SuperPotential[[i,2]]];
];
i1++;];
i++;];

DynamicCheckingCCSup = "";
If[violation==False,
PrintDebug["     No violation of charge conservation in superpotential"];
DynamicCheckingCCSup="local symmetries okay. ";
];

(*
If[rpv==False && RParityConservation==True,
Print["     No violation of R-Parity in superpotential"];
];
*)
If[violationDiscrete==False && Length[Global]>0,
PrintDebug["     No violation of a global in superpotential"];
DynamicCheckingCCSup=DynamicCheckingCCSup<>"global symmetries okay.";
];

];

CheckLagTermChargeConservation[term_]:=CheckLagTermChargeConservation[term,True];

(*
CheckLagTermChargeConservation[term_,printout_]:=Block[{i1,sum=0,j,violation},
violation=False;
For[i1=1,i1<=Length[Gauge],
sum=0;
For[j=1,j<=Length[term],
If[Head[term[[j]]]===conj ||Head[term[[j]]]===bar, 
sum -=ChargeFactorField[i1,RE[term[[j]]]];,
sum +=ChargeFactorField[i1,RE[term[[j]]]];
];
j++;];
If[FullSimplify[sum]=!=0,
If[Gauge[[i1,2]]===U[1],
If[printout==True,
If[Cases[sum,x_?SymbolQS,2]==={},
Message[Lagrange::ChargeViolation,Gauge[[i1,3]]];,
Message[Lagrange::MaybeChargeViolation,Gauge[[i1,3]],Cases[sum,x_?SymbolQS,2]];
];
];
violation=True;,
If[Mod[sum,Gauge[[i1,2,1]]]=!=0, 
If[printout==True,Message[Lagrange::ChargeViolation,Gauge[[i1,3]]];];
violation=True;
];
];
]; 
i1++;];
If[violation==True,
Return[False];,
Return[True];
];
];
*)

CheckLagTermChargeConservation[term_,printout_]:=Block[{i1,sum=0,j,violation,reps},
violation=False;
For[i1=1,i1<=Length[Gauge],
sum=0;
reps={};
For[j=1,j<=Length[term],
If[Head[term[[j]]]===conj ||Head[term[[j]]]===bar, 
reps=Join[reps,{ConjugatedRep[SA`DynL[RE[term[[j]]],Gauge[[i1,3]]],Gauge[[i1,2]]]}];
sum -=ChargeFactorField[i1,RE[term[[j]]]];,
reps=Join[reps,{SA`DynL[RE[term[[j]]],Gauge[[i1,3]]]}];
sum +=ChargeFactorField[i1,RE[term[[j]]]];
];
j++;];

If[FullSimplify[sum]=!=0,
If[Gauge[[i1,2]]===U[1],
If[printout==True,
If[Cases[sum,x_?SymbolQS,2]==={},
Message[Lagrange::ChargeViolation,Gauge[[i1,3]],term];,
Message[Lagrange::MaybeChargeViolation,Gauge[[i1,3]],Cases[sum,x_?SymbolQS,2]];
];
];
violation=True;,

If[Invariants[SusynoForm[Gauge[[i1,2]]],DeleteCases[reps,{0}]]==={},
If[printout==True,Message[Lagrange::ChargeViolation,Gauge[[i1,3]],term];];
violation=True;
];

];
]; 
i1++;];
If[violation==True,
Return[False];,
Return[True];
];
];



CreateParameterFile:=Block[{temp,temp2,i,j,description,pos,initpar={}},
temp = ParameterDefinitions;
ParameterDefinitions={};

For[i=1,i<=Length[temp],
If[FreeQ[initpar,temp[[i,1]]],
description = Description /. temp[[i,2]];

If[description===Description || description === None || FreeQ[ParameterDefinitionsMain,description],
ParameterDefinitions =Join[ParameterDefinitions,{temp[[i]]}];,
temp2=temp[[i,2]];
pos = Position[ParameterDefinitionsMain,description][[1,1]];
For[j=1,j<=Length[ParameterDefinitionsMain[[pos,1]]],
If[FreeQ[temp2,ParameterDefinitionsMain[[pos,1,j,1]]],
temp2 = Join[temp2,{ParameterDefinitionsMain[[pos,1,j]]}];
];
j++;];
ParameterDefinitions =Join[ParameterDefinitions,{{temp[[i,1]],temp2}}];
];
initpar = Join[initpar,{temp[[i,1]]}];
];
i++;];

SA`LHList=Select[Table[{ParameterDefinitions[[i,1]],(LesHouches /.ParameterDefinitions[[i,2]])},{i,1,Length[ParameterDefinitions]}],(FreeQ[#,LesHouches])&] ;

];



CreateParticleFile:=Block[{temp,temp2,tempFin,i,j,k,description,pos},
For[k=1,k<=Length[NameOfStates]+1,
If[k>Length[NameOfStates],
temp = WeylFermionAndIndermediate;,
temp = ParticleDefinitions[NameOfStates[[k]]];
];
tempFin={};

If[Head[temp]===List,
For[i=1,i<=Length[temp],
description = Description /. temp[[i,2]];

If[description===Description || description === None || FreeQ[ParticleDefinitionsMain,description],
tempFin =Join[tempFin,{temp[[i]]}];,
temp2=temp[[i,2]];
pos = Position[ParticleDefinitionsMain,description][[1,1]];
For[j=1,j<=Length[ParticleDefinitionsMain[[pos,1]]],
If[FreeQ[temp2,ParticleDefinitionsMain[[pos,1,j,1]]],
temp2 = Join[temp2,{ParticleDefinitionsMain[[pos,1,j]]}];
];
j++;];
tempFin =Join[tempFin,{{temp[[i,1]],temp2}}];
];
i++;];
If[k>Length[NameOfStates],
WeylFermionAndIndermediate = tempFin;,
ParticleDefinitions[NameOfStates[[k]]] = tempFin;
];
];
k++;];
];


CheckU1mixing:=Block[{i,temp,pos,listU1,mulfac,i1,i2,pos1,pos2,sum},
nonDiagonalU1=False;
mulfac=Table[{0},{Length[Fields]}];
listU1=Select[Gauge,(#[[2]]===U[1])&];
If[Length[listU1]>1,
Print["Checking U(1)'s for orthogonality"];
For[i=1,i<=Length[Fields],
states=Fields[[i,2]];
For[k=1,k<=AnzahlGauge,
If[(k=!=gaugeNr) && (Gauge[[k,2]]=!=U[1]), 
states *= Abs[FieldDim[i,k]];
];
k++;];
mulfac[[i]]=states;
i++;];

For[i1=1,i1<=Length[listU1],
pos1=Position[Gauge,listU1[[i1,1]]][[1,1]];
For[i2=i1+1,i2<=Length[listU1],
pos2=Position[Gauge,listU1[[i2,1]]][[1,1]];
sum=Sum[mulfac[[j]] Fields[[j,3+pos1]]Fields[[j,3+pos2]],{j,1,Length[Fields]}];
If[FullSimplify[sum]=!=0,
Print["   U(1)'s not orthogonality: ",Gauge[[pos1,3]]," and ",Gauge[[pos2,3]]];
nonDiagonalU1 = True;
];
i2++;];
i1++;];
];

];


CheckChargeConservationInteraction[fields_]:=Block[{i,temp,cc=True,sum},
For[i=1,i<=Length[Gauge],
(* If[(Head[Gauge[[i,2]]]=== SU || Head[Gauge[[i,2]]]=== U ) , *)
If[Head[Gauge[[i,2]]]=== U  ,
sum=Plus@@(ChargeFactorField[i,#]&/@fields);
If[(sum=!=0 && SU[sum] =!= Gauge[[i,2]]),cc=False;];,
If[CheckSusynoGaugeInvariant[fields,i]===False,
cc=False;
];
];
i++;];
Return[cc];
];

CheckPossibleTermsSuperPotential:=Block[{i,allfieldCombis,allowed,temp={},singlets,present,notpresent},
Print["Checking for additional terms in the superpotential"];
(* Print["    (Note, additional discrete symmetries are not yet considered)"]; *)
allfieldCombis=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[Fields][[3]],Transpose[Fields][[3]],Transpose[Fields][[3]]}],{1,3}]];
allowed = Intersection[Select[allfieldCombis,(CheckChargeConservationInteraction[#]==True)&]];
allowed=Select[allowed,(CheckConservationGlobal[#]==True)&];
(* singlets = Cases[allowed,{s_}];
For[i=1,i<=Length[singlets],
allowed = Join[allowed ,{{singlets[[i,1]],singlets[[i,1]]},{singlets[[i,1]],singlets[[i,1]],singlets[[i,1]]}}];
i++]; *)
(*
For[i=1,i<=Length[allowed],
If[RParityConservation==True,
If[Times@@(getRParitySF/@allowed[[i]])===1,
temp=Join[temp,{allowed[[i]]}];
];,
temp=Join[temp,{allowed[[i]]}];
];
i++;]; *)
temp=allowed;
temp=(C@@#)&/@temp;
present=(C@@#)&/@Transpose[SuperPotential][[2]];

notpresent=Complement[temp,present];
(*
If[notpresent=!={},
If[RParityConservation==True,
Message[PossibleTerms::NoRParity,(List@@#)&/@notpresent];,
Message[PossibleTerms::IncludeRParity,(List@@#)&/@notpresent];
];,
If[RParityConservation==True,
Print["    All terms allowed by gauge invariance and R-parity conservation are present"];,
Print["    All terms allowed by gauge invariance are present"];
];
];
*)


If[notpresent=!={},
Message[PossibleTerms::IncludeGlobal,(List@@#)&/@notpresent];,
Print["    All terms allowed by gauge invariance and global symmetries are present"];
];

];


CheckPossibleTermsPotential:=Block[{i,allfieldCombis,allowed,temp={},singlets,present,notpresent},
Print["Checking for additional terms in the potential"];
allfieldCombisScalars1=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]]}],{1}]];
allfieldCombisScalars2=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]]}],{2}]];
allfieldCombisScalars2=Join[allfieldCombisScalars2,Map[{conj[#[[1]]],#[[2]]}&,allfieldCombisScalars2]];
allfieldCombisScalars30=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]]}],{3}]];
allfieldCombisScalars3=allfieldCombisScalars30;
allfieldCombisScalars3=Join[allfieldCombisScalars3,Map[{conj[#[[1]]],#[[2]],#[[3]]}&,allfieldCombisScalars30]];
allfieldCombisScalars3=Join[allfieldCombisScalars3,Map[{#[[1]],conj[#[[2]]],#[[3]]}&,allfieldCombisScalars30]];
allfieldCombisScalars3=Join[allfieldCombisScalars3,Map[{#[[1]],#[[2]],conj[#[[3]]]}&,allfieldCombisScalars30]];
allfieldCombisScalars40=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]],Transpose[ScalarFields][[3]]}],{4}]];
allfieldCombisScalars4=allfieldCombisScalars40;
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],#[[2]],#[[3]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],conj[#[[2]]],#[[3]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],#[[2]],conj[#[[3]]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],#[[2]],#[[3]],conj[#[[4]]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],conj[#[[2]]],#[[3]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],#[[2]],conj[#[[3]]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{conj[#[[1]]],#[[2]],#[[3]],conj[#[[4]]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],conj[#[[2]]],conj[#[[3]]],#[[4]]}&,allfieldCombisScalars40]];
allfieldCombisScalars4=Join[allfieldCombisScalars4,Map[{#[[1]],conj[#[[2]]],#[[3]],conj[#[[4]]]}&,allfieldCombisScalars40]];

allfieldCombisFermions1=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[FermionFields][[3]],Transpose[FermionFields][[3]],Transpose[FermionFields][[3]]}],{1}]];
allfieldCombisFermions2=(List@@#)&/@Intersection[(C@@#)&/@Subsets[Flatten[{Transpose[FermionFields][[3]],Transpose[FermionFields][[3]],Transpose[FermionFields][[3]]}],{2}]];

allfieldCombisFermions1Scalar2={};
For[i=1,i<=Length[allfieldCombisFermions2],
For[j=1,j<=Length[allfieldCombisScalars1],
allfieldCombisFermions1Scalar2=Join[allfieldCombisFermions1Scalar2,{{allfieldCombisScalars1[[j,1]],allfieldCombisFermions2[[i,1]],allfieldCombisFermions2[[i,2]]},{conj[allfieldCombisScalars1[[j,1]]],allfieldCombisFermions2[[i,1]],allfieldCombisFermions2[[i,2]]},
{conj[allfieldCombisScalars1[[j,1]]],conj[allfieldCombisFermions2[[i,1]]],allfieldCombisFermions2[[i,2]]},
{conj[allfieldCombisScalars1[[j,1]]],allfieldCombisFermions2[[i,1]],conj[allfieldCombisFermions2[[i,2]]]}}];
j++;];
i++;];

allfieldCombisFermions2=Join[allfieldCombisFermions2,Map[{conj[#[[1]]],#[[2]]}&,allfieldCombisFermions2]];
allfieldCombisFermions2=DeleteCases[DeleteCases[allfieldCombisFermions2,{conj[x_],x_}],{x_,conj[x_]}];

allowed = Intersection[Select[allfieldCombisScalars4,(CheckLagTermChargeConservation[#,False]==True)&]];
allowed = Join[allowed,Intersection[Select[allfieldCombisScalars3,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisScalars2,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisScalars1,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisFermions1,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisFermions2,(CheckLagTermChargeConservation[#,False]==True)&]]];
allowed = Join[allowed,Intersection[Select[allfieldCombisFermions1Scalar2,(CheckLagTermChargeConservation[#,False]==True)&]]];

allowed=Intersection[(C@@#)&/@allowed];
SA`CheckGlobalLagLevel=True;
allowed=Select[allowed,(CheckConservationGlobal[#]==True)&];
SA`CheckGlobalLagLevel=False;
present=(C@@#)&/@SA`LagTermsNonSUSY;

notpresent=Complement[allowed,present];
Print[notpresent];
If[notpresent=!={},
Message[PossibleTerms::NonSUSY,(List@@#)&/@notpresent];,
Print["    All terms allowed by gauge invariance are present"];
];

];




(* End[] *)
