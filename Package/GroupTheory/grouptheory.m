(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
epsTensorMatrix[n_]:=Block[{i,j,res,NR},
res=epsTensor@@Table[NR[j],{j,1,n}];
For[i=1,i<=n,
res = Table[res,{NR[i],1,n}];
i++];
Return[res];
];


RM[G_, D_,x_][a__Integer]:=RM[G,-D,x][a] /; D<0;
GINV[G_, D_][a__Integer]:=GINV[G,-D][a] /; D<0;



(* ::Input::Initialization:: *)
GaugeInteractionMatrix[group_,dim_]:=Block[{i,j,pos,res,res2,nr1,x1,x2,stringName,indname},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GaugeInteractionMatrix";
SA`Doc`Info = "This routine was an attempt to obtain the gauge interaction matrix. As far as I can see, it's no longer used but replaced by the functionality of Susyno.";
SA`Doc`Input = {"group"->"Considered gauge group","dim"->"Considered representation"};
SA`Doc`GenerateEntry[];

pos=Position[Gauge,group][[1,1]];
nr1=SA`NrIndices[group,dim];
stringName = ToString[Gauge[[pos,3]]];
res = getGenerator[pos,dim,10,1,2]*(RM[group,dim,x1]@@Table[ToExpression[stringName<>appendIndex[[i]]],{i,1,nr1}] /. subGC[1])(RM[group,dim,x2]@@Table[ToExpression[stringName<>appendIndex[[i]]],{i,1,nr1}] /. subGC[2]); 
resSave=res;
For[i=1,i<=nr1,
res=Hold[Sum[Sum[RES,NAME1],NAME2]] /. NAME1 ->{(ToExpression[stringName<>appendIndex[[i]]]/. subGC[1]),1,Gauge[[pos,2,1]]}/. NAME2 -> {(ToExpression[stringName<>appendIndex[[i]]]/. subGC[2]),1,Gauge[[pos,2,1]]} /. RES->res;
res = ReleaseHold[res];
i++;];

(* If[Gauge[[i,5]]===True, *)
res = res /.( (ToExpression["a"<>StringTake[ToString[Gauge[[pos,3]]],3]<>"10"]):>gen10);
(* ]; *)

res = Sum[res,{gen10,1,Gauge[[pos,2,1]]^2-1}];
res=Table[Table[D[D[res,IR[x1][i]],IR[x2][j]],{i,1,dim}],{j,1,dim}];
Off[Part::"pspec"];
Off[Part::"pkspec1"];
ReleaseHold[Hold[Set[LHS,RHS]] /. LHS -> GINV[group,dim][a__Integer] /. RHS -> (res[[a]])];
On[Part::"pspec"];
On[Part::"pkspec1"];

SA`Doc`EndEntry[];
];

getInvariantMatrix[fields_,coup_]:=Block[{i,j,k,res=1},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "getInvariantMatrix";
SA`Doc`Info = "Calculates the invariance matrix (Clebsch-Gordan-Coefficients) for a given combination of fields. That's done by loop over all gauge groups and finding a gauge invariant contraction of the indices of the involved fields. The actual contraction of indices is done in the routine 'GenerateInvariantsTensor'.";
SA`Doc`Input={"fields"->"List of involved fields","coup"->"Name of the coupling"};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[Gauge],
If[Gauge[[i,2]]=!=U[1],
Off[Part::"pkspec1"];
res=res*(GenerateInvariantsTensor[Gauge[[i,2]],Gauge[[i,3]],Table[Fields[[Position[ListFields,fields[[j]]][[1,1]],3+i]],{j,1,Length[fields]}]]/.CG[a_,b_]:>InvariantMatrixSusyno[a,b] /. 1[]->1);
On[Part::"pkspec1"];
];
i++;];

SA`Doc`Return[res];
];

(*
getRepresentationMatrix[field_,nr_]:=Block[{i,j,ind,pos,res={},indFinal={},k},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "getRepresentationMatrix";
SA`Doc`Info = "";
SA`Doc`GenerateEntry[];

pos=Position[ListFields,field][[1,1]];
For[j=1,j\[LessEqual]Length[Gauge],
ind=Select[ListFields[[pos]],(FreeQ[#,Gauge[[j,3]]]\[Equal]False)&];
If[ind=!={},
ind=ind[[1]]; 
indFinal={};
For[k=1,k\[LessEqual]Length[ind[[1]]],
If[ind[[2,k,1]]===Gauge[[j,3]] || ind[[2,k,1]]===-Gauge[[j,3]],
indFinal = Join[indFinal,{ind[[1,k]]}];
];
k++;];
If[indFinal=!={},
res=Join[res,{RM[Gauge[[j,2]],Fields[[pos,3+j]],nr]@@indFinal}];,
If[Gauge[[j,2]]===U[1],res=Join[res,{IR[nr][1]}];,res=Join[res,{1}];];
];,
If[Gauge[[j,2]]===U[1],res=Join[res,{IR[nr][1]}];,res=Join[res,{1}];];
];
j++;];

SA`Doc`Return[res];
];
*)


GetCubicDynkin[reps_,N_]:=Block[{known,unknown,iterator=1,i,j,repsDyn={}},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GetCubicDynkin";
SA`Doc`Info = "Checks for triangle anomalies involving non-fundamental representations. That's done by calculatung the value of the cubic Dynkin Tr(T^a T^b T^c) with help of Susyno.";
SA`Doc`Input={"reps"->"List of all representation for given gauge group","N"->"The N in SU(N) to define the gauge group"};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[reps],
If[reps[[i]]=!=1,
If[Head[reps[[i]]]===List,
repsDyn=Join[repsDyn,{reps[[i,2]]}];,
repsDyn=Join[repsDyn,{getDynkinLabels[reps[[i]],N]}];
];
];
i++;];

For[i=1,i<=Length[repsDyn],
SA`Dynkin3[repsDyn[[i]],N]=TriangularAnomalyValue[{SusynoForm[SU[N]]},{repsDyn[[i]]}][[1]];
i++;];

SA`Doc`EndEntry[];
];

SA`Dynkin3[a_Integer,dim_]:=SA`Dynkin3[getDynkinLabels[a,dim],dim];
SA`Dynkin3[{a_Integer,b_List},dim_]:=SA`Dynkin3[b,dim];
SA`Dynkin3[a_Integer,dim_]:=0 /;(a===1 && dim>1)

GetQuadraticDynkin[reps_,N_]:=Block[{i,j},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GetQuadraticDynkin";
SA`Doc`Info = "Calculates the quadratic Dynkin index Tr(T^a T^b)";
SA`Doc`Input={"reps"->"List of all representation for given gauge group","N"->"The N in SU(N) to define the gauge group"};
SA`Doc`GenerateEntry[];

SA`Dynkin2[N,N]=1;
SA`Dynkin2[-N,N]=1;
SA`Dynkin2[0,N]=0;

For[i=1,i<=Length[reps],
If[reps[[i]]===1,
SA`Dynkin2[reps[[i]],N]=0;,
SA`Dynkin2[reps[[i]],N]=TestDim[Abs[reps[[i]]],N][[5]];
];
i++;];

SA`Doc`EndEntry[];
];

GenerateQuadraticAndCubicDynkins:=Block[{i,j,k,reps,ggroups},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GenerateQuadraticAndCubicDynkins";
SA`Doc`Info = "Wrapper function to generate all quadratic and cubic Dynkin indices for the gauge groups present in the considered model. The routine loops over the given gauge groups as well as over all representation under these gauge groups.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

PrintDebug["Generate cubic Dynkins"];
DynamicCheckAnomalies="Generate cubic Dynkins"!;
ggroups=Table[Gauge[[i,2]],{i,1,Length[Gauge]}];
reps=Table[{},{Length[ggroups]}];

For[i=1,i<=Length[Gauge],
pos=Position[ggroups,Gauge[[i,2]]][[1,1]];
For[j=1,j<=Length[Fields],
reps[[pos]]=Join[reps[[pos]],{Fields[[j,3+i]]}];
j++;];
i++;];

(* reps=Intersection/@DeleteCases[reps,1,5]; *)

For[i=1,i<=Length[reps],
If[Head[ggroups[[i]]]=== U || Head[ggroups[[i]]]===SU,
If[ggroups[[i]]=!=U[1],
GetQuadraticDynkin[reps[[i]],ggroups[[i,1]]];
If[ggroups[[i]]=!=SU[2],
GetCubicDynkin[reps[[i]],ggroups[[i,1]]];,
SA`Dynkin3[a__,2]=0;
];,
For[j=1,j<=Length[reps[[i]]],
SA`Dynkin3[reps[[i,j]],1]=reps[[i,j]]^3;
SA`Dynkin2[reps[[i,j]],1]=reps[[i,j]]^2;
j++;];
];
];
i++;];

SA`Doc`EndEntry[];
];


GetMultiplicites:=Block[{i,j,k},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GetMultiplicites";
SA`Doc`Info = "This routine calculates the multiplicity of a particle with respect to a specific gauge group. The multiplicity is the product of the dimension of the field under all other gauge groups than the considered one. E.g., left quark has multiplicity 2 under SU(3)_c (=2 isospin states), and multiplicity 3 under SU(2)_L (=3 color).";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[Gauge],
For[j=1,j<=Length[Fields],
mfac=Fields[[j,2]];
For[k=1,k<=Length[Gauge],
If[k=!=i&&Gauge[[k,2]]=!=U[1],
mfac=mfac*Abs[Fields[[j,3+k]]];
];
k++;];
MultiplicityFactorSF[Fields[[j,3]],Gauge[[i,3]]]=mfac;
j++;];
i++;];

SA`Doc`EndEntry[];
];

getDynkinLabels[dim_,group_]:=Block[{},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "getDynkinLabels";
SA`Doc`Info = "This is a wrapper routine to get the Dynkin labels for a given representation of a gauge group. For a singlet, the {0} is returned. Note, it is NOT checked if the dimension is unique. For a SU(N) group, the hand-made implementation using Young tableaus is called, for other groups, Susyno is used.";
SA`Doc`Input={"dim"->"Dimension of the considered representation", "group"->"considered gauge gorup"};
SA`Doc`GenerateEntry[];

If[Abs[dim]===1,SA`Doc`Return[{0}]];
Switch[Head[group],
SU,SA`Doc`Return[getDynkinLabels[dim,group[[1]]]];,
_,SA`Doc`Return[getDynkinLabelsSusyno[SusynoForm[group],dim]];
];
];


getDynkinLabels[dim_,N_Integer]:=Block[{},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "getDynkinLabels";
SA`Doc`Info = "This function searches for the Dynkin lables of a given representation under a specific SU(N) group. For doing it, it looks for the Young Tableaux which corresponds to the dimension and extracts the Dynkin labels from it.";
SA`Doc`Input={"dim"->"Dimension of the considered representation", "N"->"The N in SU(N) to define the gauge group"};
SA`Doc`GenerateEntry[];

If[Abs[dim]===1,Return[{0}]];
(* If[dim\[Equal]-2 && N\[Equal]2,Return[{-1}];]; *)
If[N===2 && dim < 0,
SA`Doc`Return[-YoungToDynkin[getYoungTableaux[dim,N],N]];,
SA`Doc`Return[YoungToDynkin[getYoungTableaux[dim,N],N]];
];
];

(* some short function to obtain basic properties *)

DynkinLabels[dim,SU[N]]:=YoungToDynkin[getYoungTableaux[dim,N],N];
YoungToDynkin[tab_,N_]:=If[Length[DeleteCases[tab,0,2]]>N,NOTAB,Table[If[i<Length[tab],tab[[i]]-tab[[i+1]],If[i==Length[tab],tab[[i]],0]],{i,1,N-1}]];
DynkinToYoung[dyn_]:=DeleteCases[Table[Plus@@Take[dyn,{i,Length[dyn]}],{i,1,Length[dyn]}],0,2];
DynkinToDim[dyn_,N_]:=UseHookFormular[DynkinToYoung[dyn],N];

getDynkinLabelsAdjoint[group_]:=Adjoint[SusynoForm[group]];

getNumberStatesAdjoint[group_]:=Switch[Head[group],
U,1,
SU, group[[1]]^2-1,
_,DimR[SusynoForm[group],Adjoint[SusynoForm[group]]]
];

getDimAdjoint[group_]:=getNumberStatesAdjoint[group];

getDimFundamental[group_]:=Switch[Head[group],
U, 1,
SU, group[[1]],
SO, group[[1]],
F, Switch[group[[1]],4,26],
E,Switch[group[[1]],6,27,7,56,8,248]
];

SA`DynL[conj[a_],b_Integer]:=ConjugatedRep[SA`DynL[a,b],Gauge[[b,2]]];
SA`DynL[bar[a_],b_Integer]:=ConjugatedRep[SA`DynL[a,b],Gauge[[b,2]]];
SA`DynL[conj[a_],b_Symbol]:=ConjugatedRep[SA`DynL[a,b],Gauge[[Position[Gauge,b][[1,1]]]][[2]]]/;(FreeQ[Gauge,b]==False);
SA`DynL[bar[a_],b_Symbol]:=ConjugatedRep[SA`DynL[a,b],Gauge[[Position[Gauge,b][[1,1]]]][[2]]]/;(FreeQ[Gauge,b]==False);
SA`DynL[conj[a_],b_Symbol]:=ConjugatedRep[SA`DynL[a,b],AuxGauge[[Position[AuxGauge,b][[1,1]]]][[2]]]/;(FreeQ[Gauge,b]==True && FreeQ[AuxGauge,b]==False );
SA`DynL[bar[a_],b_Symbol]:=ConjugatedRep[SA`DynL[a,b],AuxGauge[[Position[AuxGauge,b][[1,1]]]][[2]]]/;(FreeQ[Gauge,b]==True &&  FreeQ[AuxGauge,b]==False );


SA`DynL[a_,b_]:=SA`DynL[(a/.diracSub[ALL])[[1]],b]/;(FreeQ[diracFermions[ALL],a]==False);

CG[a_,{}][b___]=1;



ConjugatedRepQ[dyn_,groups_]:=Block[{dim},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "ConjugatedRepQ";
SA`Doc`Info = "This function checks given Dynkin labels with respect to a given gauge group belong to an conjugated representation or not. The simple cases of 6 and bar(3) of SU(3) are hard-coded. For the general case, Susyno is used: first the dimension N corresponding to the Dynkin labels are calculated. Afterwards, the Dynkin labels for the dimension are obtained. This works because N doesn't carry a sign, i.e. Susyno returns always the Dynkin labels for a non-conjugated representation.";
SA`Doc`Input={"dyn"->"Considered Dynkin labels","groups"->"Considered gauge group"};
SA`Doc`GenerateEntry[];

dim=DimR[SusynoForm[groups],dyn];
If[dyn==={0,2} && groups===SU[3], SA`Doc`Return[True];];
If[dyn==={2,0} && groups===SU[3], SA`Doc`Return[False];];
If[FreeQ[getDynkinLabelsSusyno[SusynoForm[groups],dim],dyn],
SA`Doc`Return[True];,
SA`Doc`Return[False];
];
];

ConjugatedRep[dyn_,groups_]:=Block[{i,l,r},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "ConjugatedRep";
SA`Doc`Info = "This routine returns the Dynkin labels corresponding to the conjugated Irrep of the one defined by the Dynkin labels given as input.";
SA`Doc`Input={"dyn"->"The Dynkin labels given as input","groups"->"The considered gauge group"};
SA`Doc`GenerateEntry[];

If[dyn==={0},SA`Doc`Return[{0}];];
Switch[Head[groups],
U,SA`Doc`Return[-dyn];,
SU,
	l=groups[[1]]-1;
	SA`Doc`Return[Table[dyn[[l+1-i]],{i,1,Length[dyn]}]];,
_,
	SA`Doc`Return[ConjugateIrrep[SusynoForm[groups],dyn]];
];
];

getTensorIndizes[dim_,group_]:=Block[{temp},
Switch[Head[group],
SU,
	temp=TestDim[dim,group[[1]]];
	Return[temp[[2]]+temp[[3]]];
	
];
];

InitGaugeGroups:=Block[{i,j,k,l,list,reps,groups,pos,rep,crep},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "InitGaugeGroups";
SA`Doc`Info = "This routine initialises all gauge theoretical information needed for the given gauge groups and representation: \n
- quadratic and cubic Dynkin indices \n
- quadratic Casimir index \n
- Generators (for the broken and unbroken case) \n
- Generator matrices \n
This is done for all gauge groups defined in Gauge. Moreover, also AuxGauge is considered to get that information for unbroken subgroups of a higher group. 
";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

PrintDebug["   Calculate Lie Group constants"];
DynamicInitGaugeG="Construct gauge group constants";
For[i=1,i<=Length[Gauge],
If[Gauge[[i,2]]=!=U[1],
CG[Gauge[[i,2]],{{0},{0}}][a_,b_]:=1;
SA`KnonwCG=Join[SA`KnonwCG,{CG[Gauge[[i,2]],{{0},{0}}]}];
reps=Join[{getDynkinLabelsAdjoint[Gauge[[i,2]]]},DeleteCases[getDynkinLabels[#,Gauge[[i,2]]]&/@Intersection[Transpose[Fields][[3+i]]],{0}]];
(* reps=Abs[reps]; *)
GenerateDynkinCasimir[Gauge[[i,2]] ,#]&/@reps;
GenerateGeneratorsUnbrokenGroup[i,#]&/@reps;
If[Gauge[[i,5]]==True,
GenerateGeneratorsBrokenGroup[i,#]&/@reps; ,
GenerateGeneratorsUnbrokenGroup[i,#]&/@reps;
];
If[Head[Gauge[[i,2]]]=!=SU || Gauge[[i,2,1]]>3,
GeneratorMatrices[Gauge[[i,2]]]=Normal[RepMatrices[SusynoForm[Gauge[[i,2]]],getDynkinLabels[getDimFundamental[Gauge[[i,2]]],Gauge[[i,2]]]]];
];
];
(* Initialize Deltas for N^* N *)
For[j=1,j<=Length[reps],
rep=reps[[j]];
crep=ConjugatedRep[rep,Gauge[[i,2]]];
If[rep=!=crep && crep=!={},
If[FreeQ[SA`KnonwCG,CG[Gauge[[i,2]],{crep,rep}]],
SA`KnonwCG = Join[SA`KnonwCG,{CG[Gauge[[i,2]],{crep,rep}]}];
CG[Gauge[[i,2]],{crep,rep}][a__]=Delta[a];
];
If[FreeQ[SA`KnonwCG,CG[Gauge[[i,2]],{rep,crep}]],
SA`KnonwCG = Join[SA`KnonwCG,{CG[Gauge[[i,2]],{rep,crep}]}];
CG[Gauge[[i,2]],{rep,crep}][a__]=Delta[a];
];
];
j++;];
i++;];

For[i=1,i<=Length[AuxGauge],
If[AuxGauge[[i,2]]=!=U[1],
CG[AuxGauge[[i,2]],{{0},{0}}][a_,b_]:=1;
SA`KnonwCG=Join[SA`KnonwCG,{CG[AuxGauge[[i,2]],{{0},{0}}]}];
reps=Intersection[Join[{getDynkinLabelsAdjoint[AuxGauge[[i,2]]]},DeleteCases[getDynkinLabels[#,AuxGauge[[i,2]]]&/@Intersection[Select[Flatten[Select[Flatten[AuxDimFields,1],FreeQ[#,{AuxGauge[[i,3]],_}]==False&]],Head[#]===Integer&]],{0}]]];
(* reps=Abs[reps]; *)
GenerateDynkinCasimir[AuxGauge[[i,2]] ,#]&/@reps;
GenerateGeneratorsUnbrokenGroup[i,#,True]&/@reps;
If[Head[AuxGauge[[i,2]]]=!=SU || AuxGauge[[i,2,1]]>3,
GeneratorMatrices[AuxGauge[[i,2]]]=Normal[RepMatrices[SusynoForm[AuxGauge[[i,2]]],getDynkinLabels[getDimFundamental[AuxGauge[[i,2]]],AuxGauge[[i,2]]]]];
];
];
i++;];


If[AuxGaugesPresent===True,
For[i=1,i<=Length[AuxGauge],
If[AuxGauge[[i,2]]=!=U[1],
CG[AuxGauge[[i,2]],{{0},{0}}][a_,b_]:=1;
SA`KnonwCG=Join[SA`KnonwCG,{CG[AuxGauge[[i,2]],{{0},{0}}]}];
reps=Join[{getDynkinLabelsAdjoint[AuxGauge[[i,2]]]},DeleteCases[getDynkinLabels[#,AuxGauge[[i,2]]]&/@Intersection[Transpose[Transpose[AuxDimFields][[2]]][[2]]],{0}]];
(* reps=Abs[reps]; *)
GenerateDynkinCasimir[AuxGauge[[i,2]] ,#]&/@reps;
];
(* Initialize Deltas for N^* N *)
For[j=1,j<=Length[reps],
rep=reps[[j]];
crep=ConjugatedRep[rep,AuxGauge[[i,2]]];
If[rep=!=crep && crep=!={},
If[FreeQ[SA`KnonwCG,CG[AuxGauge[[i,2]],{crep,rep}]],
SA`KnonwCG = Join[SA`KnonwCG,{CG[AuxGauge[[i,2]],{crep,rep}]}];
CG[AuxGauge[[i,2]],{crep,rep}][a__]=Delta[a];
];
If[FreeQ[SA`KnonwCG,CG[AuxGauge[[i,2]],{rep,crep}]],
SA`KnonwCG = Join[SA`KnonwCG,{CG[AuxGauge[[i,2]],{rep,crep}]}];
CG[AuxGauge[[i,2]],{rep,crep}][a__]=Delta[a];
];
];
j++;];
i++;];
];

InitStandardSU2;
InitStandardSU3;

conj[CG[a__]]:=CG[a];
Generator[_,{0}][___]=0;
Generator[_,{0},_][___]=0;

SA`Doc`EndEntry[];
];

(* CG[A_,{a_,b_,a_,b_}][i1_,i2_,i3_,i4_]:=CG[A,{a,b}][i1,i2] CG[A,{a,b}][i3,i4]; *)

InitStandardSU2:=Block[{},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "InitStandardSU2";
SA`Doc`Info = "The Clebsch-Gordon-Coefficients for the simplest representations of SU(2) are hardcoded here.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

CG[SU[2],{{1},{1}}][a__]=epsTensor[a];
CG[SU[2],{{-1},{-1}}][a__]=epsTensor[a];
CG[SU[2],{{-1},{1}}][a__]=Delta[a];
CG[SU[2],{{1},{-1}}][a__]=Delta[a];
 CG[SU[2],{{1},{1},{1},{1}}][a_,b_,c_,d_]:=epsTensor[a,b] epsTensor[c,d]; 

SA`Doc`EndEntry[];
];

InitStandardSU3:=Block[{},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "InitStandardSU3";
SA`Doc`Info = "The Clebsch-Gordon-Coefficients for the simplest representations of SU(3) are hardcoded here.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

CG[SU[3],{{0,1},{0,1},{0,1}}][a_,b_,c_]:=epsTensor[a,b,c];
CG[SU[3],{{1,0},{1,0},{1,0}}][a_,b_,c_]:=epsTensor[a,b,c];

CG[SU[3],{{1,0},{0,1}}][a__]=Delta[a];
CG[SU[3],{{0,1},{1,0}}][a__]=Delta[a];
CG[SU[3],{{1,0},{1,0},{1,0}}]=epsTensor;

SA`Doc`EndEntry[];
];

GenerateDynkinCasimir[group_,dyn_]:=Block[{i,j,k,casimir,dim,dimAdjoint},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GenerateDynkinCasimir";
SA`Doc`Info = "This routine calculates the quadratic Casimir and Dynkin indices for a given gauge group.";
SA`Doc`Input={"group"->"Considered gauge group", "dyn"->"Considered Dynkin Labels to define the Irrep"};
SA`Doc`GenerateEntry[];

If[dyn==={-1} && group===SU[2],
casimir=Casimir[SusynoForm[group],-dyn];
dim=DimR[SusynoForm[group],-dyn];
dimAdjoint=getDimAdjoint[group];,
casimir=Casimir[SusynoForm[group],dyn];
dim=DimR[SusynoForm[group],dyn];
dimAdjoint=getDimAdjoint[group];
];
SA`Casimir[dyn,group]=casimir;
SA`Dynkin[dyn,group]=casimir*dim/dimAdjoint;

SA`Doc`EndEntry[];
(* Generator *)
];

MakeGenerator[nr_,dyn_,cov_,con_]:=Block[{temp,temp2,i,j,complete,name},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "MakeGenerator";
SA`Doc`Info = "This routine obtains the generator for a given gauge group with a specific number of upper and lower indices. The result is stored as new variable of the form 'Generator[SU(N),Dyn,Name][indices]' where 'Name' is the name of the gauge group." ;
SA`Doc`Input={"nr"->"Gives the position in the array 'Gauge' to define the gauge group","dyn"->"Dynkin label to define the considered gauge group","cov"->"Number of covariant indices","con"->"Number of contra-variant indices"};
SA`Doc`GenerateEntry[];

name=Gauge[[nr,3]];
complete=cov+con;
(* dimGauge=Gauge[[gaugeNr,2]]; *)
temp=Plus@@Table[(Hold[TA[DIMGAUGE,genf[lor],IndexName[GAUGE,NR]/.subGC[p1],IndexName[GAUGE,NR]/.subGC[p2]]]/.NR->i/.GAUGE->name/.DIMGAUGE->Gauge[[nr,2]])Product[If[j==i,1,(Hold[Delta[IndexName[GAUGE,NR]/.subGC[p1],IndexName[GAUGE,NR]/.subGC[p2]]]/.NR->j/.GAUGE->name)],{j,1,complete}],{i,1,cov}]-Plus@@Table[(Hold[TA[DIMGAUGE,genf[lor],IndexName[GAUGE,NR]/.subGC[p2],IndexName[GAUGE,NR]/.subGC[p1]]]/.NR->i/.GAUGE->name/.DIMGAUGE->Gauge[[nr,2]])Product[If[j==i,1,(Hold[Delta[IndexName[GAUGE,NR]/.subGC[p1],IndexName[GAUGE,NR]/.subGC[p2]]]/.NR->j/.GAUGE->name)],{j,1,complete}],{i,cov+1,complete}];
Generator[Gauge[[nr,2]],dyn,Gauge[[nr,3]]][lor_,p1_,p2_]=temp;

SA`Doc`EndEntry[];
];


GenerateGeneratorsBrokenGroup[nr_,dyn_]:=Block[{i,j,group,ind1, ind2,dim},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GenerateGeneratorsBrokenGroup";
SA`Doc`Info = "This is a wrapper routine to generate the generator of a given field (as defined by it's Dynkin labels) and a given gauge group. It checks for the number of indices and calls afterwards the main routine 'MakeGenerator'.";
SA`Doc`Input={"nr"->"Gives the position in the array 'Gauge' to define the gauge group","dyn"->"Dynkin label to define the considered gauge group"};
SA`Doc`GenerateEntry[];

group=Gauge[[nr,2]];
If[Head[group]=!=SU, Print["Only broken SU(N) groups are supported!"]; Return[]];
dim=DimR[SusynoForm[group],Abs[dyn]];
If[ConjugatedRepQ[Abs[dyn],group],dim=-dim;];
If[dim===2 && dyn===-{1},dim=-dim;];
Switch[dim,
group[[1]]^2-1, MakeGenerator[nr,dyn,1,1];,
group[[1]],MakeGenerator[nr,dyn,1,0];,
-group[[1]],MakeGenerator[nr,dyn,0,1];,
_,
ytab=TestDim[{DimR[SusynoForm[group],dyn],dyn},group[[1]]];
MakeGenerator[nr,dyn,ytab[[2]],ytab[[3]]];
];

SA`Doc`EndEntry[];
];

GenerateGeneratorsUnbrokenGroup[nr_,dyn_]:=GenerateGeneratorsUnbrokenGroup[nr,dyn,False];
GenerateGeneratorsUnbrokenGroup[nr_,dyn_,auxgauge_]:=Block[{i,j,group},
SA`Doc`File = "Package/GroupTheory/grouptheory.nb";
SA`Doc`Name = "GenerateGeneratorsUnbrokenGroup";
SA`Doc`Info = "This routine generators the generator in the basis with unbroken gauge groups. This is needed for the calculation of non-SUSY RGEs because the generators show explicitly up there, not only the group constants as in the case of SUSY RGEs.";
SA`Doc`Input={"nr"->"Gives the position in the array 'Gauge' (or 'AuxGauge') to define the gauge group","dyn"->"Dynkin label to define the considered gauge group","auxgauge"->"defines, if 'Gauge' (False) or 'AuxGauge' (True) is considered"};
SA`Doc`GenerateEntry[];

If[auxgauge=!=True,
group=Gauge[[nr,2]];,
group=AuxGauge[[nr,2]];
];
If[group==SU[2] && dyn=={1},
Generator[SU[2],{1}][a__]=Sig[a]/2;
SA`Doc`Return[];
];
If[group==SU[2] && dyn=={-1},
Generator[SU[2],{-1}][a_,b_,c_]=-Sig[a,c,b]/2;
SA`Doc`Return[];
];
If[group==SU[2] && dyn=={2},
(* CG[group,{dyn,dyn}][a_,b_]:= Delta[a,b];   *)
Delta3[a_Integer,b_Integer]:={{0,0,1},{0,-1,0},{1,0,0}}[[a,b]];
(* Generator[SU[2],{2}][a__Integer]:=Normal[RepMatrices[SusynoForm[SU[2]],{2}]][[a]];  *)
Generator[SU[2],{2}][a__Integer]:={{{0,-(1/Sqrt[2]),1/Sqrt[2]},{-(1/Sqrt[2]),0,0},{1/Sqrt[2],0,0}},{{0,-(I/Sqrt[2]),-(I/Sqrt[2])},{I/Sqrt[2],0,0},{I/Sqrt[2],0,0}},{{0,0,0},{0,1,0},{0,0,-1}}}[[a]];
SA`Doc`Return[];
];
If[group==SU[3] && dyn=={1,0},
Generator[SU[3],{1,0}][a__]=Lam[a]/2;
SA`Doc`Return[];
];
If[group==SU[3] && dyn=={0,1},
Generator[SU[3],{0,1}][a_,b_,c_]=-Lam[a,c,b]/2;
SA`Doc`Return[];
];
If[group==SU[3] && dyn=={1,1},
CG[group,{dyn,dyn}][a_,b_]:=Delta[a,b];
(* Generator[SU[3],{1,1}][a__Integer]:=Normal[RepMatrices[SusynoForm[SU[3]],{1,1}]][[a]]; *)
Generator[SU[3],{1,1}][a__]=fSU3[a]/I; (* Check!*)
SA`Doc`Return[];
];
If[group==SU[3] || group==SU[2],NonFundamentalSU2SU3=True;]; (* to make sure to use the same matrices as Susyno *)

If[Head[group]===SU,
If[ConjugatedRepQ[dyn,group],
Generator[group,dyn][a_,b_,c_]=-Generator[group,ConjugatedRep[dyn,group]][a,c,b];
SA`Doc`Return[];,
Off[Part::"pspec"];
Off[Part::"pkspec1"];
Generator[group,dyn][a__Integer]=Normal[RepMatrices[SusynoForm[group],dyn]][[a]]; 
On[Part::"pspec"];
On[Part::"pkspec1"];

SA`Doc`Return[];
];
];

repm=Normal[RepMatrices[SusynoForm[group],dyn]];

If[DimR[SusynoForm[group],dyn]===getDimAdjoin[group],
 CG[group,{dyn,dyn}][a_,b_]:=Delta[a,b];
];

Off[Part::"pspec"];
Off[Part::"pkspec1"];
temp=Hold[SetDelayed[Generator[group,dyn][a___Integer],REP[[a]]]]/. REP->repm;
On[Part::"pspec"];
On[Part::"pkspec1"];
ReleaseHold[temp];

SA`SavedGenerators=Join[SA`SavedGenerators,{{Generator[group,dyn],repm}}];

SA`Doc`EndEntry[];
];



SA`DynL[a_,b_Integer]:=SA`DynL[a,Gauge[[b,3]]];
SA`Casimir[a_,b_Integer]:=SA`Casimir[a,Gauge[[b,3]]];
SA`Dynkin[a_,b_Integer]:=SA`Dynkin[a,Gauge[[b,3]]];
SA`MulFactor[a_,b_Integer]:=SA`MulFactor[a,Gauge[[b,3]]];
SA`DimensionGG[a_,b_Integer]:=SA`DimensionGG[a,Gauge[[b,3]]];
Generator[a_,b_Integer]:=Generator[a,Gauge[[b,3]]];
SA`Casimir[conj[a_],b_Integer]:=SA`Casimir[a,Gauge[[b,3]]];
SA`Dynkin[conj[a_],b_Integer]:=SA`Dynkin[a,Gauge[[b,3]]];
SA`MulFactor[conj[a_],b_Integer]:=SA`MulFactor[a,Gauge[[b,3]]];
Generator[conj[a_],b_Integer]:=Generator[a,Gauge[[b,3]]];
SA`DimensionGG[conj[a_],b_]:=SA`DimensionGG[a,b];

CleanUpGaugeConstants:=Block[{i,j,k},
SA`ClebschGordon=Intersection[SA`ClebschGordon];

];


