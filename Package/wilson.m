(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SA`Doc`ToDo="Rename the file. It has nothing to do (anymore) with Wilson coefficients!";

InitDiagramGeneration:=Block[{i,j,k,l,temp,pos},
SA`Doc`File = "Package/wilson.nb";
SA`Doc`Name = "InitDiagramGeneration";
SA`Doc`Info = "This routine initialises the necessary information to be able to generatie Feynman diagrams with SARAH. For this purpose, it creates lists which store what particle combinations do exist. For instance, 'OneKnown' shows all particles a specific particle couples to. In 'TwoKnown' all particles a listed to which a given pair of two particles can couple.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

OneKnown={};
TwoKnown={};
ThreeKnown={};
OneKnownIns={};
TwoKnownIns={};
ThreeKnownIns={};

temp =Join[VertexList3,VertexList4]/. a_[{b__}]->a;


For[i=1,i<=Length[temp],
For[j=1,j<=Length[temp[[i,1]]],
If[FreeQ[OneKnownIns,C[temp[[i,1,j]]]],
OneKnown = Join[OneKnown,{Delete[temp[[i,1]],j]}];
OneKnownIns= Join[OneKnownIns,{C[temp[[i,1,j]]]}];,
pos= Position[OneKnownIns,C[temp[[i,1,j]]],1,1][[1,1]];
OneKnown[[pos]] = Join[OneKnown[[pos]],Delete[temp[[i,1]],j]];
];
For[k=j+1,k<=Length[temp[[i,1]]],
If[FreeQ[TwoKnownIns,C[temp[[i,1,j]],temp[[i,1,k]]]],
TwoKnown = Join[TwoKnown,{Delete[temp[[i,1]],{{j},{k}}]}];
TwoKnownIns= Join[TwoKnownIns,{C[temp[[i,1,j]],temp[[i,1,k]]]}];,
pos= Position[TwoKnownIns,C[temp[[i,1,j]],temp[[i,1,k]]],1,1][[1,1]];
TwoKnown[[pos]] = Join[TwoKnown[[pos]],Delete[temp[[i,1]],{{j},{k}}]];
];
For[l=k+1,l<=Length[temp[[i,1]]],
If[FreeQ[ThreeKnownIns,C[temp[[i,1,j]],temp[[i,1,k]],temp[[i,1,l]]]],
ThreeKnown = Join[ThreeKnown,{Delete[temp[[i,1]],{{j},{k},{l}}]}];
ThreeKnownIns= Join[ThreeKnownIns,{C[temp[[i,1,j]],temp[[i,1,k]],temp[[i,1,l]]]}];,
pos= Position[ThreeKnownIns,C[temp[[i,1,j]],temp[[i,1,k]],temp[[i,1,l]]],1,1][[1,1]];
ThreeKnown[[pos]] = Join[ThreeKnown[[pos]],Delete[temp[[i,1]],{{j},{k},{l}}]];
];
l++;];
k++;];
j++;];
i++;];


OneKnown=Intersection/@OneKnown;
TwoKnown=Intersection/@TwoKnown;
ThreeKnown=Intersection/@ThreeKnown;

SA`Doc`EndEntry[];
];

InsFields[process_]:=Block[{i},
SA`Doc`File = "Package/wilson.nb";
SA`Doc`Name = "InsFields";
SA`Doc`Info = "This routine takes a topology (defined as a list of generic vertices) and populates it with all possible field combinations.";
SA`Doc`Input = {"process"->"Topology of the considered diagram"};
SA`Doc`GenerateEntry[];

DiagramList={};
ListInsertedVertices={};
AddFieldToDiagram[process];
SA`Doc`Return[DiagramList];
];


(* ::Input::Initialization:: *)
AddFieldToDiagram[process_]:=Block[{pos, possFields,i,possFieldsSub, newProcess},
SA`Doc`File = "Package/wilson.nb";
SA`Doc`Name = "AddFieldToDiagram";
SA`Doc`Info = "This routine takes a single Feynman diagram in which not all particles are fixed, but some are still unknown. It creates all valid diagrams by inserting all possible states at one place. This is iterated until all unknown states have been replaced by particles of the model. ";
SA`Doc`Input = {"process"->"Topology of the considered diagram"};
SA`Doc`GenerateEntry[];

currentInsertion = Cases[process,FieldToInsert[_],3,1][[1]];
pos = Position[process[[1]],currentInsertion];
For[i=1,i<=Length[pos],
currentVertex=Extract[process[[1]],pos[[i,1]]];
If[Length[pos[[i]]]==2,
If[i==1,
possFields=getPossibleFields[currentVertex];,
possFields=Intersection[possFields,getPossibleFields[currentVertex]];
];,
If[i==1,
possFields=AntiField/@getPossibleFields[currentVertex];,
possFields=Intersection[possFields,AntiField/@getPossibleFields[currentVertex]];
];
];
i++;];
If[Length[possFields]>0,
possFieldsSub=Flatten[Table[{currentInsertion->possFields[[i]]},{i,1,Length[possFields]}]];
For[i=1,i<=Length[possFieldsSub],
newProcess= process /. possFieldsSub[[i]];
Switch[CheckVertex[newProcess],
Finished,
   
		If[SA`CheckSameVertices===False||FreeQ[ListInsertedVertices,newProcess[[1]]],
		DiagramList = Join[DiagramList,{newProcess}];
		ListInsertedVertices=Join[ListInsertedVertices,{newProcess[[1]]}];
		];,
GoOn,
		AddFieldToDiagram[newProcess];
];
i++];
];
SA`Doc`EndEntry[];
];


(* ::Input::Initialization:: *)
CheckVertex[process_]:=Block[{goOn,i},
SA`Doc`File = "Package/wilson.nb";
SA`Doc`Name = "CheckVertex";
SA`Doc`Info = "This routine checks if all lines in a diagram are populated with existing fields, or if the insertion of fields must continue.";
SA`Doc`Input = {"process"->"The considered diagram"};
SA`Doc`GenerateEntry[];

finishedVertices =Cases[process[[1]],x_?FieldToInsertQ,1];
If[Length[finishedVertices]==0,
SA`Doc`Return[GoOn];,
goOn = True;
 For[i=1,i<=Length[finishedVertices],
If[FreeQ[VerticesInv[All],finishedVertices[[i]]],
goOn=False;
];
i++;]; 
If[goOn==True,
If[Length[finishedVertices]==Length[process[[1]]],
SA`Doc`Return[Finished];,
SA`Doc`Return[GoOn];
];,
SA`Doc`Return[stop];
];
];
];

FieldToInsertQ[x_]:=Return[FreeQ[x,FieldToInsert]];

getPossibleFields[vertex_]:=Block[{temp,pos},
SA`Doc`File = "Package/wilson.nb";
SA`Doc`Name = "getPossibleFields";
SA`Doc`Info = "This routine takes as input a vertex which can involve specific fields of the model as well as placeholders. It returns all possibilities for the placeholders.";
SA`Doc`Input = {"vertex"->"The considered vertex"};
SA`Doc`GenerateEntry[];

temp = DeleteCases[vertex,FieldToInsert[_]];
temp = DeleteCases[temp,AntiField[FieldToInsert[_]]];
Switch[Length[temp],
0,SA`Doc`Return[OneKnownIns /. C->Plus];,
1,
	pos=Position[OneKnownIns,temp,1,1];
	If[pos=!={},SA`Doc`Return[Extract[OneKnown,pos[[1,1]]]];,Return[{}];];,
2,
	pos=Position[TwoKnownIns,temp,1,1];
	If[pos=!={},SA`Doc`Return[Extract[TwoKnown,pos[[1,1]]]];,Return[{}];];,
3,
	pos=Position[ThreeKnownIns,temp,1,1];
	If[pos=!={},SA`Doc`Return[Extract[ThreeKnown,pos[[1,1]]]];,Return[{}];];
];
];


(* ::Input::Initialization:: *)
GenerateBoxDiagrams[f1_,f2_,f3_,f4_]:=Block[{},
SA`Doc`File = "Package/wilson.nb";
SA`Doc`Name = "GenerateBoxDiagrams";
SA`Doc`Info = "This routine generates all one-loop box diagrams for given external states";
SA`Doc`Input={"f1..f4"->"The four external states"};
SA`Doc`GenerateEntry[];

AllBoxDiagrams={};

currentTop={{C[f1,FieldToInsert[1],AntiField[FieldToInsert[4]]],C[f2,AntiField[FieldToInsert[1]],FieldToInsert[2]],C[f3,AntiField[FieldToInsert[2]],FieldToInsert[3]],C[f4,AntiField[FieldToInsert[3]],FieldToInsert[4]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3],Internal[4]->FieldToInsert[4],External[1]->f1,External[2]->f2,External[3]->f3,External[4]->f4,Index[1]->gt1,Index[2]->gt2,Index[3]->gt3,Index[4]->gt4, InsertionOrder ->1}};
AllBoxDiagrams=InsFields[currentTop];


currentTop={{C[f1,FieldToInsert[1],AntiField[FieldToInsert[4]]],C[f2,AntiField[FieldToInsert[1]],FieldToInsert[2]],C[f4,AntiField[FieldToInsert[2]],FieldToInsert[3]],C[f3,AntiField[FieldToInsert[3]],FieldToInsert[4]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3],Internal[4]->FieldToInsert[4],External[1]->f1,External[2]->f2,External[3]->f4,External[4]->f3,Index[1]->gt1,Index[2]->gt2,Index[3]->gt4,Index[4]->gt3, InsertionOrder ->2}};
AllBoxDiagrams=Join[AllBoxDiagrams,InsFields[currentTop]];


currentTop={{C[f1,FieldToInsert[1],AntiField[FieldToInsert[4]]],C[f4,AntiField[FieldToInsert[1]],FieldToInsert[2]],C[f3,AntiField[FieldToInsert[2]],FieldToInsert[3]],C[f2,AntiField[FieldToInsert[3]],FieldToInsert[4]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3],Internal[4]->FieldToInsert[4],External[1]->f1,External[2]->f4,External[3]->f3,External[4]->f2,Index[1]->gt1,Index[2]->gt4,Index[3]->gt3,Index[4]->gt2, InsertionOrder ->3}};
InsFields[currentTop];
AllBoxDiagrams=Join[AllBoxDiagrams,InsFields[currentTop]]; 

currentTop={{C[f1,FieldToInsert[1],AntiField[FieldToInsert[4]]],C[f3,AntiField[FieldToInsert[1]],FieldToInsert[2]],C[f2,AntiField[FieldToInsert[2]],FieldToInsert[3]],C[f4,AntiField[FieldToInsert[3]],FieldToInsert[4]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3],Internal[4]->FieldToInsert[4],External[1]->f1,External[2]->f3,External[3]->f2,External[4]->f4,Index[1]->gt1,Index[2]->gt4,Index[3]->gt3,Index[4]->gt2, InsertionOrder ->4}};
InsFields[currentTop];
AllBoxDiagrams=Join[AllBoxDiagrams,InsFields[currentTop]]; 


SA`Doc`Return[AllBoxDiagrams];
];




(* ::Input::Initialization:: *)
GeneratePenguinDiagrams[f1_,f2_,f3_]:=Block[{},
SA`Doc`File = "Package/wilson.nb";
SA`Doc`Name = "GeneratePenguinDiagrams";
SA`Doc`Info = "This routine generates all one-loop triangle diagrams for given external states";
SA`Doc`Input={"f1..f3"->"The three external states"};
SA`Doc`GenerateEntry[];

currentTop={{C[f1,FieldToInsert[1],AntiField[FieldToInsert[2]]],C[f2,AntiField[FieldToInsert[1]],FieldToInsert[3]],C[f3,AntiField[FieldToInsert[3]],FieldToInsert[2]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3],External[1]->f1,External[2]->f2,External[3]->f3}};
SA`Doc`Return[InsFields[currentTop]];
];
