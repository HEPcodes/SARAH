(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* ------------------------------------------------- *)
(* Calculates all Vertices / Generates a TeX-Output  *)
(* ------------------------------------------------- *)


(* ::Input::Initialization:: *)

Options[ModelOutput]={ SixParticleInteractions->False,effectiveOperators->False, ReadLists->False, WriteTeX-> False, WriteCHep->False,  WriteWHIZARD->False, WriteFeynArts->False, WriteUFO->False, FeynmanDiagrams ->True, IncludeLoopCorrections ->False,IncludeRGEs->False,TwoLoopRGEs->True,VerticesForLoops->False, SimplifySums->True, IncludeVertices->True,Eigenstates->Automatic };

Options[MakeVertexList]={ SixParticleInteractions->False,effectiveOperators->False,VerticesForLoops->False, GenericClasses->All, SimplifySums->True};

Options[MakeAll]={ReadLists->False,IncludeSPheno->True, IncludeFeynArts->True, IncludeCalcHep->True, IncludeTeX->True, IncludeWHIZARD->True, IncludeUFO->True, Eigenstates->Automatic};
MakeAll[opt___]:=MakeAllOutput[ReadLists /. {opt} /. Options[MakeAll],IncludeSPheno /. {opt} /. Options[MakeAll],IncludeFeynArts /. {opt} /. Options[MakeAll],IncludeCalcHep /. {opt} /. Options[MakeAll],IncludeTeX /. {opt} /. Options[MakeAll],IncludeWHIZARD /. {opt} /. Options[MakeAll],IncludeUFO /. {opt} /. Options[MakeAll],
Eigenstates /. {opt} /. Options[MakeAll]];

MakeAllOutput[ReadL_,IncSPheno_,IncFA_, IncCH_, IncTeX_,IncWO_,IncUFO_,ESin_]:=Block[{ES},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "MakeAllOutput";
SA`Doc`Info = "Wrapper function to create all output for other codes (SPheno, FeynArts, UFO, etc.).";
SA`Doc`Input={"ReadL"->"Read previous results?", "IncSPheno"->"Include SPheno Output?","IncFA"->"Include FeynArts output?","IncCH"->"Include CalcHep Output?","IncTeX"->"Include TeX Ouptut?","IncWO"->"Include WHIZARD and Omega output?","IncUFO"->"Include UFO output?","ESin"->"Considered Eigenstates"};
SA`Doc`GenerateEntry[];

Print[StyleForm["Create output for: ","Section",FontSize->14]];
Print[StyleForm[" \[Bullet] SPheno ","Section",FontSize->10]];
Print[StyleForm[" \[Bullet] CalcHep (including MicrOmegas) ","Section",FontSize->10]];
Print[StyleForm[" \[Bullet] WHIZARD/Omega ","Section",FontSize->10]];
Print[StyleForm[" \[Bullet] FeynArts ","Section",FontSize->10]];
Print[StyleForm[" \[Bullet] MadGraph 5 (UFO format) ","Section",FontSize->10]];
Print[StyleForm[" \[Bullet] LaTeX ","Section",FontSize->10]];

(*
Print["************************************************************"];
Print["Starting the output for "];
Print["  - SPheno "];
Print["  - CalcHep (including MicrOmegas) "];
Print["  - WHIZARD/Omega "];
Print["  - FeynArts"];
Print["  - MadGraph 5 (UFO format)"];
Print["************************************************************"];
*)
If[ESin===Automatic, ES=Last[NameOfStates];,ES=ESin;];

SA`CurrentStates=ES;

If[WriteModelDirectories==True,
DirectoryNamesFile=OpenWrite[ToFileName[StartingDirectory,"DirectoryNames.txt"]];
WriteString[DirectoryNamesFile,"SARAHModelName="<>ModelName <>"\n"];
];

If[IncSPheno,MakeSPheno[ReadLists->ReadL];,ModelOutput[ES,ReadLists->ReadL];];
If[IncCH,MakeCHep[Eigenstates ->ES];];
If[IncWO,MakeWHIZARD[Eigenstates ->ES];];
If[IncFA,MakeFeynArts[];];
If[IncTeX,MakeTeX[];];
If[IncUFO,MakeUFO[];];

If[WriteModelDirectories==True,
Close[DirectoryNamesFile];
];

SA`Doc`EndEntry[];
];


ModelOutput[Eigenstates_,opt___ ]:=ModelOutputFunc[Eigenstates, effectiveOperators/.{opt}/.Options[ModelOutput],SixParticleInteractions/.{opt}/.Options[ModelOutput],ReadLists/.{opt}/.Options[ModelOutput], WriteTeX/.{opt}/.Options[ModelOutput],WriteCHep/.{opt}/.Options[ModelOutput],WriteFeynArts/.{opt}/.Options[ModelOutput],WriteUFO/.{opt}/.Options[ModelOutput],FeynmanDiagrams/.{opt}/.Options[ModelOutput],IncludeLoopCorrections/.{opt}/.Options[ModelOutput],IncludeRGEs/.{opt}/.Options[ModelOutput],TwoLoopRGEs/.{opt}/.Options[ModelOutput],VerticesForLoops/.{opt}/.Options[ModelOutput],SimplifySums/.{opt}/.Options[ModelOutput],IncludeVertices/.{opt}/.Options[ModelOutput]];

SA`Doc`ToDo="Remove all references to 6-particle vertices to prevent confusion?";

ModelOutputFunc[Eigenstates_,effOp_, SixP_,ReadL_,WriteTeX_, WriteCHep_, WriteFeynArts_,WriteUFO_, FeynDia_,LoopC_, IncludeRGEs_,TwoLoopRGEs_,VLoop_ , SimplifySUMs_, IncludeVert_]:=Block[{CalcVLoop},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "ModelOutputFunc";
SA`Doc`Info = "This function calculates all vertices in the Lagrangian for the given Eigenstates. Also the model files for other codes could be generated via the given options or the calculation of the RGEs could be truned on. Here and in the following, 6-particle vertices are considered to some extent, but this was never well tested or used in practive. Maybe, it might the best to remove all that until there is a proper implementation of effective theories.";
SA`Doc`Input={"Eigenstates"->"Considered Eigenstates","effOp"->"Include effective operators?","SixP"->"Inclue 6-particle interactions?","ReadL"->"Read previous results?", "IncSPheno"->"Include SPheno Output?","WriteFeynArts"->"Include FeynArts output?","WriteCHep"->"Include CalcHep Output?","WriteTeX"->"Include TeX Ouptut?","WriteUFO"->"Include UFO output?","FeynDia"->"Show Feynman diagrams in LaTeX output?","LoopC"->"Calculate loop corrections?","IncludeRGEs"->"Calcualte RGEs?","TwoLoopRGEs"->"Calculate two-loop RGEs?", "VLoop"->"Calculate loop vertices?","SimplifSUMs"->"Simplify appearing sums in vertices","IncludeVert"->"Include the vertex calculation?"};
SA`Doc`GenerateEntry[];

SA`CurrentStates=Eigenstates;

CheckConsistency[Eigenstates];

massless=Massless[Eigenstates];
InitVertexCalculation[Eigenstates, WriteTeX];
partDefinition=ParticleDefinitions[Eigenstates];
Particles[Current] = Particles[Eigenstates];
CurrentStates = Eigenstates;

If[LoopC==True,
CalcVLoop=True;,
CalcVLoop=VLoop
];

EigenstateName=Eigenstates;

If[IncludeVert ==True,
 If[ReadL==False,
MakeVertexList[Eigenstates, SixParticleInteractions-> SixP,effectiveOperators-> effOp,VerticesForLoops->CalcVLoop, SimplifySums->SimplifySUMs];,
ReadVertexList[Eigenstates,effOp,SixP,CalcVLoop];
]; 
];

MakeDepParList[Eigenstates];

If[LoopC==True,
CalcLoopCorrections[Eigenstates];
];

If[IncludeRGEs==True,
If[TwoLoopRGEs==True,
CalcRGEs[TwoLoop->True, ReadLists->ReadL];,
CalcRGEs[TwoLoop->False, ReadLists->ReadL];
];
];

 If[WriteTeX==True,
MakeTeX[effectiveOperators-> effOp,SixParticleInteractions-> SixP, FeynmanDiagrams-> FeynDia, IncludeVert -> IncludeVertices];
];
 
If[WriteFeynArts == True,
MakeFeynArts[];
];

If[WriteCHep == True,
MakeCHep[];
];

If[WriteUFO == True,
MakeUFO[];
];

SA`Doc`EndEntry[];
];

ITypes={ {SSS,S,S,S}, {SSSS,S,S,S,S}, {SSVV,S,S,V,V}, {SSV,S,S,V}, {SVV,S,V,V}, {GGV,G,G,V}, {GGS,G,G,S}, {FFS,F,F,S}, {FFV,F,F,V},{VVV,V,V,V},{VVVV,V,V,V,V},{ASS,A,S,S}};
ITypesNonRen={ {SSSSSS,S,S,S,S,S,S}, {SSSSVV,S,S,S,S,V,V}, {SSVVVV,S,S,V,V,V,V}, {FFSS,F,F,S,S}, {FFVV,F,F,V,V}, {FFFF,F,F,F,F}};




(* ::Input::Initialization:: *)
InitVertexCalculation[Eigenstates_,WriteTeX_]:=Block[{},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "InitVertexCalculation";
SA`Doc`Info = "Initialises the calculation of all vertices: the necessary directories are created, the necessary information for the given eigenstates is stored in variables with shorter names, all existing scalars, fermions and vector bososn are collected in respective lists (PART[S,F,V]).";
SA`Doc`Input={"Eigenstates"->"Considered Eigenstates","WriteTeX"->"Write LaTeX Output?"};
SA`Doc`GenerateEntry[];

Print["Generate Directories"];

modelName=ToString[Eigenstates];

InitalizedVertexCalculaton=Eigenstates;

If[FileExistsQ[$sarahOutputDir]=!=True,
CreateDirectory[$sarahOutputDir];
];
If[FileExistsQ[$sarahCurrentOutputMainDir]=!=True,
CreateDirectory[$sarahCurrentOutputMainDir];
];

Lag=LagrangianComplete[Eigenstates];
Particles[Current]=Particles[Eigenstates];
MMatrizen=MassMatrices[Eigenstates];
SelfEnergy=SelfEnergies1Loop[Eigenstates];
ParticlesSelfE=ParticlesSelfEnergy1LoopSum[Eigenstates];
TadpolesLoop=Tadpoles1Loop[Eigenstates];
mixings=MixBasis[Eigenstates];
mixedNames=MixMatrix[Eigenstates];
effectiveTheory=IntOut[Eigenstates];
TadEqu=TadpoleEquations[Eigenstates];
UnmixedFields=ListUnmixed[Eigenstates];
SelfEunmixed=SelfEnergyUnmixed[Eigenstates];



$sarahCurrentOutputDir=ToFileName[{$sarahCurrentOutputMainDir,modelName}];
$sarahCurrentTeXDir=ToFileName[{$sarahCurrentOutputDir,"TeX"}];
$sarahCurrentFeynArtsDir=ToFileName[{$sarahCurrentOutputDir,"FeynArts"}];
$sarahCurrentVerticesDir=ToFileName[{$sarahCurrentOutputDir,"Vertices"}];
$sarahCurrentCalcHepDir=ToFileName[{$sarahCurrentOutputDir,"CHep"}];
$sarahDiagrams = ToFileName[{$sarahCurrentTeXDir,"Diagrams"}];


If[FileExistsQ[$sarahCurrentOutputDir]=!=True,
CreateDirectory[$sarahCurrentOutputDir];
];
If[FileExistsQ[$sarahCurrentVerticesDir]=!=True,
CreateDirectory[$sarahCurrentVerticesDir];
];


Print["Building Particle List"];

PART[S]={};
PART[V]={};
PART[F]={};
PART[G]={};
PART[A]={};


diracTemp=diracSub[Eigenstates];

For[i=1,i<=Length[Particles[Current]],
Switch[Particles[Current][[i,4]],
S, PART[S] = Join[PART[S],{{Particles[Current][[i,1]],Particles[Current][[i,3]], Particles[Current][[i,5]],TrueQ[Particles[Current][[i,1]]== conj[Particles[Current][[i,1]]]]}}];,
F, pos=Position[diracTemp,Particles[Current][[i,1]]];
	If[Length[pos]>0,
	PART[F]=Join[PART[F],{{Extract[diracTemp,pos[[1,1]]][[1]],Particles[Current][[i,3]], Particles[Current][[i,5]], MemberQ[MajoranaPart,Particles[Current][[i,1]]/.diracSubBack1[Eigenstates]/. diracSubBack2[Eigenstates]]}}];
	diracTemp=Delete[diracTemp,pos[[1,1]]];
	];,
V, PART[V] = Join[PART[V],{{Particles[Current][[i,1]],Particles[Current][[i,3]], Particles[Current][[i,5]],TrueQ[Particles[Current][[i,1]]== conj[Particles[Current][[i,1]]]]}}];,
G, PART[G] = Join[PART[G],{{Particles[Current][[i,1]],Particles[Current][[i,3]], Particles[Current][[i,5]],TrueQ[Particles[Current][[i,1]]== conj[Particles[Current][[i,1]]]]}}];,
A, PART[A] = Join[PART[A],{{Particles[Current][[i,1]],Particles[Current][[i,3]], Particles[Current][[i,5]],False}}];
];
i++;];


CreateTeXNameList[Eigenstates];

SA`Doc`EndEntry[];
];


(* ::Input::Initialization:: *)


ReadVertexList[ES_,effectiveOperators_,SixP_,VLoop_]:=Block[{i},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "ReadVertexList";
SA`Doc`Info = "Reads the stored vertices from a previous calculation. ";
SA`Doc`Input={"Eigenstates"->"Considered Eigenstates","effectiveOperators"->"Include effective operators?","SixP"->"Inclue 6-particle interactions?","VLoop"->"Include vertices for loop calculations?"};
SA`Doc`GenerateEntry[];

Print["Read Vertex Lists"];
EigenstateName=ES;
VerticesForEigenstates=ES;

For[i=1,i<=Length[ITypes],
SA`VertexList[ITypes[[i,1]]]=Get[ToFileName[$sarahCurrentVerticesDir,"VertexList"<>ToString[ITypes[[i,1]]]<>".m"]];
i++; ];

If[VLoop,
For[i=1,i<=Length[ITypes],
SA`VertexList[sum][ITypes[[i,1]]]=Get[ToFileName[$sarahCurrentVerticesDir,"VertexList"<>ToString[ITypes[[i,1]]]<>"sum.m"]];
i++; ];
VertexListSUMS=Get[ToFileName[$sarahCurrentVerticesDir,"VertexListSUMS.m"]];
];

VertexList3=Get[ToFileName[$sarahCurrentVerticesDir,"VertexList3.m"]];
VertexList4=Get[ToFileName[$sarahCurrentVerticesDir,"VertexList4.m"]];
VertexListNonCC=Get[ToFileName[$sarahCurrentVerticesDir,"VertexListNonCC.m"]];

If[effectiveOperators==True,
For[i=1,i<=Length[ITypesNonRen],
If[SixP==True || Length[ITypesNonRen]<7,
SA`VertexList[ITypesNonRen[[i,1]]]=Get[ToFileName[$sarahCurrentVerticesDir,"VertexList"<>ToString[ITypesNonRen[[i,1]]]<>".m"]];
];
i++;];
];

SA`Doc`EndEntry[];
];


(* ::Input::Initialization:: *)
MakeVertexList[ES_,opt___]:=MakeVertexListFun[ES, effectiveOperators/.{opt}/.Options[MakeVertexList],SixParticleInteractions/.{opt}/.Options[MakeVertexList], VerticesForLoops /.{opt}/.Options[MakeVertexList],SimplifySums /.{opt}/.Options[MakeVertexList],GenericClasses /.{opt}/.Options[MakeVertexList]];

MakeVertexListFun[ES_,effectiveOperators_,SixParticleInteractions_, VerticesForLoops_,SimplifySums_,classes_]:=Block[{s1,s2,s3,s4,s5,s6,fin,iteration,starttime},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "MakeVertexListFun";
SA`Doc`Info = "Main function to check the Lagrangian for existing combinations of fields and calculating the vertices for these combinations. The results are stored in different arrays for the generically different vertices (FFS, SSS, etc.). By default, vertices for all generic classes are calculated, but this could be changed via the options. Also six-particle interactions could be included (HARDLY TESTED!!). \n
Also vertices for loops are calculated. For these vertices some sums involving rotation matrices are not simplified. The reason is that the external particles might be replaced by gauge eigenstates, i.e. the rotation matrix must be replaced by the unit matrix. That's not possible, if the matrix has been disappeared during some simplification. ";
SA`Doc`Input={"ES"->"Considered Eigenstates","effectiveOperators"->"Include effective operators?","SixParticleInteractions"->"Inclue 6-particle interactions?","VerticesForLoops"->"Include vertices for loop calculations?","SimplifSums"->"Simplify appearing sums in vertices?","classes"->"Considered, generic classes"};
SA`Doc`GenerateEntry[];

starttime=TimeUsed[];

If[InitalizedVertexCalculaton=!=ES, 
massless=Massless[ES];
InitVertexCalculation[ES,False]; 
partDefinition=ParticleDefinitions[ES];
Particles[Current] = Particles[ES];
CurrentStates = ES;
];

EigenstateName=ES;

SA`CurrentStates=ES;

(*
Print["-----------------------"];
Print["Calculate All Vertices"];
Print["-----------------------"];
*)
Print[StyleForm["Calculate all vertices","Section",FontSize->12]];

InitAutomaticCalc[ES];

If[VerticesForLoops==True,
sum[a_,b_,c_, conj[M_[a_,x_]] M_[a_,y_]]=.;
sum[a_,b_,c_, conj[M_[x_,a_]] M_[y_,a_]]=.;
UseCheckMatrixProduct=False;
subAlwaysSave = subAlways;
subAlways = DeleteCases[subAlways,x_?((FreeQ[#,sum]==False)&)];

];

iteration=1;

VerticesForEigenstates=ES;
VertexList3={};
VertexList4={};
VertexListNonCC={};

If[effectiveOperators==True,
VertexList4f={};
VertexList6={};


For[i=1,i<=Length[ITypesNonRen],
If[SixP==True || Length[ITypesNonRen]<7,
SA`VertexList[ITypesNonRen[[i,1]]]={};
];
i++;];

(* InitAutomaticCalc[ES]; *)

GenericVertices[FFFF,ES];
GenericVertices[FFSS,ES];
GenericVertices[FFVV,ES];

If[SixP==True,
GenericVertices[SSSSSS,ES];
GenericVertices[SSSSVV,ES];
GenericVertices[SSVVVV,ES];
];
];



For[i=1,i<=Length[ITypes],
SA`VertexList[temp][ITypes[[i,1]]]={};
i++;];




Switch[classes,
All,
	GenericVertices[SSS,ES];
	GenericVertices[SSSS,ES];
	GenericVertices[SSV,ES];
	GenericVertices[SVV,ES];
	GenericVertices[SSVV,ES];
	GenericVertices[VVV,ES];
	GenericVertices[FFS,ES];
	GenericVertices[FFV,ES];
	GenericVertices[VVVV,ES];
	GenericVertices[GGV,ES];
	GenericVertices[GGS,ES];
	GenericVertices[ASS,ES];,
_, 
	GenericVertices[classes,ES]; 
];

subVacuum=Flatten[Map[vacHead,vacuum]];
diaNr=0;

Print[""];
Print["Simplify Vertices"];

If[effectiveOperators==True,
For[i=1,i<=Length[ITypesNonRen],
If[SixP==True || Length[ITypesNonRen]<7,
Put[SA`VertexList[ITypesNonRen[[i,1]]],ToFileName[$sarahCurrentVerticesDir,"VertexList"<>ToString[ITypesNonRen[[i,1]]]<>".m"]];
];
i++;];
];

If[VerticesForLoops,
VertexListSUMS==VertexListNonCCtemp /. sum->sumExp;

For[i=1,i<=Length[ITypes],
SA`VertexList[sum][ITypes[[i,1]]]=SA`VertexList[temp][ITypes[[i,1]]] /. sum -> sumExp;
i++;];

If[SimplifySums==True,
sum[a_,b_,c_, conj[M_[a_,x_]] M_[a_,y_]]:=Delta[x,y] /; getDim[M]==c && b==1;
sum[a_,b_,c_, conj[M_[x_,a_]] M_[y_,a_]]:=Delta[x,y] /; getDim[M]==c && b==1;,
CheckMatrixProduct2[x_]:=Return[x];
];
subAlways = subAlwaysSave;
UseCheckMatrixProduct=True;

For[i=1,i<=Length[ITypes],
If[DONOTSIMPLIFY===True,
SA`VertexList[ITypes[[i,1]]]=SA`VertexList[temp][ITypes[[i,1]]] /. subAlways;,
SA`VertexList[ITypes[[i,1]]]=Simplify/@CheckMatrixProduct2[SA`VertexList[temp][ITypes[[i,1]]] /. subAlways];
];
i++;];
If[DONOTSIMPLIFY===True,
VertexList3=VertexList3/.subAlways;
VertexList4=VertexList4/. subAlways;
VertexListNonCC=VertexListNonCC /. subAlways;,
VertexList3=Simplify/@CheckMatrixProduct2[VertexList3/.subAlways];
VertexList4=Simplify/@CheckMatrixProduct2[VertexList4/. subAlways];
VertexListNonCC=Simplify/@CheckMatrixProduct2[VertexListNonCC /. subAlways];
];,

For[i=1,i<=Length[ITypes],
SA`VertexList[ITypes[[i,1]]]=SA`VertexList[temp][ITypes[[i,1]]];
i++;];

];

Print["Writing vertices to files"];

For[i=1,i<=Length[ITypes],
Put[SA`VertexList[ITypes[[i,1]]],ToFileName[$sarahCurrentVerticesDir,"VertexList"<>ToString[ITypes[[i,1]]]<>".m"]];
i++;];

Put[VertexList3,ToFileName[$sarahCurrentVerticesDir,"VertexList3.m"]];
Put[VertexList4,ToFileName[$sarahCurrentVerticesDir,"VertexList4.m"]];
Put[VertexListNonCC,ToFileName[$sarahCurrentVerticesDir,"VertexListNonCC.m"]];

If[VerticesForLoops,
For[i=1,i<=Length[ITypes],
Put[VertexListSUMS,ToFileName[$sarahCurrentVerticesDir,"VertexListSUMS.m"]];
Put[SA`VertexList[sum][ITypes[[i,1]]],ToFileName[$sarahCurrentVerticesDir,"VertexList"<>ToString[ITypes[[i,1]]]<>"sum.m"]];
i++;];
];

Print["All vertices calculated. (Time needed: ",TimeUsed[]-starttime,"s)"];
Print["The vertices are saved in ",StyleForm[ToString[$sarahCurrentVerticesDir ],"Section",FontSize->10]];

SA`Doc`EndEntry[];
];


InitAutomaticCalc[ES_]:=Block[{},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "InitAutomaticCalc";
SA`Doc`Info = "This function initialises some lists and substitutions to extract the existing vertices. The substitution 'subNonFields' is used to get a simpler Lagrangian where only pure fields show up. This can then be used to extract all existing field combinations which might lead to a vertex. Moreover, the necessary parts of the Lagrangian are stored in new variables which are accesible from the generic type of the considered interaction, e.g. Lag[SSV][ES] or Lag[FFS][ES].";
SA`Doc`Input={"ES"->"Considered eigenstates"};
SA`Doc`GenerateEntry[];

(* subNonFields = {sum[a_,b_,c_]\[Rule]1,  Delta[a_,b_]\[Rule]1,epsTensor[a__]\[Rule]1, g[a__]\[Rule]1, Sig[a__]\[Rule]1,Lam[a__]\[Rule]1, Mom[a_,b_]\[Rule]1, T[a_]\[Rule] 1, B[a_]\[Rule]1, L[a_]\[Rule]1,gamma[a_]\[Rule]1 ,fSU2[a__]\[Rule]1, fSU3[a__]\[Rule]1, pmue[a__]\[Rule]a,RXi[a__]\[Rule]1, Mass[x_]\[Rule]1,Inv[a__][b__]\[Rule]1};  *)
subNonFields = {sum[a_,b_,c_]->1,  Delta[a_,b_]:>Random[],epsTensor[a__]:>Random[], g[a__]->1, Sig[a__]:>Random[],Lam[a__]:>Random[], Mom[a_,b_]:>Random[], T[a_]-> 1, B[a_]->1, L[a_]->1,gamma[a_]:>Random[] ,fSU2[a__]->1, fSU3[a__]->1, fSU4[a__]->1,pmue[a__]->a,RXi[a__]->1, Mass[x_]->1,Inv[a__][b__]->1,Generator[a__][b__]:>Random[], CG[a__][b__]:>Random[], FST[a__][b__]:>Random[], TA[a__]:>Random[], LorentzProduct[a___]:>Random[]}; 
subPar=Flatten[{T[a___]->1, B[a__]->1,L[a___]->1,Table[parameters[[i,1]][b__][a__]->Random[],{i,1,Length[parameters]}],Table[parameters[[i,1]][a__]->Random[],{i,1,Length[parameters]}],Table[parameters[[i,1]]->1,{i,1,Length[parameters]}]}] /. conj[x_]->x;


subGeneric[FFV]={a_[b_?IntegerQ]->a};
subGeneric[FFS]={a_[b_?IntegerQ]->a};
subGeneric[FF]={a_[b_?IntegerQ]->a};
subGeneric[SSV]={};
subGeneric[SVV]={};
subGeneric[SSVV]={};
subGeneric[SSSS]={};
subGeneric[SSSSSS]={};
subGeneric[SSSSVV]={};
subGeneric[SSVVVV]={};
subGeneric[SSS]={};
subGeneric[SS]={};
subGeneric[GGS]={};
subGeneric[GGV]={};
subGeneric[VVVV]={};
subGeneric[VVV]={};
subGeneric[ASS]={};
subGeneric[FFSS]={a_[b_?IntegerQ]->a};
subGeneric[FFFF]={a_[b_?IntegerQ]->a};
subGeneric[FFVV]={a_[b_?IntegerQ]->a};

LAG[SSV][ES]=LagSV[ES];
LAG[SSVV][ES]=LagSV[ES];
LAG[SVV][ES]=LagSV[ES];
LAG[FFV][ES]=LagFFV[ES];
LAG[FFS][ES]=LagFFS[ES];
LAG[FF][ES]=LagFFS[ES];
LAG[SSSS][ES]=LagSSSS[ES];
LAG[SSS][ES]=LagSSSS[ES];
LAG[SS][ES]=LagSSSS[ES];
LAG[VVV][ES]=LagVVV[ES];
LAG[VVVV][ES]=LagVVVV[ES];
LAG[GGV][ES]=LagGGV[ES];
LAG[GGS][ES]=LagGGS[ES];
LAG[ASS][ES]=LagSSA[ES];
LAG[FFFF][ES]=LagFFFF[ES];
LAG[FFSS][ES]=LagFFSS[ES];
LAG[SSSSSS][ES]=LagSSSSSS[ES];
LAG[SSSSVV][ES]=LagSSSSVV[ES];
LAG[SSVVVV][ES]=LagSSVVVV[ES];
LAG[FFVV][ES]=LagFFVV[ES];

Cp[a___,Power[b_,x_],c___]:=Nest[Append[#1,b]&,Cp[a,c],x];
COUP[a__ b_?NumericQ]=COUP[a];
COUP[ b_?NumericQ]=1;

SA`Doc`EndEntry[];
];

SortCoup[x_]:=List@@C@@Map[getTypeSort[#1][#1]&,x] /. {Fb[y_]->y,Szc[y_]->y,Vc[y_]->y,Gb[y_]->y,Ab[y_]->y,Fn[y_]->y,Fm[y_]->y,Sn[y_]->y,Vn[y_]->y,Gn[y_]->y, An[y_]->y};

getTypeSort[x_]:=Switch[getType[x],
F,
	If[Head[x]===bar, Return[Fb];,
	If[bar[x]===x,
	Return[Fm];,
	Return[Fn]];
	];,
S,
	If[Head[x]===conj, Return[Szc];,Return[Sn]];,
V,
	If[Head[x]===conj, Return[Vc];,Return[Vn]];,
G,
	If[Head[x]===bar, Return[Gb];,Return[Gn]];,
A,
	If[Head[x]===conj, Return[Ab];,Return[An]];
];

GenericVertices[Type_,Eigenstates_]:=Block[{i,list,nonCC={},res,all={},startedtime},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "GenericVertices";
SA`Doc`Info = "This function calculates all vertices of a given, generic type. For this purpose, it first generates a toy version of the Lagrangian cotaining only fields to check which field combinations in principle show up. ";
SA`Doc`Input={"Type"->"Generic type of vertices","ES"->"Considered eigenstates"};
SA`Doc`GenerateEntry[];

Switch[Type,
SSS,
      Print[StyleForm["      Three Scalar - Interactions","Section",FontSize->12]];,
SSV,
      Print[StyleForm["      Two Scalar - One Vector Boson - Interactions","Section",FontSize->12]];,
SVV,
      Print[StyleForm["      One Scalar - Two Vector Boson - Interactions","Section",FontSize->12]];,
SSSS,
      Print[StyleForm["      Four Scalar - Interactions","Section",FontSize->12]];,
SSVV,
      Print[StyleForm["      Two Scalar - Two Vector Boson - Interactions","Section",FontSize->12]];,
FFS,
      Print[StyleForm["      Two Fermion - One Scalar - Interactions","Section",FontSize->12]];,
FFV,
      Print[StyleForm["      Two Fermion - One Vector Boson - Interactions","Section",FontSize->12]];,
VVV,
      Print[StyleForm["      Three Vector Boson - Interactions","Section",FontSize->12]];,
VVVV,
      Print[StyleForm["      Four Vector Boson - Interactions","Section",FontSize->12]];,
GGS,
      Print[StyleForm["      Two Ghost - One Scalar - Interactions","Section",FontSize->12]];,
GGV,
      Print[StyleForm["      Two Ghost - One Vector Boson - Interactions","Section",FontSize->12]];,
ASS,
      Print[StyleForm["      Two Scalar - One Auxiliary - Interactions","Section",FontSize->12]];,
FFSS,
      Print[StyleForm["      Two Femrion - Two Scalar - Interactions","Section",FontSize->12]];,
FFFF,
      Print[StyleForm["      Four Fermion - Interactions","Section",FontSize->12]];,
FFVV,
      Print[StyleForm["      Two Fermion - Two Vector Boson - Interactions","Section",FontSize->12]];

];

startedtime=TimeUsed[];

If[Head[VertexListNonCC]=!=List,VertexListNonCC={};];
If[AtomQ[LAG[Type][Eigenstates] ]=!=True,
If[((List@@Expand[LAG[Type][Eigenstates] /.subNonFields  /. subGeneric[Type]/.subPar ]  )/.subPar /.A_[{x__}]->A )===0,
SA`VertexList[temp][Type]={};,

SA`VertexList[temp][Type]={};

list=Intersection[Select[Intersection[COUP/@((List@@Expand[LAG[Type][Eigenstates] +1/.subNonFields /.subPar  ]/. subGeneric[Type]/. diracSubBack[Eigenstates]  )/.subPar /.A_[{x__}]->A ) /. COUP -> Cp ] /. Cp[x_Times]:>Cp@@x /. conj -> AntiField /. Cp->C /. C -> List ,(VType@@getType/@#1===Type)&]];

If[FastVertexCalculation===True,
list=Select[list,Plus@@(getElectricCharge/@(List@@#))==0&];
];

list = SortCoup/@list;
SA`listSave=list;

If[Type===SVV,
list=Select[list,(Count[#,VP]<2)&];
];

timestamp=StringJoin[ToString/@Date[]];
progressNrGV[Type]=0;
progressCurrentGV[Type]={A,B,C};
Print["     Found ",Length[list]," potential vertices. Calculating ",Dynamic[progressNrGV[Type]] ,"/",Length[list]". (",Dynamic[progressCurrentGV[Type]],")"];
If[PrintDebugInformation,Print[Length[list],"  ",list]];

For[i=1,i<=Length[list],
progressNrGV[Type]=i;
progressCurrentGV[Type]=list[[i]];
If[PrintDebugInformation,Print[i,"  ",list[[i]]]];
res=Vertex[list[[i]]];
If[Type===FFV || Type ===SSV || Type ===SVV  || Type ===SSVV,
If[Select[Simplify/@(Table[res[[j,1]],{j,2,Length[res]}] /. subDependences),(#1=!=0)&]=!={},
SA`VertexList[temp][Type]=Join[SA`VertexList[temp][Type],{res}];
If[Type===FFV || Type === SSV || Type ===SVV || Type ===VVV || Type ===FFS || Type ===GGS || Type ===GGV || Type ===VVV || Type ===SSS,
VertexList3 = Join[VertexList3,{res}];,
If[Type===SSVV || Type ===SSSS || Type ===VVVV,
VertexList4 = Join[VertexList4,{res}];
];
];

all=Join[all,{list[[i]]}];
If[Plus@@(getElectricCharge/@(list[[i]]))=!=0, If[NumberQ[Plus@@(getElectricCharge/@(list[[i]]))],Message[Vertex::ChargeViolating,list[[i]]];];];
If[FreeQ[nonCC,Cp[AntiField/@list[[i]]]],
VertexListNonCC = Join[VertexListNonCC,{{res,Type}}];
];
];,
If[Select[(Table[res[[j,1]],{j,2,Length[res]}] /. subDependences),(#1=!=0)&]=!={},
SA`VertexList[temp][Type]=Join[SA`VertexList[temp][Type],{res}];
If[Type===FFV || Type === SSV || Type ===SVV || Type ===VVV || Type ===FFS || Type ===GGS || Type ===GGV || Type ===VVV || Type ===SSS,
VertexList3 = Join[VertexList3,{res}];,
If[Type===SSVV || Type ===SSSS || Type ===VVVV,
VertexList4 = Join[VertexList4,{res}];
];
];

all=Join[all,{list[[i]]}];
If[Plus@@(getElectricCharge/@(list[[i]]))=!=0, If[NumberQ[Plus@@(getElectricCharge/@(list[[i]]))],Message[Vertex::ChargeViolating,list[[i]]];];];
If[FreeQ[nonCC,Cp[AntiField/@list[[i]]]],
VertexListNonCC = Join[VertexListNonCC,{{res,Type}}];
];
];
];
i++;];
progressCurrentGV[Type]="All done in "<>ToString[TimeUsed[]-startedtime]<>"s; "<>ToString[Length[SA`VertexList[temp][Type]]]<>" are non-vanishing";
];,
SA`VertexList[temp][Type]={};
];

SA`Doc`EndEntry[];
];

CheckPossible[p_,list_]:=Block[{i,t1,t2,poss=True,pos,k},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "CheckPossible";
SA`Doc`Info = "";
SA`Doc`GenerateEntry[];

t1=CountFields[p];
t2=CountFields/@list;
c1 = Complement[t1,#1]&/@t2;
c2 = AntiField/@Complement[#1,t1]&/@t2;
pos=Position[(c1-c2),{0}];

If[FreeQ[Table[Length[c1[[pos[[k]]]]],{k,1,Length[pos]}],1],
SA`Doc`Return[True];,
SA`Doc`Return[False];
];
];

CountFields[x_]:=Block[{},
Do[Set[n[vacuum[[i]]],0],{i,1,Length[vacuum]}];
Return[x/. subCount];
];


MakeFlavorKitOutput[Eigenstates_]:=Block[{},
SA`Doc`File = "Package/deriveModel.nb";
SA`Doc`Name = "MakeFlavorKitOutput";
SA`Doc`Info = "Writes the FlavorKit Output independently from the SPheno output.";
SA`Doc`Input={"ES"->"Considered eigenstates"};
SA`Doc`GenerateEntry[];

SPhenoParameters = parameters;
MakeSPhenoFortran;
SPheno`Eigenstates=Eigenstates;
$sarahCurrentSPhenoDir=ToFileName[{$sarahCurrentOutputDir,"SPheno"}];
CreateTeXForm;
MakeCouplingLists;
ListOfLowEnergyNames={};

AllRelevant=getAllRelevantCouplings[VertexListNonCC];
temp=SPhenoCouplingList[AllRelevant];
SPhenoCouplingsAll=temp[[1]];
parametersAll=temp[[2]];
namesAll=temp[[3]];

Print["Checking For PreSARAH"];
Get[ToFileName[$sarahSPhenoPackageDir,"SPhenoPreSARAH.m"]];
CheckForPreSARAH;

(* First, the FlavorKit observables *)
sphenoFlavorKitLFV=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"FlavorKit_LFV_"<>ModelName<>".f90"]];
sphenoFlavorKitQFV=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"FlavorKit_QFV_"<>ModelName<>".f90"]];
sphenoFlavorKitObs=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"FlavorKit_Observables_"<>ModelName<>".f90"]];
GeneratePreSARAHObservables["LFV",sphenoFlavorKitLFV];
GeneratePreSARAHObservables["QFV",sphenoFlavorKitQFV];
Close[sphenoFlavorKitLFV];
Close[sphenoFlavorKitQFV];
Close[sphenoFlavorKitObs];

SA`Doc`EndEntry[];
];






(* ::Input::Initialization:: *)




