(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
GenerateUnitarityConstraints:=Block[{},


(*
(* remove Goldstones everywhere ? *)
UnitarityWithoutGoldstones=True;
*)
Print[StyleForm["Write routines to calcualte tree-level unitarity constraints","Section",FontSize->12]];

sphenoUni=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"Unitarity_"<>ModelName<>".f90"]];

WriteCopyRight[sphenoUni];

WriteString[sphenoUni,"Module Unitarity_"<>ModelName<>" \n \n"];
WriteString[sphenoUni, "Use Control \n"];
WriteString[sphenoUni, "Use Settings \n"];
WriteString[sphenoUni, "Use LoopFunctions \n"];
WriteString[sphenoUni, "Use Mathematics \n"];
WriteString[sphenoUni, "Use Model_Data_"<>ModelName<>" \n"];
WriteString[sphenoUni, "Use RGEs_"<>ModelName<>" \n"];
WriteString[sphenoUni, "Use LoopMasses_"<>ModelName<>" \n"];
WriteString[sphenoUni, "Use TreeLevelMasses_"<>ModelName<>" \n"];
WriteString[sphenoUni, "Use Couplings_"<>ModelName<>" \n"];
WriteString[sphenoUni,"Use Tadpoles_"<>ModelName<>" \n "];


WriteString[sphenoUni, "Use StandardModel \n \n"];

WriteString[sphenoUni,"Logical :: IncludeGoldstoneContributions=.true. \n"];
WriteString[sphenoUni,"Logical :: IncludeGoldstoneExternal=.true. \n"];
(*
WriteString[sphenoUni,"Logical :: IncludeVectorContributions=.false. \n"];
WriteString[sphenoUni,"Logical :: Ignore_TUpoles_Dieter=.true. \n"];
WriteString[sphenoUni,"Logical :: Ignore_TUpoles_Mine=.false. \n"];
WriteString[sphenoUni,"Logical :: Ignore_Spoles=.false. \n"];
WriteString[sphenoUni,"Logical :: Ignore_Tpoles=.false. \n"];
WriteString[sphenoUni,"Logical :: Ignore_Upoles=.false. \n"];
WriteString[sphenoUni,"Logical :: Hard_Cut_Poles=.false. \n"];
*)
WriteString[sphenoUni,"Logical :: AddR=.true. \n"];
WriteString[sphenoUni,"Real(dp) :: cut_elements = 0.0001_dp \n"];
WriteString[sphenoUni,"Real(dp) :: cut_amplitudes = 0.01_dp \n"];

WriteString[sphenoUni,"Logical :: Ignore_poles=.false. \n \n"];

WriteString[sphenoUni, "Contains \n\n"];

GenerateTreeLevelUni;
WriteUnitarityFull;
WriteIntegrals;



WriteString[sphenoUni,"End Module Unitarity_"<>ModelName<>" \n"];
Close[sphenoUni];


];


WriteUnitarityFull:=Block[{i},
(* get all scalars (inlcuding the complex conjugated ones) *)
partS=Transpose[PART[S]][[1]];
partS=Select[partS,FreeQ[getIndizes[#],color]&];
partS=Select[partS,FreeQ[RemoveParticlesFromScattering,#]&];

partS=Intersection[Join[partS,conj/@partS]];

partV=Transpose[PART[V]][[1]];
partV=Intersection[Join[partV,conj/@partV]];

(*
(* 3- and 4- tuples => to get vertices *)
tup3=Intersection[Sort/@Tuples[partS,{3}]];
tup3=Select[tup3,Plus@@(getElectricCharge/@#)\[Equal]0&];
tup4=Intersection[Sort/@Tuples[partS,{4}]];
tup4=Select[tup4,Plus@@(getElectricCharge/@#)\[Equal]0&];

tup3V=Intersection[Sort/@Tuples[Join[partS,partV],{3}]];
tup3V=Select[tup3V,Count[getType/@#,S]\[Equal]2&];
tup3V=Select[tup3V,Plus@@(getElectricCharge/@#)\[Equal]0&];

vertexlist3=getVertices[tup3,approx];
vertexlist3V=getVertices[tup3V,approx];
vertexlist4=getVertices[tup4,approx];
*)
scattering22=Select[Intersection[Tuples[partS,{4}] /. {a_,b_,c_,d_}:>{Sort[{a,b}],Sort[{c,d}]}],Plus@@(getElectricCharge/@#[[1]])===-Plus@@(getElectricCharge/@#[[2]])&];
(* get all pairs for initial/final states *)
scatteringPairs=Intersection[Tuples[partS,{2}]/. {a_,b_}:>Sort[{a,b}]] ;

differentCharges=Intersection[Map[getElectricCharge[#]&,scatteringPairs,{2}] /.{a_?NumericQ,b_?NumericQ}->a+b];

scatteringPairsCharges={};
For[i=1,i<=Length[differentCharges],
If[differentCharges[[i]]>=0, (* the results for negative charges should be the same *)
scatteringPairsCharges=Join[scatteringPairsCharges,{{differentCharges[[i]],Select[scatteringPairs,Plus@@(getElectricCharge/@#)==differentCharges[[i]]&]}}];
];
i++;];


GenerateTreeLevelUniWithTrilinears;

];

GenerateTreeLevelUniWithTrilinears:=Block[{i,j,k,dim,x1,x2,row,column,x2start,x3,x4,x4start,x1start,x3start,pF1,pF2},

Print["  Write 'Tree-Level Unitarity Limits including trilinear couplings'"];

MakeSubroutineTitle["ScatteringEigenvaluesWithTrilinears",Flatten[{Map[ToExpression[SPhenoForm[#]<>"input"]&,Join[listVEVs,listAllParameters]]}],{} ,{"delta0","kont"},sphenoUni];

WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni, "Integer, Intent(inout) :: kont \n"];
WriteString[sphenoUni, "Integer :: ierr \n"];
WriteString[sphenoUni, "Logical :: Pole_Present, SPole_Present, TPole_Present, UPole_Present \n"];
WriteString[sphenoUni, "Integer :: RemoveTUpoles(99) \n"]; 
MakeVariableList[listAllParameters,"",sphenoUni];
MakeVariableList[listVEVs,"",sphenoUni];
MakeVariableList[namesAllreallyAll,"",sphenoUni];
MakeVariableList[NewMassParameters,"",sphenoUni];
MakeVariableList[Map[ToExpression[SPhenoForm[#]<>"input"]&,listAllParametersAndVEVs],",Intent(in)",sphenoUni];

For[i=1,i<=Length[scatteringPairsCharges],
(*
If[UnitarityWithoutGoldstones===True,
dim =Plus@@(scatteringPairsCharges[[i,2]] /. {a_,b_}\[RuleDelayed]If[a===b,(getGen[a]-getGenSPhenoStart[a]+1)^2-((getGen[a]-getGenSPhenoStart[a]+1)^2-(getGen[a]-getGenSPhenoStart[a]+1))/2,(getGen[a]-getGenSPhenoStart[a]+1)*(getGen[b]-getGenSPhenoStart[b]+1)]/;Head[a]=!=List && Head[b]=!=List);,
dim =Plus@@(scatteringPairsCharges[[i,2]] /. {a_,b_}\[RuleDelayed]If[a===b,(getGen[a])^2-((getGen[a])^2-(getGen[a]))/2,(getGen[a])*(getGen[b])]/;Head[a]=!=List && Head[b]=!=List);
];
*)
dim =Plus@@(scatteringPairsCharges[[i,2]] /. {a_,b_}:>If[a===b,(getGen[a])^2-((getGen[a])^2-(getGen[a]))/2,(getGen[a])*(getGen[b])]/;Head[a]=!=List && Head[b]=!=List);
sdim[i]=dim;

If[dim>1,
WriteString[sphenoUni, "Complex(dp) :: scatter_matrix"<>ToString[i]<>"("<>ToString[dim]<>","<>ToString[dim]<>") \n"]; 
WriteString[sphenoUni, "Complex(dp) :: scatter_matrix"<>ToString[i]<>"B("<>ToString[dim]<>","<>ToString[dim]<>") \n"]; 
WriteString[sphenoUni, "Complex(dp) :: rot_matrix"<>ToString[i]<>"("<>ToString[dim]<>","<>ToString[dim]<>") \n"]; 
WriteString[sphenoUni, "Real(dp) :: eigenvalues_matrix"<>ToString[i]<>"("<>ToString[dim]<>")\n"]; 
];
i++;];
WriteString[sphenoUni, "Real(dp) :: step_size,scattering_eigenvalue_trilinears, unitarity_s, test(2) \n"]; 
WriteString[sphenoUni,"Real(dp) :: gD("<>ToString[numberAllwithVEVs]<>") \n"];
WriteString[sphenoUni, "Real(dp) :: tz,dt,q,q2,mudim, max_element_removed  \n"];
WriteString[sphenoUni, "Real(dp), Intent(in) :: delta0 \n"];
WriteString[sphenoUni, "Integer :: iter, i, count \n"]; 

If[OnlyLowEnergySPheno===True,

For[i=1,i<=Length[listAllParametersAndVEVs],
WriteString[sphenoUni,SPhenoForm[listAllParametersAndVEVs[[i]]]<>" = "<>SPhenoForm[listAllParametersAndVEVs[[i]]]<>"input \n"];
i++;];

MakeCall["TreeMasses",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{".True.","kont"},sphenoUni];
MakeCall["AllCouplingsReallyAll",Flatten[{parametersAllreallyAll,namesAllreallyAll}],{},{},sphenoUni];
];

WriteString[sphenoUni, "max_scattering_eigenvalue_trilinears = 0._dp \n"];


 

WriteString[sphenoUni, "If (unitarity_steps.eq.1) Then  \n"]; 
WriteString[sphenoUni, "  step_size = 0._dp\n"]; 
WriteString[sphenoUni, "Else  \n"]; 
WriteString[sphenoUni, " If (unitarity_steps.gt.0) Then \n"]; 
WriteString[sphenoUni, "  step_size = ((Abs(unitarity_s_max)) -(abs(unitarity_s_min)))/(1._dp*(Abs(unitarity_steps)-1)) \n"]; 
WriteString[sphenoUni, " Else \n"]; 
WriteString[sphenoUni, "  step_size = (log(Abs(unitarity_s_max)) -log(abs(unitarity_s_min)))/(1._dp*(Abs(unitarity_steps)-1)) \n"]; 
WriteString[sphenoUni, " End if \n"]; 
WriteString[sphenoUni, "End if \n"]; 

WriteString[sphenoUni, "Do iter=0,Abs(unitarity_steps)-1 \n"]; 
WriteString[sphenoUni, "If (unitarity_steps.lt.0) Then \n"]; 
WriteString[sphenoUni,"  unitarity_s=exp(log(unitarity_s_min) + iter*step_size)**2 \n"];
WriteString[sphenoUni, "Else \n"]; 
WriteString[sphenoUni,"  unitarity_s=(unitarity_s_min + iter*step_size)**2 \n"];
WriteString[sphenoUni, "End if \n"]; 



If[OnlyLowEnergySPheno=!=True,

For[i=1,i<=Length[listAllParametersAndVEVs],
WriteString[sphenoUni,SPhenoForm[listAllParametersAndVEVs[[i]]]<>" = "<>SPhenoForm[listAllParametersAndVEVs[[i]]]<>"input \n"];
i++;];

WriteString[sphenoUni, "If (RunRGEs_unitarity) Then  \n"]; 
WriteGUTnormalization[sphenoUni];
MakeCall["ParametersToG"<>ToString[numberAllwithVEVs],listAllParametersAndVEVs,{},{"gD"},sphenoUni];
WriteString[sphenoUni,"mudim=GetRenormalizationScale() \n"];
WriteString[sphenoUni,"tz=0.5_dp*Log(mudim/unitarity_s)\n"];
WriteString[sphenoUni,"dt=-tz/50._dp\n"];
WriteString[sphenoUni,"Call odeint(gD,"<>ToString[numberAllwithVEVs]<>",tz,0._dp,0.1_dp*delta0,dt,0._dp,rge"<>ToString[numberAllwithVEVs]<>",kont)\n"];
MakeCall["GToParameters"<>ToString[numberAllwithVEVs],listAllParametersAndVEVs,{"gD"},{},sphenoUni];
WriteRemoveGUTnormalization[sphenoUni];
WriteTadpoleSolutionOnlyHigh[sphenoUni];
WriteString[sphenoUni, "End if \n"]; 


MakeCall["TreeMasses",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{".True.","kont"},sphenoUni];
MakeCall["AllCouplingsReallyAll",Flatten[{parametersAllreallyAll,namesAllreallyAll}],{},{},sphenoUni];
];



For[k=1,k<=Length[scatteringPairsCharges],
WriteString[sphenoUni,"!! "<>ToString[k]<>". sub-matrix  \n"];
(*
WriteString[sphenoUni,"SPole_Present = .false. \n"];
WriteString[sphenoUni,"TPole_Present = .false. \n"];
WriteString[sphenoUni,"UPole_Present = .false. \n"];
*)
WriteString[sphenoUni,"Pole_Present = .false. \n"];
WriteString[sphenoUni,"max_element_removed = 0._dp \n"];

WriteString[sphenoUni,"RemoveTUpoles = 0 \n"];
If[sdim[k]>1,
WriteString[sphenoUni,"scatter_matrix"<>ToString[k]<>"=0._dp \n"];
];

row=1;
For[i=1,i<=Length[scatteringPairsCharges[[k,2]]],
x1start=1;
(* If[UnitarityWithoutGoldstones===True,x1start=getGenSPhenoStart[scatteringPairsCharges[[k,2,i,1]]];]; *)
For[x1=x1start,x1<=getGen[scatteringPairsCharges[[k,2,i,1]]],
x2start=1;
(* If[UnitarityWithoutGoldstones===True,x2start=getGenSPhenoStart[scatteringPairsCharges[[k,2,i,2]]];]; *)
If[scatteringPairsCharges[[k,2,i,1]]===scatteringPairsCharges[[k,2,i,2]],x2start=x1;];
For[x2=x2start,x2<=getGen[scatteringPairsCharges[[k,2,i,2]]],
column=1;
For[j=1,j<=Length[scatteringPairsCharges[[k,2]]],
x3start=1;
(* If[UnitarityWithoutGoldstones===True,x3start=getGenSPhenoStart[scatteringPairsCharges[[k,2,j,1]]];]; *)
For[x3=x3start,x3<=getGen[scatteringPairsCharges[[k,2,j,1]]],
x4start=1;
(* If[UnitarityWithoutGoldstones===True,x4start=getGenSPhenoStart[scatteringPairsCharges[[k,2,j,2]]];]; *)
If[scatteringPairsCharges[[k,2,j,1]]===scatteringPairsCharges[[k,2,j,2]],x4start=x3;];
For[x4=x4start,x4<=getGen[scatteringPairsCharges[[k,2,j,2]]],
If[FreeQ[scattering22,{scatteringPairsCharges[[k,2,i]],Sort[AntiField/@scatteringPairsCharges[[k,2,j]]]}],
(* WriteString[sphenoUni,"scatter_matrix"<>ToString[k]<>"("<>ToString[row]<>","<>ToString[column]<>") = 0._dp \n"]; *)nix;,
pF1=Sort[AntiField/@scatteringPairsCharges[[k,2,j]]][[1]];
pF2=Sort[AntiField/@scatteringPairsCharges[[k,2,j]]][[2]];
If[sdim[k]>1,
WriteString[sphenoUni,addcheckGoldstones[scatteringPairsCharges[[k,2,i]],scatteringPairsCharges[[k,2,i]],x1,x2,x3,x4]<>"scatter_matrix"<>ToString[k]<>"("<>ToString[row]<>","<>ToString[column]<>") = a0_"<>SPhenoForm[scatteringPairsCharges[[k,2,i,1]]/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[scatteringPairsCharges[[k,2,i,2]]/.conj[x_]:>SPhenoForm[x]<>"c"]<>"_"<>SPhenoForm[pF1/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[pF2/.conj[x_]:>SPhenoForm[x]<>"c"]<>"(unitarity_s,"<>ToString[x1]<>","<>ToString[x2]<>","<>ToString[x3]<>","<>ToString[x4]<>","<>ToString[row]<>","<>ToString[column]<>") \n"];,

WriteString[sphenoUni,addcheckGoldstones[scatteringPairsCharges[[k,2,i]],scatteringPairsCharges[[k,2,i]],x1,x2,x3,x4]<>"scattering_eigenvalue_trilinears= a0_"<>SPhenoForm[scatteringPairsCharges[[k,2,i,1]]/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[scatteringPairsCharges[[k,2,i,2]]/.conj[x_]:>SPhenoForm[x]<>"c"]<>"_"<>SPhenoForm[pF1/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[pF2/.conj[x_]:>SPhenoForm[x]<>"c"]<>"(unitarity_s,"<>ToString[x1]<>","<>ToString[x2]<>","<>ToString[x3]<>","<>ToString[x4]<>","<>ToString[row]<>","<>ToString[column]<>") \n"];
WriteString[sphenoUni,"scattering_eigenvalue_trilinears=Abs(scattering_eigenvalue_trilinears) \n"];
];
];
column++;
x4++;];
x3++;];
j++;];
row++;
x2++;];
x1++;];
i++;];
WriteString[sphenoUni,"\n\n"];


WriteString[sphenoUni,"Select CASE (TUcutLevel)  \n"];
WriteString[sphenoUni,"CASE (2) \n"];
If[sdim[k]>1,
WriteString[sphenoUni,"  scatter_matrix"<>ToString[k]<>"B = scatter_matrix"<>ToString[k]<>"\n"];
WriteString[sphenoUni,"Do i=1,"<>ToString[sdim[k]]<>" \n"];
WriteString[sphenoUni,"  If (RemoveTUpoles(i).eq.1) Then\n"];
WriteString[sphenoUni,"   scatter_matrix"<>ToString[k]<>"(i,:) = 0._dp \n"];
WriteString[sphenoUni,"   scatter_matrix"<>ToString[k]<>"(:,i) = 0._dp \n"];
WriteString[sphenoUni,"    If (AddR) scatter_matrix"<>ToString[k]<>"(i,i) = -1111._dp ! to get a fixed order of the eigenvalues \n"];
WriteString[sphenoUni,"   scatter_matrix"<>ToString[k]<>"B(:,i) = 0._dp \n"];
WriteString[sphenoUni,"  Else \n"];
WriteString[sphenoUni,"   scatter_matrix"<>ToString[k]<>"B(i,:) = 0._dp \n"];
WriteString[sphenoUni,"  End If \n"];
WriteString[sphenoUni,"End Do \n"];,
WriteString[sphenoUni,"If (RemoveTUpoles(1).eq.1) scattering_eigenvalue_trilinears = 0._dp \n"];
];


WriteString[sphenoUni,"CASE (1) \n"];
If[sdim[k]>1,
WriteString[sphenoUni,"If ((Abs(max_element_removed)/MaxVal(Abs(scatter_matrix"<>ToString[k]<>"))).gt.cut_elements) Then \n"];
(* WriteString[sphenoUni," Pole_Present = .true. \n"]; *)
WriteString[sphenoUni," ! Write(*,*)  (Abs(max_element_removed)/MaxVal(Abs(scatter_matrix"<>ToString[k]<>")))  \n"];
WriteString[sphenoUni,"End if \n"];
];


WriteString[sphenoUni,"End Select \n"];


(*
WriteString[sphenoUni,"If (SPole_Present) Pole_Present = .true. \n"];
WriteString[sphenoUni,"If (TPole_Present) Pole_Present = .true. \n"];
WriteString[sphenoUni,"If (UPole_Present) Pole_Present = .true. \n"];
*)

(* WriteString[sphenoUni,"If ((.not.Hard_Cut_Poles).or.(.not.Pole_Present)) Then \n"]; *)
If[sdim[k]>1,
WriteString[sphenoUni,"If (.not.pole_present) Then \n"];
WriteString[sphenoUni, "Call EigenSystem(scatter_matrix"<>ToString[k]<>",eigenvalues_matrix"<>ToString[k]<>",rot_matrix"<>ToString[k]<>",ierr,test)\n"];
WriteString[sphenoUni, " If ((TUcutLevel.eq.2).and.(AddR)) Then ! Calculate 'R' \n"];
WriteString[sphenoUni, "  scatter_matrix"<>ToString[k]<>"B = MatMul(scatter_matrix"<>ToString[k]<>"B,Conjg(Transpose(rot_matrix"<>ToString[k]<>"))) \n"];
WriteString[sphenoUni,"   Do i=1,"<>ToString[sdim[k]]<>" \n"];
WriteString[sphenoUni,"    If (eigenvalues_matrix"<>ToString[k]"(i).lt.-1000._dp) Then\n"];
WriteString[sphenoUni,"     eigenvalues_matrix"<>ToString[k]<>"(i) = 0._dp \n"];
WriteString[sphenoUni,"    Else \n"];
WriteString[sphenoUni,"     eigenvalues_matrix"<>ToString[k]<>"(i) = sqrt(eigenvalues_matrix"<>ToString[k]<>"(i)**2+  sum(scatter_matrix"<>ToString[k]<>"B(i,:)**2) )\n"];
WriteString[sphenoUni,"    End If\n"];
WriteString[sphenoUni,"   End Do \n"];
WriteString[sphenoUni, " End If \n"];
WriteString[sphenoUni,"scattering_eigenvalue_trilinears=MaxVal(Abs(eigenvalues_matrix"<>ToString[k]<>")) \n"];
WriteString[sphenoUni,"Else \n"];
WriteString[sphenoUni,"  scattering_eigenvalue_trilinears = 0._dp \n"];
WriteString[sphenoUni,"End if \n"];
];

WriteString[sphenoUni,"If (scattering_eigenvalue_trilinears.gt.max_scattering_eigenvalue_trilinears) Then \n"];
WriteString[sphenoUni,"   max_scattering_eigenvalue_trilinears=scattering_eigenvalue_trilinears \n"];
WriteString[sphenoUni,"   unitarity_s_best=sqrt(unitarity_s)\n"];
WriteString[sphenoUni,"End if \n \n"];
k++;];

(*
WriteString[sphenoUni,"scatter_matrix=0._dp \n"];
row=1;
For[i=1,i\[LessEqual]Length[scatteringPairs],
x1start=1;
If[UnitarityWithoutGoldstones===True,x1start=getGenSPhenoStart[scatteringPairs[[i,1]]];];
For[x1=x1start,x1\[LessEqual]getGen[scatteringPairs[[i,1]]],
x2start=1;
If[UnitarityWithoutGoldstones===True,x2start=getGenSPhenoStart[scatteringPairs[[i,2]]];];
If[scatteringPairs[[i,1]]===scatteringPairs[[i,2]],x2start=x1;];
For[x2=x2start,x2<=getGen[scatteringPairs[[i,2]]],
column=1;
For[j=1,j\[LessEqual]Length[scatteringPairs],
x3start=1;
If[UnitarityWithoutGoldstones===True,x3start=getGenSPhenoStart[scatteringPairs[[j,1]]];];
For[x3=x3start,x3\[LessEqual]getGen[scatteringPairs[[j,1]]],
x4start=1;
If[UnitarityWithoutGoldstones===True,x4start=getGenSPhenoStart[scatteringPairs[[j,2]]];];
If[scatteringPairs[[j,1]]===scatteringPairs[[j,2]],x4start=x3;];
For[x4=x4start,x4<=getGen[scatteringPairs[[j,2]]],
If[FreeQ[scattering22,{scatteringPairs[[i]],scatteringPairs[[j]]}],
WriteString[sphenoUni,"scatter_matrix("<>ToString[row]<>","<>ToString[column]<>") = 0._dp \n"];,
WriteString[sphenoUni,"scatter_matrix("<>ToString[row]<>","<>ToString[column]<>") = a0_"<>SPhenoForm[scatteringPairs[[i,1]]/.conj[x_]\[RuleDelayed]SPhenoForm[x]<>"c"]<>SPhenoForm[scatteringPairs[[i,2]]/.conj[x_]\[RuleDelayed]SPhenoForm[x]<>"c"]<>"_"<>SPhenoForm[scatteringPairs[[j,1]]/.conj[x_]\[RuleDelayed]SPhenoForm[x]<>"c"]<>SPhenoForm[scatteringPairs[[j,2]]/.conj[x_]\[RuleDelayed]SPhenoForm[x]<>"c"]<>"(unitarity_s,"<>ToString[x1]<>","<>ToString[x2]<>","<>ToString[x3]<>","<>ToString[x4]<>") \n"];
];
column++;
x4++;];
x3++;];
j++;];
row++;
x2++;];
x1++;];
i++;];
WriteString[sphenoUni,"\n\n"];

WriteString[sphenoUni, "Call EigenSystem(scatter_matrix,eigenvalues_matrix,rot_matrix,ierr,test) \n\n"];
WriteString[sphenoUni,"scattering_eigenvalue_trilinears=16._dp*Pi*MaxVal(Abs(eigenvalues_matrix)) \n"];
WriteString[sphenoUni,"If (scattering_eigenvalue_trilinears.gt.max_scattering_eigenvalue_trilinears) Then \n"];
WriteString[sphenoUni,"  max_scattering_eigenvalue_trilinears=scattering_eigenvalue_trilinears \n "];
WriteString[sphenoUni,"  unitarity_s_best=sqrt(unitarity_s) \n \n"];
WriteString[sphenoUni,"End if \n"];
*)
 

WriteString[sphenoUni,"End do \n\n"];

WriteString[sphenoUni,"If (max_scattering_eigenvalue_trilinears.gt.0.5_dp) TreeUnitarityTrilinear=0._dp \n \n"];
WriteString[sphenoUni,"! Write(*,*) (max_scattering_eigenvalue_trilinears) \n \n"];

WriteString[sphenoUni,"\n\n Contains \n\n"];

For[i=1,i<=Length[scattering22],
WriteScatteringAmplitude[scattering22[[i]]];
i++;];

WriteString[sphenoUni,"End Subroutine ScatteringEigenvaluesWithTrilinears\n\n"];

];

addcheckGoldstones[{p1_,p2_},{p3_,p4_},i1_,i2_,i3_,i4_]:=If[getGenSPhenoStart[p1]>i1 ||getGenSPhenoStart[p2]>i2 ||getGenSPhenoStart[p3]>i3
 ||getGenSPhenoStart[p4]>i4,
Return["If (IncludeGoldstoneExternal) "];,
Return[""];
];



WriteScatteringAmplitude[{{in1_,in2_},{out1c_,out2c_}}]:=Block[{i,j,k,c1,ind1,out1,out2},
WriteString[sphenoUni,"Complex(dp) Function a0_"<>SPhenoForm[in1/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[in2/.conj[x_]:>SPhenoForm[x]<>"c"]<>"_"<>SPhenoForm[out1c/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[out2c/.conj[x_]:>SPhenoForm[x]<>"c"]<>"(s,i1,i2,i3,i4,ind1,ind2)  Result(amp)\n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Integer, Intent(in) :: i1,i2,i3,i4,ind1,ind2 \n"];
WriteString[sphenoUni,"Real(dp), Intent(in) :: s \n"];
WriteString[sphenoUni,"Integer :: iprop, istart \n"];
WriteString[sphenoUni,"Logical :: pole_s_channel=.False. \n"];
WriteString[sphenoUni,"Real(dp) :: m1,m2,m3,m4 \n"];
WriteString[sphenoUni,"Complex(dp) :: amp_poles \n"];

(*
out1=conj[out1c];
out2=conj[out2c];
*)

out1=out1c;
out2=out2c;

WriteString[sphenoUni,"m1 = "<>SPhenoMass[in1,i1]<>"\n"];
WriteString[sphenoUni,"m2 = "<>SPhenoMass[in2,i2]<>"\n"];
WriteString[sphenoUni,"m3 = "<>SPhenoMass[out1,i3]<>"\n"];
WriteString[sphenoUni,"m4 = "<>SPhenoMass[out2,i4]<>"\n"];

WriteString[sphenoUni,"amp = 0._dp \n"];
WriteString[sphenoUni,"amp_poles = 0._dp \n"];


WriteString[sphenoUni,"If ((s.gt.1.25_dp*(m3+m4)**2).and.(s.gt.1.25_dp*(m1+m2)**2)) Then \n"];
WriteString[sphenoUni,"\n\n! Quartic \n"];
If[FreeQ[VerticesInv[SSSS],C[in1,in2,out1,out2]]==False,
c1=getSPhenoCoupling2[C[in1,in2,out1,out2],SPhenoCouplingsAllreallyAll];
ind1 = MakeIndicesCoupling4[{in1,i1},{in2,i2},{out1,i3},{out2,i4},c1[[2]]];

WriteString[sphenoUni,"amp = amp -2._dp*"<>ToString[c1[[1,1]]]<>ind1[[1]]<>"\n"];

];

WriteString[sphenoUni,"\n\n! S-Channel \n"];
GenerateChannel[in1,in2,out1,out2,{i1,i2,i3,i4},"S",sphenoUni];
WriteString[sphenoUni,"\n\n! T-Channel \n"];
GenerateChannel[in1,out1,in2,out2,{i1,i3,i2,i4},"T",sphenoUni];
WriteString[sphenoUni,"\n\n! U-Channel \n"];
GenerateChannel[in1,out2,in2,out1,{i1,i4,i2,i3},"U",sphenoUni];



WriteString[sphenoUni,"amp = 0.5_dp*oo16pi*amp*sqrt(sqrt(Kaehler(s,m1**2,m2**2)*Kaehler(s,m3**2,m4**2)))/s \n"];


If[in1===in2,
WriteString[sphenoUni,"If (i1.eq.i2) amp=amp/sqrt(2._dp) \n"];
];
If[out1===out2,
WriteString[sphenoUni,"If (i3.eq.i4) amp=amp/sqrt(2._dp) \n"];
];

WriteString[sphenoUni,"End if \n"];


WriteString[sphenoUni,"If (TUcutLevel.eq.1) Then \n"];
WriteString[sphenoUni," amp_poles = 0.5_dp*oo16pi*amp_poles*sqrt(sqrt(Kaehler(s,m1**2,m2**2)*Kaehler(s,m3**2,m4**2)))/s \n"];
If[in1===in2,
WriteString[sphenoUni,"If (i1.eq.i2) amp_poles=amp_poles/sqrt(2._dp) \n"];
];
If[out1===out2,
WriteString[sphenoUni,"If (i3.eq.i4) amp_poles=amp_poles/sqrt(2._dp) \n"];
];
WriteString[sphenoUni,"  If ((Abs(amp_poles)/Abs(amp)).gt.cut_amplitudes) Then \n"];
WriteString[sphenoUni,"   ! Write(*,*) \"TU ratio\", (Abs(amp_poles)/Abs(amp))  \n"];
(* WriteString[sphenoUni,"   If ((Abs(amp_poles)+Abs(amp)).gt.max_element_removed) max_element_removed = Abs(amp_poles)+Abs(amp) \n"]; *)
WriteString[sphenoUni,"   If ((Abs(amp)).gt.max_element_removed) max_element_removed = Abs(amp) \n"];
WriteString[sphenoUni,"   amp = 0._dp \n"];
WriteString[sphenoUni,"  End if \n"];
WriteString[sphenoUni,"End if \n"];

WriteString[sphenoUni,"End Function a0_"<>SPhenoForm[in1/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[in2/.conj[x_]:>SPhenoForm[x]<>"c"]<>"_"<>SPhenoForm[out1c/.conj[x_]:>SPhenoForm[x]<>"c"]<>SPhenoForm[out2c/.conj[x_]:>SPhenoForm[x]<>"c"]<>"\n\n"];


];

GenerateChannel[s1_,s2_,s3_,s4_,inds_,Type_,file_]:=Block[{outlist,i,sign,c1,c2,ind1,ind2},
(* check for all scalars in the propagator *)
For[i=1,i<=Length[partS],
(* check if vertex exists *)
If[FreeQ[VerticesInv[SSS],C[s1,s2,partS[[i]]]]==False&&FreeQ[VerticesInv[SSS],C[s3,s4,conj[partS[[i]]]]]==False,

c1=getSPhenoCoupling2[C[s1,s2,partS[[i]]],SPhenoCouplingsAll];
ind1 = MakeIndicesCoupling[{s1,inds[[1]]},{s2,inds[[2]]},{partS[[i]],iprop},c1[[2]]];

c2=getSPhenoCoupling2[C[s3,s4,conj[partS[[i]]]],SPhenoCouplingsAll];
ind2 = MakeIndicesCoupling[{s3,inds[[3]]},{s4,inds[[4]]},{conj[partS[[i]]],iprop},c2[[2]]];

WriteString[file,"istart=1\n"];
If[getGenSPhenoStart[partS[[i]]]>1,
WriteString[file, "If (.not.IncludeGoldstoneContributions) istart="<>ToString[getGenSPhenoStart[partS[[i]]]]<>"\n"];
];

WriteString[file,"Do iprop=istart,"<>ToString[getGen[partS[[i]]]]<>"\n"];
Switch[Type,
"S",
WriteString[file,"If (Abs(1-s/"<>SPhenoMass[partS[[i]],iProp]<>"**2).lt.0.25_dp) Then \n"];
WriteString[file," Pole_Present = .true. \n"];,
"U",
WriteString[file,"If  (((s.lt.(CheckUpole(m1**2,m2**2,m3**2,m4**2,"<>SPhenoMass[partS[[i]],iProp]<>"**2)))).and.(Abs("<>Type<>"channel(m1,m2,m3,m4,"<>SPhenoMass[partS[[i]],iProp]<>",s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>")).gt.1.0E-10_dp)) Then \n"];
WriteString[file,"! Write(*,*) \"U\",m1,m2,m3,m4,"<>SPhenoMass[partS[[i]],iProp]<>"  \n"];,
"T",
WriteString[file,"If  (((s.lt.(CheckTpole(m1**2,m2**2,m3**2,m4**2,"<>SPhenoMass[partS[[i]],iProp]<>"**2)))).and.(Abs("<>Type<>"channel(m1,m2,m3,m4,"<>SPhenoMass[partS[[i]],iProp]<>",s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>")).gt.1.0E-10_dp)) Then \n"];
WriteString[file,"! Write(*,*) \"T\",m1,m2,m3,m4,"<>SPhenoMass[partS[[i]],iProp]<>"  \n"];
];
If[Type==="T" || Type==="U",
WriteString[file,"Select Case (TUcutLevel) \n"];
WriteString[file," Case (3) \n"];
WriteString[file,"   Pole_Present = .True. \n"];
WriteString[file," Case (2) \n"];
WriteString[file,"  RemoveTUpoles(ind1) = 1 \n"];
WriteString[file,"  RemoveTUpoles(ind2) = 1 \n"]; 
WriteString[file," Case (1) \n"];
WriteString[file,"  amp_poles = amp_poles + Abs("<>Type<>"channel(m1,m2,m3,m4,"<>SPhenoMass[partS[[i]],iProp]<>",s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>")) \n"];
WriteString[file," Case (0) \n"];
WriteString[file,"  amp = amp + "<>Type<>"channel(m1,m2,m3,m4,"<>SPhenoMass[partS[[i]],iProp]<>",s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>") \n"];
WriteString[file,"End Select \n"];
];
WriteString[file,"Else \n"];
WriteString[file,"  amp = amp + "<>Type<>"channel(m1,m2,m3,m4,"<>SPhenoMass[partS[[i]],iProp]<>",s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>") \n"];
WriteString[file,"End if \n"];
WriteString[file,"End Do \n"];
];
i++;];




(*
WriteString[file,"\n \n If (IncludeVectorContributions) Then \n"];
(* check for all scalars in the propagator *)
For[i=1,i\[LessEqual]Length[partV],
(* check if vertex exists *)
If[FreeQ[VerticesInv[SSV],C[s1,s2,partV[[i]]]]\[Equal]False&&FreeQ[VerticesInv[SSV],C[s3,s4,conj[partV[[i]]]]]\[Equal]False,

c1=getSPhenoCoupling2[C[s1,s2,partV[[i]]],SPhenoCouplingsAll];
ind1 = MakeIndicesCoupling[{s1,inds[[1]]},{s2,inds[[2]]},{partV[[i]],iprop},c1[[2]]];

c2=getSPhenoCoupling2[C[s3,s4,conj[partV[[i]]]],SPhenoCouplingsAll];
ind2 = MakeIndicesCoupling[{s3,inds[[3]]},{s4,inds[[4]]},{conj[partV[[i]]],iprop},c2[[2]]];

(* sign from momentum flow in vertex *)
sign=1;
If[{s1,s2}=!=Take[c1[[2]],{1,2}] /.a_[{b__}]\[Rule]a,sign=-sign;];
If[{s3,s4}=!=Take[c2[[2]],{1,2}] /.a_[{b__}]\[Rule]a,sign=-sign;];

If[FreeQ[massless,partV[[i]]],
If[sign\[Equal]1,
WriteString[file,"amp = amp + "<>Type<>"Vchannel(m1,m2,m3,m4,"<>SPhenoMass[partV[[i]],iProp]<>",s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>") \n"];,
WriteString[file,"amp = amp - "<>Type<>"Vchannel(m1,m2,m3,m4,"<>SPhenoMass[partV[[i]],iProp]<>",s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>") \n"];
];,
If[sign\[Equal]1,
WriteString[file,"amp = amp + "<>Type<>"Vchannel(m1,m2,m3,m4,100._dp,s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>") \n"];,
WriteString[file,"amp = amp - "<>Type<>"Vchannel(m1,m2,m3,m4,100._dp,s,"<>ToString[c1[[1,1]]] <>ind1[[1]]<>","<>ToString[c2[[1,1]]] <>ind2[[1]]<>") \n"];
];];
Switch[Type,
"S",
WriteString[file,"If ((Abs(1-s/"<>SPhenoMass[partV[[i]],iProp]<>"**2).lt.0.1_dp).and.(.not.ignore_Spoles)) Pole_Present = .True. \n"];,
"U",
(*
WriteString[file,"If ((m1.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m4)).and.(m3.gt.("<>SPhenoMass[partS[[i]],iProp]<>"+m2)).and.(.not.ignore_TUpoles_Dieter)) Pole_Present = .True. \n"];
WriteString[file,"If ((m2.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m3)).and.(m4.gt.("<>SPhenoMass[partS[[i]],iProp]<>"+m1)).and.(.not.ignore_TUpoles_Dieter)) Pole_Present = .True. \n"]; *)
(*
WriteString[file,"If (((m1.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m4)).and.(m3.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m2)) & \n"];
WriteString[file,"   & .or.((m2.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m3))).and.(m4.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m1))).and.(.not.ignore_TUpoles_Dieter)) Then \n"]; 
WriteString[file," RemoveTUpoles(ind1) = 1 \n"];
WriteString[file," RemoveTUpoles(ind2) = 1 \n"]; 		
WriteString[file,"End if \n"]; 
WriteString[file,"If ((m1.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m4)).and.("<>SPhenoMass[partV[[i]],iProp]<>".gt.(m2+m3)).and.(Abs(1._dp-s/(m3+m4)**2).lt.0.1_dp).and.(.not.ignore_TUpoles_Mine)) Pole_Present = .True. \n"];*)
WriteString[file,"If  (s.lt.(1.1_dp*CheckUpole(m1**2,m2**2,m3**2,m4**2,"<>SPhenoMass[partV[[i]],iProp]<>"**2))) Pole_Present = .True.  \n"];,
"T",
(*
WriteString[file,"If ((m1.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m3)).and.(m4.gt.("<>SPhenoMass[partS[[i]],iProp]<>"+m2)).and.(.not.ignore_TUpoles_Dieter)) Pole_Present = .True. \n"];
WriteString[file,"If ((m2.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m4)).and.(m3.gt.("<>SPhenoMass[partS[[i]],iProp]<>"+m1)).and.(.not.ignore_TUpoles_Dieter)) Pole_Present = .True. \n"];
*)
(*
WriteString[file,"If (((m1.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m3)).and.(m4.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m2)) & \n"];
WriteString[file,"   & .or.((m2.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m4))).and.(m3.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m1))).and.(.not.ignore_TUpoles_Dieter)) Then \n"]; 
WriteString[file," RemoveTUpoles(ind1) = 1 \n"];
WriteString[file," RemoveTUpoles(ind2) = 1 \n"]; 		
WriteString[file,"End if \n"]; 
WriteString[file,"If ((m1.gt.("<>SPhenoMass[partV[[i]],iProp]<>"+m3)).and.("<>SPhenoMass[partV[[i]],iProp]<>".gt.(m2+m4)).and.(Abs(1._dp-s/(m3+m4)**2).lt.0.1_dp).and.(.not.ignore_TUpoles_Mine)) Pole_Present = .True. \n"]
*)
WriteString[file,"If  (s.lt.(1.1_dp*CheckTpole(m1**2,m2**2,m3**2,m4**2,"<>SPhenoMass[partV[[i]],iProp]<>"**2))) Pole_Present = .True.  \n"];
];
];
i++;];
WriteString[file,"End if \n \n"];
*)

];



GenerateTreeLevelUni:=Block[{i,j,dim},
scattermatrix=Get2to2scattering /. Delta[a__]->1;
dim=Length[scattermatrix];

Print["  Write 'Tree-Level Unitarity Limits'"];

MakeSubroutineTitle["ScatteringEigenvalues",Flatten[{Map[ToExpression[SPhenoForm[#]<>"input"]&,Join[listVEVs,listAllParameters]]}],{} ,{"delta0","kont"},sphenoUni];

WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni, "Integer, Intent(inout) :: kont \n"];
WriteString[sphenoUni, "Integer :: ierr \n"];
MakeVariableList[listAllParameters,"",sphenoUni];
MakeVariableList[listVEVs,"",sphenoUni];
WriteString[sphenoUni,"Real(dp) :: gD("<>ToString[numberAllwithVEVs]<>") \n"];
WriteString[sphenoUni, "Real(dp) :: tz,dt,q,q2,mudim \n"];
WriteString[sphenoUni, "Real(dp), Intent(in) :: delta0 \n"];
WriteString[sphenoUni, "Integer :: iter \n"];

WriteString[sphenoUni, "Complex(dp) :: scatter_matrix("<>ToString[dim]<>","<>ToString[dim]<>") \n"]; 
WriteString[sphenoUni, "Complex(dp) :: rot_matrix("<>ToString[dim]<>","<>ToString[dim]<>") \n"]; 
WriteString[sphenoUni, "Real(dp) :: eigenvalues_matrix("<>ToString[dim]<>"), test(2), unitarity_s, scattering_eigenvalue, step_size\n"]; 
MakeVariableList[Map[ToExpression[SPhenoForm[#]<>"input"]&,listAllParametersAndVEVs],",Intent(in)",sphenoUni];

WriteString[sphenoUni, "max_scattering_eigenvalue = 0._dp \n\n"]; 


For[i=1,i<=Length[listAllParametersAndVEVs],
WriteString[sphenoUni,SPhenoForm[listAllParametersAndVEVs[[i]]]<>" = "<>SPhenoForm[listAllParametersAndVEVs[[i]]]<>"input \n"];
i++;];






If[OnlyLowEnergySPheno=!=True,
WriteString[sphenoUni, "If (unitarity_steps.eq.1) Then  \n"]; 
WriteString[sphenoUni, "  step_size = 0._dp\n"]; 
WriteString[sphenoUni, "Else  \n"]; 
WriteString[sphenoUni, " If (unitarity_steps.gt.0) Then \n"]; 
WriteString[sphenoUni, "  step_size = ((Abs(unitarity_s_max)) -(abs(unitarity_s_min)))/(1._dp*(Abs(unitarity_steps)-1)) \n"]; 
WriteString[sphenoUni, " Else \n"]; 
WriteString[sphenoUni, "  step_size = (log(Abs(unitarity_s_max)) -log(abs(unitarity_s_min)))/(1._dp*(Abs(unitarity_steps)-1)) \n"]; 
WriteString[sphenoUni, " End if \n"]; 
WriteString[sphenoUni, "End if \n"]; 

WriteString[sphenoUni, "Do iter=0,Abs(unitarity_steps)-1 \n"]; 
WriteString[sphenoUni, "If (unitarity_steps.lt.0) Then \n"]; 
WriteString[sphenoUni,"  unitarity_s=exp(log(unitarity_s_min) + iter*step_size)**2 \n"];
WriteString[sphenoUni, "Else \n"]; 
WriteString[sphenoUni,"  unitarity_s=(unitarity_s_min + iter*step_size)**2 \n"];
WriteString[sphenoUni, "End if \n"]; 



WriteString[sphenoUni, "If (RunRGEs_unitarity) Then  \n"]; 

For[i=1,i<=Length[listAllParametersAndVEVs],
WriteString[sphenoUni,SPhenoForm[listAllParametersAndVEVs[[i]]]<>" = "<>SPhenoForm[listAllParametersAndVEVs[[i]]]<>"input \n"];
i++;];

WriteGUTnormalization[sphenoUni];
MakeCall["ParametersToG"<>ToString[numberAllwithVEVs],listAllParametersAndVEVs,{},{"gD"},sphenoUni];
WriteString[sphenoUni,"mudim=GetRenormalizationScale() \n"];
WriteString[sphenoUni,"tz=0.5_dp*Log(mudim/unitarity_s)\n"];
WriteString[sphenoUni,"dt=-tz/50._dp\n"];
WriteString[sphenoUni,"Call odeint(gD,"<>ToString[numberAllwithVEVs]<>",tz,0._dp,0.1_dp*delta0,dt,0._dp,rge"<>ToString[numberAllwithVEVs]<>",kont)\n"];
MakeCall["GToParameters"<>ToString[numberAllwithVEVs],listAllParametersAndVEVs,{"gD"},{},sphenoUni];
WriteRemoveGUTnormalization[sphenoUni];
WriteTadpoleSolutionOnlyHigh[sphenoUni];
WriteString[sphenoUni, "End if \n"]; 
];

WriteString[sphenoUni,"scatter_matrix=0._dp \n"];

For[i=1,i<=dim,
For[j=1,j<=dim,
If[scattermatrix[[i,j]]=!=0,
WriteString[sphenoUni,"scatter_matrix("<>ToString[i]<>","<>ToString[j]<>") ="<>SPhenoForm[scattermatrix[[i,j]]]<>"\n"];
];
j++;];
i++;];

WriteString[sphenoUni, "Call EigenSystem( oo16pi*scatter_matrix,eigenvalues_matrix,rot_matrix,ierr,test) \n\n"];
WriteString[sphenoUni,"scattering_eigenvalue=MaxVal(Abs(eigenvalues_matrix)) \n"];

If[OnlyLowEnergySPheno=!=True,
WriteString[sphenoUni," If (scattering_eigenvalue.gt.max_scattering_eigenvalue) Then \n"];
WriteString[sphenoUni,"   max_scattering_eigenvalue=scattering_eigenvalue \n"];
WriteString[sphenoUni," End if \n\n"];

WriteString[sphenoUni,"End Do \n"]; ,
WriteString[sphenoUni,"max_scattering_eigenvalue=scattering_eigenvalue \n"];
];


WriteString[sphenoUni,"If (max_scattering_eigenvalue.gt.0.5_dp) TreeUnitarity=0._dp \n"];

WriteString[sphenoUni,"End Subroutine ScatteringEigenvalues\n\n"];

];

WriteIntegrals:=Block[{},
WriteString[sphenoUni,"Complex(dp) Function Kaehler(a,b,c) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::a,b,c\n"];
WriteString[sphenoUni,"Kaehler = a**2-2._dp*a*(b+c)+(b-c)**2 \n"];
WriteString[sphenoUni,"End Function Kaehler \n  \n"];

WriteString[sphenoUni,"Real(dp) Function CheckTpole(m1,m2,m3,m4,mP) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1,m2,m3,m4,mP\n"];
WriteString[sphenoUni,"Complex(dp):: res\n"];
WriteString[sphenoUni,"res = (m2*m3 - m3*m4 + m2*mP + m3*mP + m4*mP - mP**2 + m1*(-m2 + m4 + mP) + Sqrt(m1**2 + (m3 - mP)**2 &\n"];
WriteString[sphenoUni,"  &  - 2*m1*(m3 + mP))*Sqrt(m2**2 + (m4 - mP)**2 - 2*m2*(m4 + mP)))/(2.*mP)\n"];
WriteString[sphenoUni,"If (Aimag(res).gt.1._dp) Then \n"];
WriteString[sphenoUni," CheckTpole = 0._dp \n"];
WriteString[sphenoUni,"Else \n"];
WriteString[sphenoUni," CheckTpole = Real(res,dp) \n"];
WriteString[sphenoUni,"End If \n"];
WriteString[sphenoUni,"End Function CheckTpole \n \n"];

WriteString[sphenoUni,"Real(dp) Function CheckUpole(m1,m2,m3,m4,mP) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1,m2,m3,m4,mP\n"];
WriteString[sphenoUni,"Complex(dp) :: res\n"];
WriteString[sphenoUni,"res =(m2*m4-m3*m4+m2*mP+m3*mP+m4*mP-mP**2+m1*(-m2+m3+mP)+Sqrt(m2**2+(m3-mP)**2 &\n"];
WriteString[sphenoUni,"  &-2*m2*(m3+mP))*Sqrt(m1**2+(m4-mP)**2-2*m1*(m4+mP)))/(2.*mP)\n"];
WriteString[sphenoUni,"If (Aimag(res).gt.1._dp) Then \n"];
WriteString[sphenoUni," CheckUpole = 0._dp \n"];
WriteString[sphenoUni,"Else \n"];
WriteString[sphenoUni," CheckUpole = Real(res,dp) \n"];
WriteString[sphenoUni,"End If \n"];
WriteString[sphenoUni,"End Function CheckUpole \n \n"];



WriteString[sphenoUni,"Complex(dp) Function Schannel(m1,m2,m3,m4,mP,s,c1,c2) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1,m2,m3,m4,mP,s\n"];
WriteString[sphenoUni,"Complex(dp),Intent(in)::c1,c2\n"];
WriteString[sphenoUni,"Schannel = 2._dp/(-mP**2+s) \n"];
WriteString[sphenoUni,"Schannel = c1*c2*Schannel \n"];
WriteString[sphenoUni,"End Function Schannel \n \n"];

(*
WriteString[sphenoUni,"Complex(dp) Function SVchannel(m1,m2,m3,m4,mP,s,c1,c2) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1,m2,m3,m4,mP,s\n"];
WriteString[sphenoUni,"Complex(dp),Intent(in)::c1,c2\n"];
WriteString[sphenoUni,"SVchannel = (2*(m1 - m2)*(m1 + m2)*(m3 - m4)*(m3 + m4))/((mP**2 - s)*s) \n"];
WriteString[sphenoUni,"SVchannel = c1*c2*SVchannel \n"];
WriteString[sphenoUni,"End Function SVchannel \n \n"];
*)
WriteString[sphenoUni,"Complex(dp) Function Uchannel(m1r,m2r,m3r,m4r,mPr,s,c1,c2) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1r,m2r,m3r,m4r,mPr,s\n"];
WriteString[sphenoUni,"Complex(dp),Intent(in)::c1,c2\n"];
WriteString[sphenoUni,"Complex(dp)::m1,m2,m3,m4,mP \n"];
WriteString[sphenoUni,"m1=Cmplx(m1r,0._dp)\n"];
WriteString[sphenoUni,"m2=Cmplx(m2r,0._dp)\n"];
WriteString[sphenoUni,"m3=Cmplx(m3r,0._dp)\n"];
WriteString[sphenoUni,"m4=Cmplx(m4r,0._dp)\n"];
WriteString[sphenoUni,"mP=Cmplx(mPr,0._dp)\n"];
WriteString[sphenoUni,"Uchannel = (2*s*Log(-(((m1 - m2)*(m1 + m2)*(m3 - m4)*(m3 + m4) + (m1**2 + m2**2 + m3**2 + m4**2 - 2*mP**2)*s & \n"]; WriteString[sphenoUni,"  & - s**2 + Sqrt((m1**4 + (m2**2 - s)**2 - 2*m1**2*(m2**2 + s))*(m3**4 + (m4**2 - s)**2 - 2*m3**2*(m4**2 + s))))/& \n"]; WriteString[sphenoUni,"  &((-m1 + m2)*(m1 + m2)*(m3 - m4)*(m3 + m4) - (m1**2 + m2**2 + m3**2 + m4**2 - 2*mP**2)*s + s**2 + & \n"]; WriteString[sphenoUni,"  & Sqrt((m1**4 + (m2**2 - s)**2 - 2*m1**2*(m2**2 + s))*(m3**4 + (m4**2 - s)**2 - 2*m3**2*(m4**2 + s)))))))/& \n"];
 WriteString[sphenoUni," &Sqrt((m1**4 + (m2**2 - s)**2 - 2*m1**2*(m2**2 + s))*(m3**4 + (m4**2 - s)**2 - 2*m3**2*(m4**2 + s))) \n"];
WriteString[sphenoUni,"Uchannel = c1*c2*Uchannel \n"];
WriteString[sphenoUni,"End Function Uchannel \n  \n"];
(*
WriteString[sphenoUni,"Complex(dp) Function UVchannel(m1r,m2r,m3r,m4r,mPr,s,c1,c2) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1r,m2r,m3r,m4r,mPr,s\n"];
WriteString[sphenoUni,"Complex(dp),Intent(in)::c1,c2\n"];
WriteString[sphenoUni,"Complex(dp)::m1,m2,m3,m4,mP \n"];
WriteString[sphenoUni,"m1=Cmplx(m1r,0._dp)\n"];
WriteString[sphenoUni,"m2=Cmplx(m2r,0._dp)\n"];
WriteString[sphenoUni,"m3=Cmplx(m3r,0._dp)\n"];
WriteString[sphenoUni,"m4=Cmplx(m4r,0._dp)\n"];
WriteString[sphenoUni,"mP=Cmplx(mPr,0._dp)\n"];
WriteString[sphenoUni,"UVchannel = 2-(4*(m1**2+m2**2+m3**2+m4**2-mP**2-2._dp*(s))*s* & \n"]; WriteString[sphenoUni,"  & ArcCoth(((m1-m2)*(m1+m2)*(m3-m4)*(m3+m4)+(m1**2+m2**2+m3**2+m4**2-2*mP**2)*s-s**2)/ & \n"]; WriteString[sphenoUni,"  & (Sqrt((m1**2-m2**2)**2-2*(m1**2+m2**2)*s+s**2)*Sqrt((m3**2-m4**2)**2-2*(m3**2+m4**2)*s+s**2))))/ & \n"]; WriteString[sphenoUni,"  & (Sqrt((m1**2-m2**2)**2-2*(m1**2+m2**2)*s+s**2)*Sqrt((m3**2-m4**2)**2-2*(m3**2+m4**2)*s+s**2))\n"];
WriteString[sphenoUni,"UVchannel = c1*c2*UVchannel \n"];
WriteString[sphenoUni,"End Function UVchannel \n  \n"];
*)
WriteString[sphenoUni,"Complex(dp) Function Tchannel(m1r,m2r,m3r,m4r,mPr,s,c1,c2) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1r,m2r,m3r,m4r,mPr,s\n"];
WriteString[sphenoUni,"Complex(dp),Intent(in)::c1,c2\n"];
WriteString[sphenoUni,"Complex(dp)::m1,m2,m3,m4,mP \n"];
WriteString[sphenoUni,"m1=Cmplx(m1r,0._dp)\n"];
WriteString[sphenoUni,"m2=Cmplx(m2r,0._dp)\n"];
WriteString[sphenoUni,"m3=Cmplx(m3r,0._dp)\n"];
WriteString[sphenoUni,"m4=Cmplx(m4r,0._dp)\n"];
WriteString[sphenoUni,"mP=Cmplx(mPr,0._dp)\n"];
WriteString[sphenoUni,"Tchannel =(2*s*Log(((m1-m2)*(m1+m2)*(m3-m4)*(m3+m4)-(m1**2+m2**2+m3**2+m4**2-2*mP**2)*s+s**2& \n"]; WriteString[sphenoUni,"  & -Sqrt((m1**4+(m2**2-s)**2-2*m1**2*(m2**2+s))*(m3**4+(m4**2-s)**2-2*m3**2*(m4**2+s))))/& \n"]; WriteString[sphenoUni,"  & ((m1-m2)*(m1+m2)*(m3-m4)*(m3+m4)-(m1**2+m2**2+m3**2+m4**2-2*mP**2)*s+s**2+Sqrt((m1**4+(m2**2-s)**2& \n"]; WriteString[sphenoUni,"  & -2*m1**2*(m2**2+s))*(m3**4+(m4**2-s)**2-2*m3**2*(m4**2+s))))))/& \n"]; WriteString[sphenoUni,"  & Sqrt((m1**4+(m2**2-s)**2-2*m1**2*(m2**2+s))*(m3**4+(m4**2-s)**2-2*m3**2*(m4**2+s))) \n"];
WriteString[sphenoUni,"Tchannel = c1*c2*Tchannel \n"];
WriteString[sphenoUni,"End Function Tchannel \n  \n"];
(*
WriteString[sphenoUni,"Complex(dp) Function TVchannel(m1r,m2r,m3r,m4r,mPr,s,c1,c2) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Real(dp),Intent(in)::m1r,m2r,m3r,m4r,mPr,s\n"];
WriteString[sphenoUni,"Complex(dp),Intent(in)::c1,c2\n"];
WriteString[sphenoUni,"Complex(dp)::m1,m2,m3,m4,mP \n"];
WriteString[sphenoUni,"m1=Cmplx(m1r,0._dp)\n"];
WriteString[sphenoUni,"m2=Cmplx(m2r,0._dp)\n"];
WriteString[sphenoUni,"m3=Cmplx(m3r,0._dp)\n"];
WriteString[sphenoUni,"m4=Cmplx(m4r,0._dp)\n"];
WriteString[sphenoUni,"mP=Cmplx(mPr,0._dp)\n"];
WriteString[sphenoUni,"TVchannel =2+(4*(m1**2+m2**2+m3**2+m4**2-mP**2-2._dp*(s))*s* & \n"]; WriteString[sphenoUni,"  & ArcCoth(((m1-m2)*(m1+m2)*(m3-m4)*(m3+m4)-(m1**2+m2**2+m3**2+m4**2-2*mP**2)*s+s**2)/ & \n"]; WriteString[sphenoUni,"  & (Sqrt((m1**2-m2**2)**2-2*(m1**2+m2**2)*s+s**2)*Sqrt((m3**2-m4**2)**2-2*(m3**2+m4**2)*s+s**2))))/ & \n"]; WriteString[sphenoUni,"  & (Sqrt((m1**2-m2**2)**2-2*(m1**2+m2**2)*s+s**2)*Sqrt((m3**2-m4**2)**2-2*(m3**2+m4**2)*s+s**2)) \n"];
WriteString[sphenoUni,"TVchannel = c1*c2*TVchannel \n"];
WriteString[sphenoUni,"End Function TVchannel \n \n"];

WriteString[sphenoUni,"Complex(dp) Function arccoth(a) \n"];
WriteString[sphenoUni,"Implicit None \n"];
WriteString[sphenoUni,"Complex(dp),Intent(in)::a\n"];
WriteString[sphenoUni,"arccoth = 0.5_dp*Log((a+1)/(a-1)) \n"];
WriteString[sphenoUni,"End Function arccoth \n  \n"];
*)
];



