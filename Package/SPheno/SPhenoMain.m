(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
GenerateSPhenoMain[NameForModel_]:=Block[{i},

(*
Print["-----------------------------------"];
Print["Write SPheno Main File"];
Print["-----------------------------------"];
*)

Print[StyleForm["Write SPheno main file","Section",FontSize->12]];

spheno=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"SPheno"<>NameForModel<>".f90"]];

WriteCopyRight[spheno];

WriteString[spheno,"Program SPheno"<>NameForModel<>" \n \n"];

WriteString[spheno,"Use Control\n"];
WriteString[spheno,"Use InputOutput_"<>ModelName<>"\n"];
WriteString[spheno,"Use LoopFunctions\n"];
WriteString[spheno,"Use Settings\n"];
If[AddLowEnergyConstraint ===True && SPhenoOnlyForHM=!=True,
WriteString[spheno,"Use LowEnergy_"<>ModelName<>"\n"]; 
];
WriteString[spheno,"Use Mathematics\n"];
WriteString[spheno,"Use Model_Data_"<>ModelName<>"\n"];
WriteString[spheno,"Use Tadpoles_"<>ModelName<>" \n "];
If[OnlyLowEnergySPheno=!=True,
WriteString[spheno,"Use RGEs_"<>ModelName<>"\n"];
];
WriteString[spheno,"!Use StandardModel\n"];
If[AddTreeLevelUnitarityLimits===True,
WriteString[spheno,"Use Unitarity_"<>ModelName<>" \n "];
];
WriteString[spheno,"Use Boundaries_"<>ModelName<>"\n "];


If[IncludeFineTuning===True,
WriteString[spheno,"Use FineTuning_"<>ModelName<>"\n"];
];

If[SPhenoOnlyForHM=!=True,WriteString[spheno,"Use HiggsCS_"<>ModelName<>"\n"];];
WriteString[spheno,"Use TreeLevelMasses_"<>ModelName<>"\n"];
WriteString[spheno,"Use LoopMasses_"<>ModelName<>"\n \n"];
If[SPhenoOnlyForHM=!=True, WriteString[spheno,"Use BranchingRatios_"<>ModelName<>"\n \n"];];




WriteString[spheno,"Implicit None\n \n"];

WriteString[spheno,"Real(dp) :: epsI=0.00001_dp, deltaM = 0.000001_dp \n"];
WriteString[spheno, "Real(dp) :: mGut = -1._dp, ratioWoM = 0._dp\n"];
WriteString[spheno, "Integer :: kont, n_tot \n \n"];
WriteString[spheno, "Integer,Parameter :: p_max=100\n"];
WriteString[spheno, "Real(dp) :: Ecms(p_max),Pm(p_max),Pp(p_max), dt, tz, Qin, gSM(11) \n"];
(* If[OnlyLowEnergySPheno===True,
WriteString[spheno, "Real(dp) :: vev, sinw2, f_GMSB\n"];, *)
WriteString[spheno, "Real(dp) :: vev, sinw2\n"];
(* ]; *)
(* If[SupersymmetricModel===False, *)
WriteString[spheno, "Complex(dp) :: YdSM(3,3), YuSM(3,3), YeSM(3,3)\n"];
WriteString[spheno, "Real(dp) :: vSM, g1SM, g2SM, g3SM\n"];
WriteString[spheno, "Integer :: i1 \n"];
(* ]; *)

CheckSCKM;
If[WriteCKMBasis===True,
WriteString[spheno,"Complex(dp) :: Yd_ckm(3,3), Yu_ckm(3,3), Tu_ckm(3,3), Td_ckm(3,3), mq2_ckm(3,3), mu2_ckm(3,3), md2_ckm(3,3) \n"];
WriteString[spheno,"Complex(dp) :: Yd_out(3,3), Yu_out(3,3), Tu_out(3,3), Td_out(3,3), mq2_out(3,3), mu2_out(3,3), md2_out(3,3) \n"];
];

If[DEFINITION[UseNonStandardYukwas]===True,
WriteString[spheno,"Real(dp) :: vd_aux, vu_aux\n"];
];

If[SupersymmetricModel===True && DEFINITION[UseNonStandardYukwas]===True,
WriteString[spheno, "Complex(dp) :: YdSM(3,3), YuSM(3,3), YeSM(3,3)\n"];
WriteString[spheno, "Real(dp) :: vSM\n"];
];

WriteString[spheno, "Logical :: ISR(p_max)=.False.\n"];
WriteString[spheno, "Logical :: CalcTBD\n"];
(* MakeVariableList[NewParametersFromTadpoles,"",spheno]; *)
MakeVariableList[Transpose[ListOfLowEnergyNames][[1]],"",spheno]; (* NonPublic *)

For[i=1,i<=Length[ListOfLowEnergyNames],
If[ListOfLowEnergyNames[[i,2]]=!=0,
WriteString[spheno,ToString[ListOfLowEnergyNames[[i,1]]]<>" = 0._dp \n"];
];
i++;];


WriteString[spheno, "Call get_command_argument(1,inputFileName)\n"];
WriteString[spheno, "If (len_trim(inputFileName)\[Equal]0) Then\n"];
WriteString[spheno, "  inputFileName=\"LesHouches.in."<>NameForModel<>"\"\n"];
WriteString[spheno, "Else\n"];
WriteString[spheno, "  inputFileName=trim(inputFileName)\n"];
WriteString[spheno, "End if\n"];

WriteString[spheno, "Call get_command_argument(2,outputFileName)\n"];
WriteString[spheno, "If (len_trim(outputFileName)\[Equal]0) Then\n"];
WriteString[spheno, "  outputFileName=\"SPheno.spc."<>NameForModel<>"\"\n"];
WriteString[spheno, "Else\n"];
WriteString[spheno, "  outputFileName=trim(outputFileName)\n"];
WriteString[spheno, "End if \n"];


[SupersymmetricModel===False,
WriteString[spheno,"g1SM = 0._dp \n"];
WriteString[spheno,"g2SM = 0._dp \n"];
WriteString[spheno,"g3SM = 0._dp \n"];
WriteString[spheno,"vSM = 0._dp \n"];
];
WriteString[spheno,"YdSM = 0._dp \n"];
WriteString[spheno,"YeSM = 0._dp \n"];
WriteString[spheno,"YuSM = 0._dp \n"];


WriteString[spheno,"Call Set_All_Parameters_0() \n \n"];

If[SupersymmetricModel=!=False,
WriteString[spheno,"Qin = SetRenormalizationScale(1.0E3_dp**2)  \n"];,
WriteString[spheno,"Qin = SetRenormalizationScale(1.6E2_dp**2)  \n"];
];

WriteString[spheno,"kont = 0 \n"];
WriteString[spheno,"delta_Mass = 0.0001_dp \n"];
WriteString[spheno,"CalcTBD = .false. \n"];
WriteString[spheno, "Call ReadingData(kont) \n \n"];


subLowEnergyParameters={
ToExpression[SPhenoForm[hyperchargeCoupling]]-> ToExpression[SPhenoForm[hyperchargeCoupling]<>"MZ" ],
ToExpression[SPhenoForm[leftCoupling]]-> ToExpression[SPhenoForm[leftCoupling]<>"MZ" ],
ToExpression[SPhenoForm[VEVSM1]]-> ToExpression[SPhenoForm[VEVSM1]<>"MZ" ],
ToExpression[SPhenoForm[VEVSM2]]-> ToExpression[SPhenoForm[VEVSM2]<>"MZ" ],
ToExpression[SPhenoForm[VEVSM]]-> ToExpression[SPhenoForm[VEVSM]<>"MZ" ],
ToExpression[SPhenoForm[UpYukawa]]-> ToExpression[SPhenoForm[UpYukawa]<>"MZ" ],
ToExpression[SPhenoForm[DownYukawa]]-> ToExpression[SPhenoForm[DownYukawa]<>"MZ" ],
ToExpression[SPhenoForm[ElectronYukawa]]-> ToExpression[SPhenoForm[ElectronYukawa]<>"MZ" ]
};

temp1=Join[listVEVs,Complement[listAllParameters,ParametersToSolveTadpoles]];
temp2={};
For[i=1,i<=Length[temp1],
If[FreeQ[subLowEnergyParameters,temp1[[i]]],
temp2=Join[temp2,{temp1[[i]]}];,
temp2=Join[temp2,{temp1[[i]]/. subLowEnergyParameters}];
];
i++;];

If[OnlyLowEnergySPheno===True,
WriteString[spheno," HighScaleModel = \"LOW\" \n"];
];

WriteString[spheno,"If ((MatchingOrder.lt.-1).or.(MatchingOrder.gt.2)) Then \n"];
WriteString[spheno,"  If (HighScaleModel.Eq.\"LOW\") Then \n"];
WriteString[spheno,"    If (.not.CalculateOneLoopMasses) Then \n"];
WriteString[spheno,"       MatchingOrder = -1 \n"];
WriteString[spheno,"    Else \n"];
WriteString[spheno,"       MatchingOrder =  2 \n"];
WriteString[spheno,"    End if \n"];
WriteString[spheno,"   Else \n"];
WriteString[spheno,"       MatchingOrder =  2 \n"];
WriteString[spheno,"   End If \n"];
WriteString[spheno,"End If \n"];

WriteString[spheno,"Select Case(MatchingOrder) \n"];
WriteString[spheno," Case(0) \n"];
WriteString[spheno,"   OneLoopMatching = .false. \n"];
WriteString[spheno,"   TwoLoopMatching = .false. \n"];
WriteString[spheno,"   GuessTwoLoopMatchingBSM = .false. \n"];
WriteString[spheno," Case(1) \n"];
WriteString[spheno,"   OneLoopMatching = .true. \n"];
WriteString[spheno,"   TwoLoopMatching = .false. \n"];
WriteString[spheno,"   GuessTwoLoopMatchingBSM = .false. \n"];
WriteString[spheno," Case(2) \n"];
WriteString[spheno,"   OneLoopMatching = .true. \n"];
WriteString[spheno,"   TwoLoopMatching = .true. \n"];
WriteString[spheno,"   GuessTwoLoopMatchingBSM = .true. \n"];
WriteString[spheno,"End Select \n"];

(*
If[OnlyLowEnergySPheno===True,
WriteString[spheno,"If (.not.DecoupleAtRenScale) Then ! No longer used by default \n "];,
WriteString[spheno,"If ((HighScaleModel.Eq.\"LOW\").and.(.not.SUSYrunningFromMZ)) Then ! No longer used by default \n "];
];
*)

WriteString[spheno,"If (MatchingOrder.eq.-1) Then \n "];


WriteString[spheno,"! Setting values \n "];
For[i=1,i<=Length[listVEVsIN],
If[MemberQ[ParametersToSolveTadpoles,listVEVs[[i]]]==False,
WriteString[spheno,StringDrop[SPhenoForm[listVEVsIN[[i]]],-2] <>" = " <>SPhenoForm[listVEVsIN[[i]]]<>" \n "];
];
i++;];
For[i=1,i<=Length[HighScaleList],
If[MemberQ[ParametersToSolveTadpoles,HighScaleList[[i,2]]]==False,
WriteString[spheno,StringDrop[SPhenoForm[highScaleIn[[i]]],-2] <>" = " <>SPhenoForm[highScaleIn[[i]]]<>" \n "];
];
i++;];
For[i=1,i<=Length[LowScaleList],
If[MemberQ[ParametersToSolveTadpoles,LowScaleList[[i,2]]]==False,
WriteString[spheno,StringDrop[SPhenoForm[lowScaleIn[[i]]],-2] <>" = " <>SPhenoForm[lowScaleIn[[i]]]<>" \n "];
];
i++;];

For[i=1,i<=Length[BoundaryLowScaleInput],
If[FreeQ[BoundaryLowScaleInput[[i,2]],DIAGONAL]==True,
Switch[Head[BoundaryLowScaleInput[[i,1]]],
re,WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<>" = Cmplx(Real(" <> SPhenoForm[BoundaryLowScaleInput[[i,2]]]  <>",dp),Aimag("<>SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<> "))\n"];,
im,WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<>" = Cmplx(Real(" <>SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<>",dp),Real("<> SPhenoForm[BoundaryLowScaleInput[[i,2]]]  <> ",dp))\n"];,
_,WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1]]]<>" = " <>SPhenoForm[BoundaryLowScaleInput[[i,2]]]<>"\n"];
];,
WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1]]]<>" = 0._dp \n"];
WriteString[spheno,"Do i1=1,"<>ToString[getDimSPheno[BoundaryLowScaleInput[[i,1]]][[1]]]<>"\n"];
WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1]]]<>"(i1,i1) = " <> SPhenoForm[BoundaryLowScaleInput[[i,2]] /. DIAGONAL->1]<>"\n"];
WriteString[spheno,"End Do\n"];
];
i++;];

(*
If[SupersymmetricModel===False,
If[AddOHDM=!=True,
WriteString[spheno,"tanbetaMZ = tanbeta \n"];
];
]; *)

If[FreeQ[MINPAR,TanBeta]===False,
WriteString[spheno,"tanbetaMZ = tanbeta \n"];
];

WriteString[spheno,"\n \n ! Setting VEVs used for low energy constraints \n "];
For[i=1,i<=Length[listVEVsIN],
WriteString[spheno,StringDrop[SPhenoForm[listVEVsIN[[i]]],-2] <>"MZ = " <>StringDrop[SPhenoForm[listVEVsIN[[i]]],-2]<>" \n "];
i++;];

(*
WriteString[spheno,"If (SMrunningLowScaleInput) Then \n"];
WriteString[spheno,"  Qin=sqrt(getRenormalizationScale()) \n"];
WriteString[spheno,"  Call RunSMohdm(Qin,deltaM,g1SM,g2SM,g3SM,YuSM,YdSM,YeSM,vSM) \n"];
WriteString[spheno,"Else \n"];
*)
WriteString[spheno,"   sinW2=1._dp-mW2/mZ2 \n"];
WriteString[spheno,"   vSM=1/Sqrt((G_F*Sqrt(2._dp)))\n"];
WriteString[spheno,"   g1SM=sqrt(4*Pi*Alpha_MZ/(1-sinW2)) \n"];
WriteString[spheno,"   g2SM=sqrt(4*Pi*Alpha_MZ/Sinw2 ) \n"];
WriteString[spheno,"   g3SM=sqrt(AlphaS_MZ*4*Pi) \n"];
WriteString[spheno,"   Do i1=1,3 \n"];
WriteString[spheno,"      YuSM(i1,i1)=sqrt(2._dp)*mf_u(i1)/vSM \n"];
WriteString[spheno,"      YeSM(i1,i1)=sqrt(2._dp)*mf_l(i1)/vSM \n"];
WriteString[spheno,"      YdSM(i1,i1)=sqrt(2._dp)*mf_d(i1)/vSM \n"];
WriteString[spheno,"    End Do \n"];
WriteString[spheno,"    If (GenerationMixing) YuSM = Matmul(Transpose(CKM),YuSM) \n"];


If[TransposedYukawaScheme===False,
WriteString[spheno,"\n\n! Transpose Yukawas to fit SPheno conventions \n"];
WriteString[spheno,"YuSM= Transpose(YuSM) \n"];
WriteString[spheno,"YdSM= Transpose(YdSM)\n"];
WriteString[spheno,"YeSM= Transpose(YeSM)\n"];
];

(*
WriteString[spheno,"End if \n"];
*)

If[SPhenoOnlyForHM=!=True,
WriteString[spheno,"\n ! Setting Boundary conditions \n "];

SetMatchingConditions[spheno];

For[i=1,i<=Length[BoundaryLowScaleInput],
If[FreeQ[BoundaryLowScaleInput[[i,2]],DIAGONAL]==True,
Switch[Head[BoundaryLowScaleInput[[i,1]]],
re,WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<>" = Cmplx(Real(" <> SPhenoForm[BoundaryLowScaleInput[[i,2]]]  <>",dp),Aimag("<>SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<> "))\n"];,
im,WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<>" = Cmplx(Real(" <>SPhenoForm[BoundaryLowScaleInput[[i,1,1]]]<>",dp),Real("<> SPhenoForm[BoundaryLowScaleInput[[i,2]]]  <> ",dp))\n"];,
_,WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1]]]<>" = " <>SPhenoForm[BoundaryLowScaleInput[[i,2]]]<>"\n"];
];,
WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1]]]<>" = 0._dp \n"];
WriteString[spheno,"Do i1=1,"<>ToString[getDimSPheno[BoundaryLowScaleInput[[i,1]]][[1]]]<>"\n"];
WriteString[spheno,SPhenoForm[BoundaryLowScaleInput[[i,1]]]<>"(i1,i1) = " <> SPhenoForm[BoundaryLowScaleInput[[i,2]] /. DIAGONAL->1]<>"\n"];
WriteString[spheno,"End Do\n"];
];
i++;];
];

If[SPhenoOnlyForHM===True,
For[i=1,i<=Length[subVEVnames],
If[getDimSPheno[subVEVnames[[i,1]]]==={1} || getDimSPheno[subVEVnames[[i,1]]]==={2},
If[Head[subVEVnames[[i,2]]]===Symbol,
WriteString[spheno,SPhenoForm[subVEVnames[[i,2]]] <>" = " <> SPhenoForm[subVEVnames[[i,1]]] <>"\n"];,
WriteString[spheno,SPhenoForm[subVEVnames[[i,2]]/.I->0] <>" = Real(" <> SPhenoForm[subVEVnames[[i,1]]] <>",dp) \n"];
WriteString[spheno,SPhenoForm[Coefficient[subVEVnames[[i,2]] /. I->ic,ic]] <>" = Aimag(" <> SPhenoForm[subVEVnames[[i,1]]] <>") \n"];
];,
For[j=1,j<=getDimSPheno[subVEVnames[[i,1]]/. A_[a_Pattern]->A][[1]],
If[Head[subVEVnames[[i,2]]]=!=Plus,
WriteString[spheno,SPhenoForm[subVEVnames[[i,2]] /. A_[a_]->A[j] /. A_[b_Integer]:>ToExpression[ToString[A]<>ToString[b]]] <>" = " <> SPhenoForm[subVEVnames[[i,1]] /. A_[a_]->A[j]] <>"\n"];,
WriteString[spheno,SPhenoForm[subVEVnames[[i,2]]/.I->0 /. A_[a_]->A[j]/. A_[b_Integer]:>ToExpression[ToString[A]<>ToString[b]]]<>" = Real(" <> SPhenoForm[subVEVnames[[i,1]]/. A_[a_]->A[j]] <>",dp) \n"];
WriteString[spheno,SPhenoForm[Coefficient[subVEVnames[[i,2]] /. I->ic,ic] /. A_[a_]->A[j]/. A_[b_Integer]:>ToExpression[ToString[A]<>ToString[b]]] <>" = Aimag(" <> SPhenoForm[subVEVnames[[i,1]]/. A_[a_]->A[j]] <>") \n"];
];
j++;];
];
i++;];
];

If[WriteCKMBasis===True,
WriteString[spheno,"\n\n\n"];
WriteString[spheno,"! Translate input form SCKM to electroweak basis \n"];
WriteString[spheno,"If (SwitchToSCKM) Then\n"];
WriteString[spheno,"Yd_ckm = "<>SPhenoForm[DownYukawa]<>"(1:3,1:3) \n"];
WriteString[spheno,"Yu_ckm = "<>SPhenoForm[UpYukawa]<>"(1:3,1:3) \n"];
WriteString[spheno,"Td_ckm = "<>SPhenoForm[TrilinearDown]<>"(1:3,1:3) \n"];
WriteString[spheno,"Tu_ckm = "<>SPhenoForm[TrilinearUp]<>"(1:3,1:3) \n"];
WriteString[spheno,"mq2_ckm = "<>SPhenoForm[SoftSquark]<>"(1:3,1:3) \n"];
WriteString[spheno,"md2_ckm = "<>SPhenoForm[SoftDown]<>"(1:3,1:3) \n"];
WriteString[spheno,"mu2_ckm = "<>SPhenoForm[SoftUp]<>"(1:3,1:3) \n"];

WriteString[spheno,"Call Switch_from_superCKM(Yd_ckm, Yu_ckm, Td_ckm, Tu_ckm, md2_ckm, mq2_ckm, mu2_ckm& \n"];
WriteString[spheno,"&, Td_out, Tu_out, md2_out, mq2_out, mu2_out,.True.) \n"];

WriteString[spheno,"If (InputValuefor"<>SPhenoForm[TrilinearDown] <>") "<>SPhenoForm[TrilinearDown] <>" = Td_out \n"];
WriteString[spheno,"If (InputValuefor"<>SPhenoForm[TrilinearUp] <>") "<>SPhenoForm[TrilinearUp] <>" = Tu_out \n"];
WriteString[spheno,"If (InputValuefor"<>SPhenoForm[SoftSquark] <>") "<>SPhenoForm[SoftSquark] <>" = mq2_out \n"];
WriteString[spheno,"If (InputValuefor"<>SPhenoForm[SoftDown] <>") "<>SPhenoForm[SoftDown] <>" = md2_out \n"];
WriteString[spheno,"If (InputValuefor"<>SPhenoForm[SoftUp] <>") "<>SPhenoForm[SoftUp] <>" = mu2_out \n"];
WriteString[spheno,"End If \n"];
WriteString[spheno,"\n\n\n"];
];

If[SPhenoOnlyForHM=!=True,
WriteTadpoleSolutionOnlyLow[spheno];,
WriteString[spheno,"\n\n ! Put here the equations for delta_vi  (as check, should all be zero!) \n\n"];
];

MakeCall["OneLoopMasses",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{"kont"},spheno];

WriteString[spheno,"\n If (SignOfMassChanged) Then  \n"];
WriteString[spheno," If (.Not.IgnoreNegativeMasses) Then \n"];
WriteString[spheno,"  Write(*,*) \" Stopping calculation because of negative mass squared.\" \n"];
WriteString[spheno,"  Call TerminateProgram \n"];
WriteString[spheno," Else \n"];
WriteString[spheno,"  SignOfMassChanged= .False. \n"];
WriteString[spheno,"  kont=0  \n"];
WriteString[spheno," End If \n"];
WriteString[spheno,"End If \n"];
WriteString[spheno,"If (SignOfMuChanged) Then \n"];
WriteString[spheno," If (.Not.IgnoreMuSignFlip) Then \n"];
WriteString[spheno,"  Write(*,*) \" Stopping calculation because of negative mass squared in tadpoles.\" \n"];
WriteString[spheno,"  Call TerminateProgram \n"];
WriteString[spheno," Else \n"];
WriteString[spheno,"  SignOfMuChanged= .False. \n"];
WriteString[spheno,"  kont=0 \n"];
WriteString[spheno," End If \n"];
WriteString[spheno,"End If \n\n"];

(* If[OnlyLowEnergySPheno=!=True, *)
WriteString[spheno,"Else \n "];
WriteString[spheno,"  If (GetMassUncertainty) Then \n "];
WriteString[spheno,"  ! Uncertainty from Y_top \n "];
WriteString[spheno,"If ((CalculateOneLoopMasses).and.(CalculateTwoLoopHiggsMasses)) Then \n"];
WriteString[spheno,"OneLoopMatching = .true. \n"];
WriteString[spheno,"TwoLoopMatching = .false. \n"];
WriteString[spheno,"GuessTwoLoopMatchingBSM = .True. \n"];
WriteString[spheno,"Elseif ((CalculateOneLoopMasses).and.(.not.CalculateTwoLoopHiggsMasses)) Then  \n"];
WriteString[spheno,"OneLoopMatching = .true. \n"];
WriteString[spheno,"TwoLoopMatching = .false. \n"];
WriteString[spheno,"GuessTwoLoopMatchingBSM = .false. \n"];
WriteString[spheno,"Else  \n"];
WriteString[spheno,"OneLoopMatching = .true. \n"];
WriteString[spheno,"TwoLoopMatching = .false. \n"];
WriteString[spheno,"GuessTwoLoopMatchingBSM = .false. \n"];
WriteString[spheno,"End if \n"];

MakeCall["CalculateSpectrum",Join[NewMassParameters,Join[listVEVs,listAllParameters ]],{"n_run","delta_mass","WriteOut","kont"},{"mGUT"},spheno];

WriteString[spheno,"n_tot =1\n"];
For[i=1,i<=Length[NewMasses],
WriteString[spheno,"mass_uncertainty_Yt(n_tot:n_tot+"<>ToString[NewMasses[[i,2]]-1]<>") = " <>ToString[NewMasses[[i,1]]]<> "! difference will be taken later \n"]; 
If[i<Length[NewMasses],
WriteString[spheno,"n_tot = n_tot + " <>ToString[NewMasses[[i,2]]] <>" \n"];
];
i++;];

WriteString[spheno,"If ((CalculateOneLoopMasses).and.(CalculateTwoLoopHiggsMasses)) Then \n"];
WriteString[spheno,"OneLoopMatching = .true. \n"];
WriteString[spheno,"TwoLoopMatching = .true. \n"];
WriteString[spheno,"GuessTwoLoopMatchingBSM = .false. \n"];
WriteString[spheno,"Elseif ((CalculateOneLoopMasses).and.(.not.CalculateTwoLoopHiggsMasses)) Then  \n"];
WriteString[spheno,"OneLoopMatching = .false. \n"];
WriteString[spheno,"TwoLoopMatching = .false. \n"];
WriteString[spheno,"GuessTwoLoopMatchingBSM = .false. \n"];
WriteString[spheno,"Else  \n"];
WriteString[spheno,"OneLoopMatching = .false. \n"];
WriteString[spheno,"TwoLoopMatching = .false. \n"];
WriteString[spheno,"GuessTwoLoopMatchingBSM = .false. \n"];
WriteString[spheno,"End if \n"];

WriteString[spheno,"  End if \n "];

MakeCall["CalculateSpectrum",Join[NewMassParameters,Join[listVEVs,listAllParameters ]],{"n_run","delta_mass","WriteOut","kont"},{"mGUT"},spheno];

WriteString[spheno,"  If (GetMassUncertainty) Then \n "];
MakeCall["GetScaleUncertainty",Join[NewMassParameters,Join[listVEVs,listAllParameters ]],{"delta_mass","WriteOut","kont"},{"mass_uncertainty_Q"},spheno];

WriteString[spheno,"  End if \n "];

WriteString[spheno,"End If \n "];
(* ]; *)

WriteString[spheno, "! Save correct Higgs masses for calculation of L -> 3 L' \n"];
If[FreeQ[ParticleDefinitions[SPheno`Eigenstates],"Higgs"]===False,
WriteString[spheno,"MhhL = "<>SPhenoForm[SPhenoMass[HiggsBoson]]<>"\n"];
WriteString[spheno,"Mhh2L = MhhL**2 \n"];
];
If[FreeQ[ParticleDefinitions[SPheno`Eigenstates],"Pseudo-Scalar Higgs"]===False,
WriteString[spheno,"MAhL = "<>SPhenoForm[SPhenoMass[PseudoScalar]]<>"\n"];
WriteString[spheno,"MAh2L = MAhL**2 \n \n"];
];

WriteSetDependentParameters[spheno];


WriteString[spheno,"If ((L_BR).And.(kont.Eq.0)) Then \n "];

If[OnlyLowEnergySPheno=!=True,
WriteString[spheno,"sinW2=1._dp-mW2/mZ2 \n"];
WriteString[spheno,"vev=Sqrt(mZ2*(1._dp-sinW2)*SinW2/(pi*alpha_mZ))\n"];
If[AddOHDM=!=True,
If[FreeQ[parameters,VEVSM1]===False && FreeQ[parameters,VEVSM2]===False,
WriteString[spheno,"vdMZ=vev/Sqrt(1._dp+tanbetaMZ**2)\n"];
WriteString[spheno,"vuMZ=tanbetaMZ*vdMZ \n"];
];,
WriteString[spheno,SPhenoForm[VEVSM]<>"MZ = vev\n"];
];
];

If[SPhenoOnlyForHM=!=True,
If[OnlyLowEnergySPheno=!=True,
(* MakeCall["CalculateBR",Join[Join[NewMassParameters,Join[Map[ToExpression[ToString[#]<>"MZ"]&,listVEVs],listAllParameters]],SPhenoWidthBR],{"CalcTBD","ratioWoM","epsI","deltaM","kont"},{},spheno];, *)
MakeCall["CalculateBR",Join[Join[NewMassParameters,Join[listVEVs(* /. {VEVSM1\[Rule]vdMZ,VEVSM2\[Rule]vuMZ} *),listAllParameters]],SPhenoWidthBR],{"CalcTBD","ratioWoM","epsI","deltaM","kont"},{},spheno];,
MakeCall["CalculateBR",Join[Join[NewMassParameters,Join[listVEVs,listAllParameters]],SPhenoWidthBR],{"CalcTBD","ratioWoM","epsI","deltaM","kont"},{},spheno];
];

If[getGen[HiggsBoson]>1,
MakeCall["HiggsCrossSections",{},{SPhenoForm[SPhenoMass[HiggsBoson]],"ratioGG", "ratioPP","rHB_S_"<>SPhenoForm[VectorW],"rHB_S_"<>SPhenoForm[VectorZ],"rHB_S_S_"<>SPhenoForm[TopQuark]<>"(:,3)","CS_Higgs_LHC","kont"},{},spheno];
];

If[(getGen[PseudoScalar]-getGenSPhenoStart[PseudoScalar]+1)>0 && (getGen[PseudoScalar]<99),
MakeCall["HiggsCrossSections",{},{SPhenoForm[SPhenoMass[PseudoScalar]],"ratioPGG", "ratioPPP","0._dp*rHB_S_"<>SPhenoForm[VectorW],"0._dp*rHB_S_"<>SPhenoForm[VectorZ],"rHB_P_S_"<>SPhenoForm[TopQuark]<>"(:,3)","CS_PHiggs_LHC","kont"},{},spheno];
];
];

WriteString[spheno,"End If \n \n "];



If[AddLowEnergyConstraint ===True && SPhenoOnlyForHM=!=True,

WriteString[spheno,"If (CalculateLowEnergy) then \n"];
MakeCall["CalculateLowEnergyConstraints",Join[Join[listAllParameters,listVEVs],Transpose[ListOfLowEnergyNames][[1]]],{},{},spheno]; 
WriteString[spheno, SPhenoForm[SPhenoMass[VectorZ]]<>" = mz \n"];
WriteString[spheno, SPhenoForm[SPhenoMassSq[VectorZ]]<>" = mz2 \n"];
WriteString[spheno, SPhenoForm[SPhenoMass[VectorW]]<>" = mW \n"];
WriteString[spheno, SPhenoForm[SPhenoMassSq[VectorW]]<>" = mW2 \n"];

WriteString[spheno,"If (WriteParametersAtQ) Then \n"];
MakeCall["TreeMasses",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{"GenerationMixing","kont"},spheno];
WriteString[spheno,"End If \n \n"];

If[FreeQ[massless,Neutrino] && SA`NeutrinoPresent ==True,
WriteString[spheno,SPhenoForm[SPhenoMass[Neutrino]]<>" = nuMasses  \n"];
If[SPhenoForm[NeutrinoMM]=!="Delta",WriteString[spheno,SPhenoForm[NeutrinoMM]<>" = nuMixing  \n"];];
];
WriteString[spheno,"End if \n \n"];
]; 

(*
If[SA`AddOneLoopDecay === True,
MakeCall["CalculateOneLoopDecays",Join[listVEVs,listAllParameters],{},{"epsI","deltaM","kont"},spheno];
];
*)

If[IncludeFineTuning===True,
WriteString[spheno,"If (HighScaleModel.ne.\"LOW\") Then \n "];
WriteString[spheno," If (calcFT) Then \n"];
MakeCall["FineTuning",listAllParametersAndVEVs, {},{"mGut","kont"},spheno];
WriteString[spheno," End If \n"];
WriteString[spheno,"End If \n"];
];


WriteString[spheno,"If ((FoundIterativeSolution).or.(WriteOutputForNonConvergence)) Then \n"];
WriteString[spheno,"If (OutputForMO) Then \n"];
MakeCall["RunningFermionMasses",Join[Join[listVEVs,listAllParameters]],SPhenoForm/@SA`SMfermionmasses ,{"kont"},spheno];
WriteString[spheno,"End if \n"];

If[AddTreeLevelUnitarityLimits===True,
WriteString[spheno,"If (TreeLevelUnitarityLimits) Then \n"];
WriteString[spheno,"Write(*,*) \"Calculating unitarity constraints \" \n"];
MakeCall["ScatteringEigenvalues",Join[listVEVs,listAllParameters],{} ,{"deltaM","kont"},spheno];
WriteString[spheno,"End if \n"];
WriteString[spheno,"If (TrilinearUnitarity) Then \n"];
WriteString[spheno,"If (.not.TreeLevelUnitarityLimits) Write(*,*) \"Calculating unitarity constraints \" \n"];
MakeCall["ScatteringEigenvaluesWithTrilinears",Join[NewMassParameters,listVEVs,listAllParameters],{} ,{"deltaM","kont"},spheno];
WriteString[spheno,"End if \n"];
];

WriteString[spheno,"Write(*,*) \"Writing output files\" \n"];
MakeCall["LesHouches_Out",Transpose[ListOfLowEnergyNames][[1]],{"67","11","kont","MGUT"},{"GenerationMixing"},spheno];
WriteString[spheno, "End if \n"];

WriteString[spheno,"Write(*,*) \"Finished!\" \n"];

WriteString[spheno, "Contains \n \n"];

If[WriteCKMBasis===True,
AppendSourceCode["SwitchFromSCKM.f90",spheno];
];

(* If[OnlyLowEnergySPheno=!=True, *)
GenerateCalculateSpectrum;
(* ]; *)
GenerateReadingData;



If[AddTreeLevelUnitarityLimits===True,
GenerateUnitarityConstraints;
(* GenerateTreeLevelUni; *)
];

GenerateScaleUncertainty;

WriteString[spheno,"End Program SPheno"<>NameForModel<>" \n"];

Close[spheno];
];


(* ::Input::Initialization:: *)
GenerateReadingData:=Block[{},

Print["  Write 'ReadingData'"];

WriteString[spheno,"Subroutine ReadingData(kont)\n"];
WriteString[spheno,"Implicit None\n"];
WriteString[spheno,"Integer,Intent(out)::kont\n"];

WriteString[spheno,"Logical::file_exists\n"];

WriteString[spheno,"kont=-123456\n"];

WriteString[spheno,"Inquire(file=inputFileName,exist=file_exists)\n"];
WriteString[spheno,"If (file_exists) Then\n"];
WriteString[spheno,"kont=1\n"];

(*  WriteString[spheno,"Call LesHouches_Input(kont,HighScaleModel,Ecms,Pm,Pp,ISR,F_GMSB)\n"]; *)
 WriteString[spheno,"Call LesHouches_Input(kont,Ecms,Pm,Pp,ISR,F_GMSB)\n"]; 
(* WriteString[spheno,"Call LesHouches_Input(kont)\n"]; *)

WriteString[spheno,"LesHouches_Format= .True.\n"];
WriteString[spheno,"Else\n"];
WriteString[spheno,"Write(*,*)&\n"];
WriteString[spheno,"& \"File \",inputFileName,\" does not exist\"\n"];
WriteString[spheno,"Call TerminateProgram\n"];
WriteString[spheno,"End If\n"];

WriteString[spheno,"End Subroutine ReadingData\n\n \n"];


];




(* ::Input::Initialization:: *)
GenerateScaleUncertainty:=Block[{i,j,temp},
Print["  Write 'ScaleUncertainty'"];

MakeSubroutineTitle["GetScaleUncertainty",ToExpression[SPhenoForm[#]<>"input"]&/@Join[NewMassParameters,Join[listVEVs,listAllParameters]],{"delta","WriteOut","kont"},{"mass_Qerror"},spheno]; 

WriteString[spheno,"Implicit None \n"];
WriteString[spheno, "Integer, Intent(inout) :: kont \n"];
WriteString[spheno, "Logical, Intent(in) :: WriteOut \n"];
WriteString[spheno, "Real(dp), Intent(in) :: delta \n"]; 

WriteString[spheno, "Real(dp) :: mass_in("<>NumberNewMassesTotal<>"), mass_new("<>NumberNewMassesTotal<>") \n"]; 
WriteString[spheno, "Real(dp), Intent(out) :: mass_Qerror("<>NumberNewMassesTotal<>") \n"]; 

WriteString[spheno, "Real(dp) :: gD("<>ToString[numberAllwithVEVs]<>"), Q, Qsave, Qstep, Qt, g_SM(62), mh_SM \n"]; 
WriteString[spheno, "Integer :: i1, i2, iupdown, ntot \n"]; 

MakeVariableList[ToExpression[SPhenoForm[#]<>"input"]&/@listAllParameters,",Intent(in)",spheno];
MakeVariableList[ToExpression[SPhenoForm[#]<>"input"]&/@NewMassParameters,",Intent(in)",spheno];
MakeVariableList[ToExpression[SPhenoForm[#]<>"input"]&/@listVEVs,",Intent(in)",spheno];

MakeVariableList[listAllParameters,"",spheno];
MakeVariableList[NewMassParameters,"",spheno];
MakeVariableList[listVEVs,"",spheno];

WriteString[spheno,"kont = 0 \n"];

WriteString[spheno,"Write(*,*) \"Check scale uncertainty\" \n"];

WriteString[spheno,"n_tot =1\n"];
For[i=1,i<=Length[NewMasses],
WriteString[spheno,"mass_in(n_tot:n_tot+"<>ToString[NewMasses[[i,2]]-1]<>") = " <>ToString[NewMasses[[i,1]]]<> "input\n"];
If[i<Length[NewMasses],
WriteString[spheno,"n_tot = n_tot + " <>ToString[NewMasses[[i,2]]] <>" \n"];
];
i++;];
WriteString[spheno,"mass_Qerror = 0._dp \n"];

WriteString[spheno,"Qsave=sqrt(getRenormalizationScale()) \n"];

WriteString[spheno,"Do iupdown=1,2 \n"];
WriteString[spheno,"If (iupdown.eq.1) Then \n"];
WriteString[spheno,"  Qstep=Qsave/7._dp \n"];
WriteString[spheno,"Else \n"];
WriteString[spheno,"  Qstep=-0.5_dp*Qsave/7._dp \n"];
WriteString[spheno,"End if \n"];

WriteString[spheno,"Do i1=1,7 \n"];
WriteString[spheno,"Q=Qsave+i1*Qstep \n"];
WriteString[spheno,"Qt = SetRenormalizationScale(Q**2) \n"];
For[i=1,i<=Length[listAllParametersAndVEVs],
WriteString[spheno,SPhenoForm[listAllParametersAndVEVs[[i]]]<>" = "<>SPhenoForm[listAllParametersAndVEVs[[i]]]<>"input\n"];
i++;];
WriteGUTnormalization[spheno];
MakeCall["ParametersToG"<>ToString[numberAllwithVEVs],listAllParametersAndVEVs,{},{"gD"},spheno];

WriteString[spheno,"If (iupdown.eq.1) Then \n"];
WriteString[spheno," tz=Log(Q/Qsave)\n"];
WriteString[spheno," dt=-tz/50._dp\n"];
WriteString[spheno," Call odeint(gD,"<>ToString[numberAllwithVEVs]<>",0._dp,tz,0.1_dp*delta,dt,0._dp,rge"<>ToString[numberAllwithVEVs]<>",kont)\n"];
WriteString[spheno,"Else \n"];
WriteString[spheno," tz=-Log(Q/Qsave)\n"];
WriteString[spheno," dt=tz/50._dp\n"];
WriteString[spheno," Call odeint(gD,"<>ToString[numberAllwithVEVs]<>",tz,0._dp,0.1_dp*delta,dt,0._dp,rge"<>ToString[numberAllwithVEVs]<>",kont)\n"];
WriteString[spheno,"End if \n"];

MakeCall["GToParameters"<>ToString[numberAllwithVEVs],listAllParametersAndVEVs,{"gD"},{},spheno];

WriteRemoveGUTnormalization[spheno];

WriteTadpoleSolutionOnlyHigh[spheno];

MakeCall["OneLoopMasses",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{"kont"},spheno];

If[getGen[HiggsBoson]>1,
WriteString[spheno,"If (((Calculate_mh_within_SM).and.("<>SPhenoMass[HiggsBoson,getGenStart[HiggsBoson]+1] <>".gt.300._dp)).OR.(Force_mh_within_SM))Then\n"];,
WriteString[spheno,"If (Calculate_mh_within_SM) Then\n"];
];
WriteString[spheno,"g_SM=g_SM_save \n"];
WriteString[spheno,"tz=0.5_dp*Log(mZ2/Q**2)\n"];
WriteString[spheno,"dt=tz/100._dp\n"];
WriteString[spheno,"g_SM(1)=Sqrt(5._dp/3._dp)*g_SM(1) \n"];
WriteString[spheno,"Call odeint(g_SM,62,tz,0._dp,delta,dt,0._dp,rge62_SM,kont) \n"];
WriteString[spheno,"g_SM(1)=Sqrt(3._dp/5._dp)*g_SM(1) \n"];
WriteString[spheno,"Call Get_mh_pole_SM(g_SM,Q**2,delta,"<>SPhenoMassSq[HiggsBoson,getGenStart[HiggsBoson]]<>",mh_SM)\n"];
WriteString[spheno,SPhenoMassSq[HiggsBoson,getGenStart[HiggsBoson]] <>" = mh_SM**2 \n"];
WriteString[spheno,SPhenoMass[HiggsBoson,getGenStart[HiggsBoson]] <>" = mh_SM \n"];
WriteString[spheno,"End if\n"];

WriteString[spheno,"n_tot =1\n"];
For[i=1,i<=Length[NewMasses],
WriteString[spheno,"mass_new(n_tot:n_tot+"<>ToString[NewMasses[[i,2]]-1]<>") = " <>ToString[NewMasses[[i,1]]]<> "\n"];
If[i<Length[NewMasses],
WriteString[spheno,"n_tot = n_tot + " <>ToString[NewMasses[[i,2]]] <>" \n"];
];
i++;];

WriteString[spheno,"  Do i2=1,"<>NumberNewMassesTotal<>" \n"];
WriteString[spheno,"    If (Abs(mass_new(i2)-mass_in(i2)).gt.mass_Qerror(i2)) mass_Qerror(i2) = Abs(mass_new(i2)-mass_in(i2)) \n"];
WriteString[spheno,"  End Do \n"];

WriteString[spheno,"End Do \n"];
WriteString[spheno,"End Do \n"];

WriteString[spheno,"  Do i2=1,"<>NumberNewMassesTotal<>"  \n"];
WriteString[spheno,"    mass_uncertainty_Yt(i2) = Abs(mass_uncertainty_Yt(i2)-mass_in(i2)) \n"];
WriteString[spheno,"  End Do \n"];


WriteString[spheno,"If (kont.ne.0) Then \n"];
WriteString[spheno," Write(*,*) \"Error appeared in check of scale uncertainty \"\n \n"];
WriteString[spheno," Call TerminateProgram \n"];
WriteString[spheno,"End If \n \n"];

WriteString[spheno,"Qt = SetRenormalizationScale(Qsave**2) \n"];

WriteString[spheno,"End Subroutine GetScaleUncertainty \n \n\n \n"];
];

GenerateCalculateSpectrum:=Block[{i,j,temp},

Print["  Write 'CalculateSpectrum'"];


 MakeSubroutineTitle["CalculateSpectrum",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{"n_run","delta","WriteOut","kont"},{"mGUT"},spheno]; 

WriteString[spheno,"Implicit None \n"];
WriteString[spheno, "Integer, Intent(in) :: n_run \n"]; 
WriteString[spheno, "Integer, Intent(inout) :: kont \n"];
WriteString[spheno, "Logical, Intent(in) :: WriteOut \n"];
WriteString[spheno, "Real(dp), Intent(in) :: delta \n"]; 
WriteString[spheno, "Real(dp), Intent(inout) :: mGUT \n"]; 

MakeVariableList[listAllParameters,",Intent(inout)",spheno];
MakeVariableList[NewMassParameters,",Intent(inout)",spheno];
MakeVariableList[listVEVs,",Intent(inout)",spheno];

WriteString[spheno,"kont = 0 \n"];

If[Length[UseParameterAsGUTscale]>0,
If[FreeQ[MINPAR,UseParameterAsGUTscale[[1]]]===False,
If[Head[MINPAR[[1,1]]]=!=List,
temp=Select[Transpose[MINPAR][[2]],(FreeQ[UseParameterAsGUTscale,#]==False)&];
If[temp=!={},WriteString[spheno,"Call SetGUTscale(abs("<>SPhenoForm[temp[[1]]]<>")) \n"];];,
WriteString[spheno,"Select Case(BoundaryCondition) \n"];
For[j=1,j<=Length[MINPAR],
WriteString[spheno,"Case ("<>ToString[j]<>") \n"];
temp=Select[Transpose[MINPAR[[j]]][[2]],(FreeQ[UseParameterAsGUTscale,#]==False)&];
If[temp=!={},
WriteString[spheno,"  Call SetGUTscale(abs("<>SPhenoForm[temp[[1]]]<>")) \n"];,
WriteString[spheno,"  ! Free GUT scale \n"];
];
j++;];
WriteString[spheno,"End Select \n\n"];
];,
temp=Select[Transpose[EXTPAR][[2]],(FreeQ[UseParameterAsGUTscale,#]==False)&];
WriteString[spheno,"Call SetGUTscale(abs("<>SPhenoForm[temp[[1]]]<>")) \n"];];
];

If[Head[SetParametersAt]===List && SetParametersAt=!={},
WriteString[spheno,"If ((HighScaleModel.eq.\"LOW\").and.(Abs("<>ToString[SetParametersAt[[1]]]<>").gt.0_dp)) Call SetGUTscale(Abs("<>ToString[SetParametersAt[[1]]]<>")) \n "];
];

MakeCall["FirstGuess",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{"kont"},spheno];
WriteString[spheno,"!If (kont.ne.0) Call TerminateProgram \n \n"];

WriteString[spheno,"If (SPA_Convention) Call SetRGEScale(1.e3_dp**2) \n \n"];


If[OnlyLowEnergySPheno=!=True,
If[SupersymmetricModel===True,
WriteString[spheno,"If (.not.DecoupleAtRenScale) Then \n"];
MakeCall["Sugra",Join[NewMassParameters,listAllParameters], {"delta"},{"mGut","kont","WriteOut","n_run"},spheno];
WriteString[spheno,"Else \n"];
MakeCall["Match_and_Run",Join[NewMassParameters,listAllParameters], {"delta"},{"mGut","kont","WriteOut","n_run"},spheno];
WriteString[spheno,"End If \n \n"];,
MakeCall["Match_and_Run",Join[NewMassParameters,listAllParameters], {"delta"},{"mGut","kont","WriteOut","n_run"},spheno];
];,
WriteString[spheno,"If (.Not.UseFixedScale) Then \n"];
WriteString[spheno," Call SetRGEScale(160._dp**2) \n"];
WriteString[spheno,"End If\n"];


MakeCall["Match_and_Run",Join[NewMassParameters,listAllParameters], {"delta"},{"mGut","kont","WriteOut","n_run"},spheno];
];


WriteString[spheno,"If (kont.ne.0) Then \n"];
WriteString[spheno," Write(*,*) \"Error appeared in calculation of masses \"\n \n"];
WriteString[spheno," Call TerminateProgram \n"];
WriteString[spheno,"End If \n \n"];

WriteString[spheno,"End Subroutine CalculateSpectrum \n \n\n \n"];


];


(* ::Input::Initialization:: *)
WriteSetDependentParameters[file_]:=Block[{i},
For[i=1,i<=Length[subDependencesSPheno],
If[FreeQ[NewNumericalDependences,subDependencesSPheno[[i,1]]],
WriteString[file,SPhenoForm[subDependencesSPheno[[i,1]]]<>" = "<>SPhenoForm[subDependencesSPheno[[i,2]]]<>"\n"];
];
i++;];
];


