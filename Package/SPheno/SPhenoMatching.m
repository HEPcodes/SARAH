(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
GenerateMatching:=Block[{i,temp,file,ModuleName},
Print[StyleForm["Write routine for matching couplings","Section",FontSize->12]];

file=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"Matching_"<>ModelName<>".f90"]];
(* function to write references for SARAH as well as date and time to the beginning of the file *)
WriteCopyRight[file];

WriteString[file,"Module Matching_"<>ModelName<>" \n"];
WriteString[file,"Use Control \n"];
WriteString[file,"Use AddLoopFunctions \n"];
WriteString[file,"Use Settings \n"];
WriteString[file,"Use LoopFunctions \n"];
WriteString[file,"Use Couplings_"<>ModelName<>" \n"];
WriteString[file,"Use TreeLevelMasses_"<>ModelName<>" \n"];
WriteString[file,"Use Tadpoles_"<>ModelName<>" \n \n"];

WriteString[file,"Real(dp) :: MatchingThreshold = 1000._dp ! need to put reasonable value \n \n"];
WriteString[file,"Logical :: Include_in_Thresholds_ScalarD0 = .True. \n"];
WriteString[file,"Logical :: Include_in_Thresholds_ScalarC0 = .True. \n"];
WriteString[file,"Logical :: Include_in_Thresholds_ScalarB0 = .True. \n"];
WriteString[file,"Logical :: Include_in_Thresholds_Fermion = .True. \n"];
WriteString[file,"Logical :: Include_in_Thresholds_Wave = .True. \n"];
WriteString[file,"Logical :: Include_in_Thresholds_TreeProp = .True. \n"];
WriteString[file,"Logical :: Include_in_Thresholds_Tree = .True. \n\n"];

WriteString[file,"Contains \n \n"];

checkvertices=SA`CheckSameVertices;
SA`CheckSameVertices=False;


GenerateMatchingAll[file];

SA`CheckSameVertices=checkvertices;


AppendSourceCode["MatchingFunctions.f90",file];


(* MISSING *)
(* MS/DR shifts *)

(* Comparison THDM:
C0, wave: overall factor of 2 *)
(* check sign propagtor diagrams *)



WriteString[file,"End Module Matching_"<>ModelName<>" \n"];
Close[file];

];


(* ::Input::Initialization:: *)
GenerateMatchingAll[file_]:=Block[{i,j,temp,AllInfo,diffExternal},

Print["Matching for quartic couplings"];

MatchedCouplings=Table[HighscaleMatchingConditions[[i,2]],{i,1,Length[HighscaleMatchingConditions]}];

diffExternal =Intersection[Flatten[MatchedCouplings/.a_ + b_ ->a //. a_ b_Dot ->b /.A_[b_Integer]->A/. Plus->List /. Dot->List /. conj[x_]->x]];

match4=Select[MatchedCouplings,Length[# /. a_ + b_ ->a //. a_ b_Dot ->b]==4&];
match3=Select[MatchedCouplings,Length[# /. a_ + b_ ->a //. a_ b_Dot ->b]==3&];

match4diffFields=Intersection[Flatten[match4 /. A_[b_Integer]->A/. Plus->List//. a_ b_Dot ->b]];
match3diffFields=Intersection[Flatten[match3 /. A_[b_Integer]->A/. Plus->List//. a_ b_Dot ->b]];

listMatchingWave={};
For[i=1,i<=Length[diffExternal],
listMatchingWave=Join[listMatchingWave,{"PiForMatching"<>ToString[diffExternal[[i]]]}];
SPhenoParameters=Join[SPhenoParameters,{{"PiForMatching"<>ToString[diffExternal[[i]]],{generation,generation},{getGen[diffExternal[[i]]],getGen[diffExternal[[i]]]}}}];
WriteMatchingWaveContributions[diffExternal[[i]],SPhenoForm[diffExternal[[i]]],file];
i++;];

For[i=1,i<=Length[match4diffFields],
WriteString[file,"\n\n"];
WriteMatchingQuartic[match4diffFields[[i]],file];
i++;];

For[i=1,i<=Length[match3diffFields],
WriteString[file,"\n\n"];
WriteMatchingCubic[match3diffFields[[i]],file];
i++;];

WriteMainFunctionMatching[diffExternal,file];


];

WriteMainFunctionMatching[diffex_,file_]:=Block[{i,ii,j,k,j1,j2,name,nameT},
subMatching={};
For[i=1,i<=Length[ParametersEffModel],
If[FreeQ[parameters,ParametersEffModel[[i,1]]],
If[FreeQ[RealParametersEffModel,ParametersEffModel[[i,1]]]==False,realVar=Join[realVar,{ParametersEffModel[[i,1]]}];];
SPhenoParameters=Join[SPhenoParameters,{ParametersEffModel[[i]]}];
];
i++;];
ParameterNamesEffModel=Transpose[ParametersEffModel][[1]];


MakeSubroutineTitle["MatchingRoutine_"<>ModelName,Flatten[{ParameterNamesEffModel,SPhenoForm/@Transpose[MINPAR][[2]]}],{"scale"},{},file];
WriteString[file,"Implicit None \n"];
MakeVariableList[NewMassParameters,"",file];
MakeVariableList[namesAllreallyAll,"",file];
MakeVariableList[ParameterNamesEffModel,", Intent(inout)",file];
For[i=1,i<=Length[MINPAR],
If[FreeQ[realVar,MINPAR[[i,2]]],
WriteString[file,"Complex(dp), Intent(in) ::  "<>ToString[MINPAR[[i,2]]]<>"\n"];,
WriteString[file,"Real(dp), Intent(in) ::  "<>ToString[MINPAR[[i,2]]]<>"\n"];
];
i++;];
WriteString[file,"Integer :: i1,i2,i3,i4, kont \n"];
WriteString[file,"Real(dp), Intent(in) :: scale \n"];
WriteString[file,"Real(dp) :: scale_save, setscale \n"];
WriteString[file,"Logical :: GenerationMixing \n"];


For[i=1,i<=Length[diffex],
WriteString[file,"Complex(dp) ::  PiForMatching"<>ToString[diffex[[i]]]<>"("<>ToString[getGen[diffex[[i]]]]<>","<>ToString[getGen[diffex[[i]]]]<>")\n"];
i++;];


For[i=1,i<=Length[match4diffFields],
WriteString[file,"Complex(dp) :: res"<>StringReplace[SPhenoForm/@(match4diffFields[[i]]/. conj[x_]->C.x) //. Dot->StringJoin,{"("->"",")"->""}]<>"("<>StringReplace[ToString[getGen/@match4diffFields[[i]]],{"("->"",")"->"","."->","}]<>") \n"];
WriteString[file,"Complex(dp) :: resT"<>StringReplace[SPhenoForm/@(match4diffFields[[i]]/. conj[x_]->C.x) //. Dot->StringJoin,{"("->"",")"->""}]<>"("<>StringReplace[ToString[getGen/@match4diffFields[[i]]],{"("->"",")"->"","."->","}]<>") \n"];
i++;];

For[i=1,i<=Length[match3diffFields],
WriteString[file,"Complex(dp) :: res"<>StringReplace[SPhenoForm/@(match3diffFields[[i]]/. conj[x_]->C.x) //. Dot->StringJoin,{"("->"",")"->""}]<>"("<>StringReplace[ToString[getGen/@match3diffFields[[i]]],{"("->"",")"->"","."->","}]<>") \n"];
WriteString[file,"Complex(dp) :: resT"<>StringReplace[SPhenoForm/@(match3diffFields[[i]]/. conj[x_]->C.x) //. Dot->StringJoin,{"("->"",")"->""}]<>"("<>StringReplace[ToString[getGen/@match3diffFields[[i]]],{"("->"",")"->"","."->","}]<>") \n"];
i++;];



WriteString[file,"scale_save = GetRenormalizationScale() \n"];
WriteString[file,"setscale = SetRenormalizationScale(scale**2) \n"];


WriteString[file,"! Boundary Conditions \n"];
For[i=1,i<=Length[BoundaryMatchingScale],
If[FreeQ[BoundaryMatchingScale[[i,2]],DIAGONAL]==True,
Switch[Head[BoundaryMatchingScale[[i,1]]],
re,WriteString[file,SPhenoForm[BoundaryMatchingScale[[i,1,1]]]<>" = Cmplx(Real(" <> SPhenoForm[BoundaryMatchingScale[[i,2]]]  <>",dp),Aimag("<>SPhenoForm[BoundaryMatchingScale[[i,1,1]]]<> "))\n"];,
im,WriteString[file,SPhenoForm[BoundaryMatchingScale[[i,1,1]]]<>" = Cmplx(Real(" <>SPhenoForm[BoundaryMatchingScale[[i,1,1]]]<>",dp),Real("<> SPhenoForm[BoundaryMatchingScale[[i,2]]]  <> ",dp))\n"];,
_,WriteString[file,SPhenoForm[BoundaryMatchingScale[[i,1]]]<>" = " <> SPhenoForm[BoundaryMatchingScale[[i,2]]]<>"\n"];
];,
WriteString[file,SPhenoForm[BoundaryMatchingScale[[i,1]]]<>" = 0._dp \n"];
WriteString[file,"Do i1=1,"<>ToString[getDimSPheno[BoundaryMatchingScale[[i,1]]][[1]]]<>"\n"];
WriteString[file,SPhenoForm[BoundaryMatchingScale[[i,1]]]<>"(i1,i1) = " <> SPhenoForm[BoundaryMatchingScale[[i,2]] /. DIAGONAL->1]<>"\n"];
WriteString[file,"End Do\n"];
];
i++;];

WriteString[file,"Write(*,*) g1,g2,g3,Yu(3,3),Yd(3,3),Ye(3,3) \n"];

WriteString[file,"\n\n! Tadpoles \n"];
WriteTadpoleSolutionOnlyHigh[file];

WriteString[file,"\n\n! Masses \n"];
MakeCall["TreeMasses",Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{"GenerationMixing","kont"},file];

For[i=1,i<=Length[ParametrisationExternalStates],
For[j1=1,j1<=Length[ParametrisationExternalStates[[i,2]]],
For[j2=1,j2<=Length[ParametrisationExternalStates[[i,2]]],
WriteString[file,SPhenoForm[ParametrisationExternalStates[[i,1]]]<>"("<>ToString[j1]<>","<>ToString[j2]<>")="<>SPhenoForm[ParametrisationExternalStates[[i,2,j1,j2]]]<>"\n"];
j2++;];
j1++;];
i++;];

WriteString[file,"!! Only for comparison with literature \n"];
WriteString[file,"!Yu(1,1) = 0._dp \n"];
WriteString[file,"!Yu(2,2) = 0._dp \n"];
WriteString[file,"!Yu(1,1) = 0._dp \n"];
WriteString[file,"!Yd(2,2) = 0._dp \n"];
WriteString[file,"!Yd(1,1) = 0._dp \n"];
WriteString[file,"!Ye(2,2) = 0._dp \n"];
WriteString[file,"!Ye(1,1) = 0._dp \n"];
WriteString[file,"!Tu(2,2) = 0._dp \n"];
WriteString[file,"!Tu(1,1) = 0._dp \n"];
WriteString[file,"!Td(2,2) = 0._dp \n"];
WriteString[file,"!Td(1,1) = 0._dp \n"];
WriteString[file,"!Te(2,2) = 0._dp \n"];
WriteString[file,"!Te(1,1) = 0._dp \n\n"];

WriteString[file,"\n\n! Couplings \n"];
MakeCall["AllCouplingsReallyAll" , Join[parametersAllreallyAll,namesAllreallyAll],{},{},file];

WriteString[file,"\n\n! Wave-Functions \n"];
For[i=1,i<=Length[diffex],
MakeCall["MatchingFor"<>SPhenoForm[diffex[[i]]]<>"_Wave",Flatten[{NewMassParameters,namesAllreallyAll}],{},{"PiForMatching"<>ToString[diffex[[i]]]},file];
i++;];

For[i=1,i<=Length[match4diffFields],
subMatching=Join[subMatching,{((match4diffFields[[i]]/. Dot->List/. {f1_,f2_,f3_,f4_}->f1[a_].f2[b_].f3[c_].f4[d_]):>"res"<>NAME<>"("<>ToString[a]<>","<>ToString[b]<>","<>ToString[c]<>","<>ToString[d]<>")")/.NAME->StringReplace[SPhenoForm/@(match4diffFields[[i]] /. conj[x_]->C.x)//. Dot->StringJoin,{"("->"",")"->""}]}];
WriteString[file,"Do i1=1,"<>ToString[getGen[(match4diffFields[[i]]/. Dot->List)[[1]]]]<>"\n"];
WriteString[file," Do i2=1,"<>ToString[getGen[(match4diffFields[[i]]/. Dot->List)[[2]]]]<>"\n"];
WriteString[file,"  Do i3=1,"<>ToString[getGen[(match4diffFields[[i]]/. Dot->List)[[3]]]]<>"\n"];
WriteString[file,"   Do i4=1,"<>ToString[getGen[(match4diffFields[[i]]/. Dot->List)[[4]]]]<>"\n"];
MakeCall["      MatchingFor"<>(SPhenoForm/@(match4diffFields[[i]] /. conj[x_]->C.x)/. Dot->StringJoin),Flatten[{NewMassParameters,namesAllreallyAll,listMatchingWave}],{"i1","i2","i3","i4"},{"res"<>StringReplace[SPhenoForm/@(match4diffFields[[i]]/. conj[x_]->C.x) //. Dot->StringJoin,{"("->"",")"->""}]<>"(i1,i2,i3,i4)"},file];
WriteString[file,"   End Do\n"];
WriteString[file,"  End Do\n"];
WriteString[file," End Do\n"];
WriteString[file,"End Do\n\n"];
i++;];

For[i=1,i<=Length[match3diffFields],
subMatching=Join[subMatching,{((match3diffFields[[i]]/. Dot->List/. {f1_,f2_,f3_}->f1[a_].f2[b_].f3[c_]):>"res"<>NAME<>"("<>ToString[a]<>","<>ToString[b]<>","<>ToString[c]<>")")/.NAME->StringReplace[SPhenoForm/@(match4diffFields[[i]] /. conj[x_]->C.x)//. Dot->StringJoin,{"("->"",")"->""}]}];
WriteString[file,"Do i1=1,"<>ToString[getGen[(match4diffFields[[i]]/. Dot->List)[[1]]]]<>"\n"];
WriteString[file," Do i2=1,"<>ToString[getGen[(match4diffFields[[i]]/. Dot->List)[[2]]]]<>"\n"];
WriteString[file,"  Do i3=1,"<>ToString[getGen[(match4diffFields[[i]]/. Dot->List)[[3]]]]<>"\n"];
MakeCall["      MatchingFor"<>(SPhenoForm/@(match4diffFields[[i]] /. conj[x_]->C.x)/. Dot->StringJoin),Flatten[{NewMassParameters,namesAllreallyAll,listMatchingWave}],{"i1","i2","i3"},{"res"<>StringReplace[SPhenoForm/@(match4diffFields[[i]]/. conj[x_]->C.x) //. Dot->StringJoin,{"("->"",")"->""}]<>"(i1,i2,i3)"},file];
WriteString[file,"  End Do\n"];
WriteString[file," End Do\n"];
WriteString[file,"End Do\n\n"];
i++;];


For[i=1,i<=Length[HighscaleMatchingConditions],
WriteString[file,SPhenoForm[HighscaleMatchingConditions[[i,1]]]<>" = "<>SPhenoForm[HighscaleMatchingConditions[[i,3]]]<>"*("<>StringReplace[ToString[FortranForm[(HighscaleMatchingConditions[[i,2]]/. subMatching)]],"\""->""]<>")\n"]
i++;];

WriteString[file,"setscale = SetRenormalizationScale(scale_save) \n"];

WriteString[file,"End Subroutine MatchingRoutine_"<>ModelName <>"\n\n"];
];

WriteMatchingQuartic[fields_,file_]:=Block[{i,j,k,temp,res,nameRoutine,ctree,indtree,waveadded={},perfields,topology,diagrams,exf1,exf2,exf3,exf4,c1,c2,ind1,ind2,p1},
nameRoutine=SPhenoForm/@(fields/. A_[b_Integer]->A /. conj[x_]->C.x) /. Dot->StringJoin;
MakeSubroutineTitle["MatchingFor"<>nameRoutine,Flatten[{NewMassParameters,namesAllreallyAll,listMatchingWave}],{"gt1","gt2","gt3","gt4"},{"res"},file];
WriteString[file,"Implicit None \n"];
MakeVariableList[NewMassParameters,",Intent(in)",file];
MakeVariableList[namesAllreallyAll,",Intent(in)",file];
MakeVariableList[listMatchingWave,",Intent(in)",file];
WriteString[file,"Integer,Intent(in) :: gt1,gt2,gt3,gt4 \n"]; 
WriteString[file,"Integer :: i1 \n"]; 
WriteString[file,"Complex(dp), Intent(out) ::  res \n"];
WriteString[file,"Complex(dp) ::  temp \n"];

WriteString[file,"res=0._dp \n"];


WriteString[file,"! -----------------------------------------\n"];
WriteString[file,"! Tree-Level                           \n"];
WriteString[file,"! -----------------------------------------\n"];
ctree=getSPhenoCoupling2[C[fields[[1]],fields[[2]],fields[[3]],fields[[4]]],SPhenoCouplingsAllreallyAll];
indtree =MakeIndicesCoupling[{fields[[1]],gt1},{fields[[2]],gt2},{fields[[3]],gt3},{fields[[4]],gt4},ctree[[2]]];

WriteString[file,"If(Include_in_Thresholds_Tree) Then \n"];
WriteString[file," res="<>ToString[ctree[[1,1]]]<>indtree<>"! Check symmetry  \n"];
WriteString[file,"End if \n"];

WriteString[file,"If(Include_in_Thresholds_TreeProp) Then \n"];
perfields={fields,{fields[[1]],fields[[2]],fields[[4]],fields[[3]]},{fields[[1]],fields[[3]],fields[[2]],fields[[4]]}};
For[i=1,i<=Length[perfields],
exf1=perfields[[i,1]];
exf2=perfields[[i,2]];
exf3=perfields[[i,3]];
exf4=perfields[[i,4]];
topology={C[External[1],External[2],FieldToInsert[1]] ,C[External[3],External[4],FieldToInsert[1]]};
diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2], Internal[3]->FieldToInsert[3],External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexExternal[4]->ex4,IndexInternal[1]->i1,IndexInternal[2]->i2,IndexInternal[3]->i3},
{{{exf1,ex1},{exf2,ex2},{Internal[1],i1}},{{exf3,ex3},{exf4,ex4},{AntiField[Internal[1]],i1}}}}];
diagrams=Select[diagrams,FreeQ[IncludeParticlesInThresholds,RE[Internal[1]/.#[[2]]]]==False&];
If[Length[diagrams]>0,
WriteString[file,"\n! "<>ToString[i]<>".th Topology \n"];
Switch[i,
1,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt3 \n"];WriteString[file,"ex4=gt4 \n"];,
2,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt4 \n"];WriteString[file,"ex4=gt3 \n"];,
3,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt3 \n"];WriteString[file,"ex3=gt2 \n"];WriteString[file,"ex4=gt4 \n"];
];
];
For[j=1,j<=Length[diagrams],

(* get more handy names for the particles in the loop *)
p1=(Internal[1] /.diagrams[[j,2]]); 
WriteString[file,"! "<>ToString[p1] <>"\n"];

(* Extract the vertices *)
c1=getSPhenoCoupling2[diagrams[[j,1,1]],SPhenoCouplingsAllreallyAll];
c2=getSPhenoCoupling2[diagrams[[j,1,2]],SPhenoCouplingsAllreallyAll];

(* Generate the index structure *)
ind1 =MakeIndicesCouplingWrapper[diagrams[[j,3,1]]/.diagrams[[j,2]],c1[[2]]];
ind2 =MakeIndicesCouplingWrapper[diagrams[[j,3,2]]/.diagrams[[j,2]],c2[[2]]];

(* loop over generations of particles in the loop *)
If[getGenSPheno[p1]>1,WriteString[file,"Do i1=1,"<> ToString[GetGenerationFlag[p1]]<>"\n"];];
WriteString[file, "If (("<>SPhenoMassSq[p1,i1]<>".gt.MatchingThreshold)) Then\n"];
WriteVertexToFile[1,c1,ind1,getVertexType[diagrams[[j,1,1]]],file];
WriteVertexToFile[2,c2,ind2,getVertexType[diagrams[[j,1,2]]],file];
WriteString[file,"res = res + coup1*coup2/"<>SPhenoMassSq[p1,i1]<>"\n"];
WriteString[file, "End if \n"];

If[getGenSPheno[p1]>1,WriteString[file,"End Do \n"];];
j++;];
i++;];
WriteString[file,"End if \n"];

WriteString[file,"\n\n! -----------------------------------------\n"];
WriteString[file,"! Wave Function                           \n"];
WriteString[file,"! -----------------------------------------\n"];
WriteString[file,"If(Include_in_Thresholds_Wave) Then \n"];
WriteString[file,"Do i1=1,"<>ToString[getGen[fields[[1]]]]<>"\n"];
indtree =MakeIndicesCoupling[{fields[[1]],i1},{fields[[2]],gt2},{fields[[3]],gt3},{fields[[4]],gt4},ctree[[2]]];
WriteString[file,"res= res -0.5_dp*"<>ToString[ctree[[1,1]]]<>indtree<>"*PiForMatching"<>SPhenoForm[RE[fields[[1]]]]<>"(i1,gt1) \n"];
WriteString[file,"End Do\n"];
WriteString[file,"Do i1=1,"<>ToString[getGen[fields[[2]]]]<>"\n"];
indtree =MakeIndicesCoupling[{fields[[1]],gt1},{fields[[2]],i1},{fields[[3]],gt3},{fields[[4]],gt4},ctree[[2]]];
WriteString[file,"res= res -0.5_dp*"<>ToString[ctree[[1,1]]]<>indtree<>"*PiForMatching"<>SPhenoForm[RE[fields[[2]]]]<>"(i1,gt2) \n"];
WriteString[file,"End Do\n"];

WriteString[file,"Do i1=1,"<>ToString[getGen[fields[[3]]]]<>"\n"];
indtree =MakeIndicesCoupling[{fields[[1]],gt1},{fields[[2]],gt2},{fields[[3]],i1},{fields[[4]],gt4},ctree[[2]]];
WriteString[file,"res= res -0.5_dp*"<>ToString[ctree[[1,1]]]<>indtree<>"*PiForMatching"<>SPhenoForm[RE[fields[[3]]]]<>"(i1,gt3) \n"];
WriteString[file,"End Do\n"];

WriteString[file,"Do i1=1,"<>ToString[getGen[fields[[4]]]]<>"\n"];
indtree =MakeIndicesCoupling[{fields[[1]],gt1},{fields[[2]],gt2},{fields[[3]],gt3},{fields[[4]],i1},ctree[[2]]];
WriteString[file,"res= res -0.5_dp*"<>ToString[ctree[[1,1]]]<>indtree<>"*PiForMatching"<>SPhenoForm[RE[fields[[4]]]]<>"(i1,gt4) \n"];
WriteString[file,"End Do\n"];
waveadded=Join[waveadded,{fields[[4]]}];
WriteString[file,"End if \n"];

WriteString[file,"\n\n! -----------------------------------------\n"];
WriteString[file,"! Scalar Contributions                    \n"];
WriteString[file,"! -----------------------------------------\n"];

WriteString[file,"! D-Contributions \n"];
WriteString[file,"If(Include_in_Thresholds_ScalarD0) Then \n"];
MakeCall["  MatchingFor"<>nameRoutine<>"_ScalarD",Flatten[{NewMassParameters,namesAllreallyAll}],{"gt1","gt2","gt3","gt4"},{"temp"},file];
WriteString[file,"  res=res+temp  \n"];
WriteString[file,"End if \n"];

WriteString[file,"! C-Contributions \n"];
WriteString[file,"  If(Include_in_Thresholds_ScalarC0) Then \n"];
MakeCall["MatchingFor"<>nameRoutine<>"_ScalarC",Flatten[{NewMassParameters,namesAllreallyAll}],{"gt1","gt2","gt3","gt4"},{"temp"},file];
WriteString[file,"  res=res+temp  \n"];
WriteString[file,"End if \n\n"];

WriteString[file,"! B-Contributions \n"];
WriteString[file,"  If(Include_in_Thresholds_ScalarB0) Then \n"];
MakeCall["MatchingFor"<>nameRoutine<>"_ScalarB",Flatten[{NewMassParameters,namesAllreallyAll}],{"gt1","gt2","gt3","gt4"},{"temp"},file];
WriteString[file,"  res=res+temp  \n"];
WriteString[file,"End if \n\n"];



WriteString[file,"! -----------------------------------------\n"];
WriteString[file,"! Fermion Contributions                   \n"];
WriteString[file,"! -----------------------------------------\n"];

WriteString[file,"! D-Contributions \n"];
WriteString[file,"If(Include_in_Thresholds_Fermion) Then \n"];
MakeCall["  MatchingFor"<>nameRoutine<>"_FermionD",Flatten[{NewMassParameters,namesAllreallyAll}],{"gt1","gt2","gt3","gt4"},{"temp"},file];
WriteString[file,"  res=res+temp  \n"];
WriteString[file,"End if \n\n"];



WriteString[file,"End Subroutine MatchingFor"<>nameRoutine <>"\n\n"];

WriteMatchingContributions[fields,nameRoutine,"Scalar","D",file];
WriteMatchingContributions[fields,nameRoutine,"Scalar","C",file];
WriteMatchingContributions[fields,nameRoutine,"Scalar","B",file];
WriteMatchingContributions[fields,nameRoutine,"Fermion","D",file];

];

WriteMatchingCubic[fields_,file_]:=Block[{i,j,k,temp,res,nameRoutine,ctree,indtree,waveadded={}},
nameRoutine=SPhenoForm/@(fields/. A_[b_Integer]->A /. conj[x_]->C.x) /. Dot->StringJoin;
MakeSubroutineTitle["MatchingFor"<>nameRoutine,Flatten[{NewMassParameters,namesAllreallyAll,listMatchingWave}],{"gt1","gt2","gt3"},{"res"},file];
WriteString[file,"Implicit None \n"];
MakeVariableList[NewMassParameters,",Intent(in)",file];
MakeVariableList[namesAllreallyAll,",Intent(in)",file];
MakeVariableList[listMatchingWave,",Intent(in)",file];
WriteString[file,"Integer,Intent(in) :: gt1,gt2,gt3 \n"]; 
WriteString[file,"Integer :: i1 \n"]; 
WriteString[file,"Complex(dp), Intent(out) ::  res \n"];
WriteString[file,"Complex(dp) ::  temp \n"];

WriteString[file,"res=0._dp \n"];


WriteString[file,"! -----------------------------------------\n"];
WriteString[file,"! Tree-Level                           \n"];
WriteString[file,"! -----------------------------------------\n"];
ctree=getSPhenoCoupling2[C[fields[[1]],fields[[2]],fields[[3]]],SPhenoCouplingsAllreallyAll];
indtree =MakeIndicesCoupling[{fields[[1]],gt1},{fields[[2]],gt2},{fields[[3]],gt3},ctree[[2]]];

WriteString[file,"If(Include_in_Thresholds_Tree) Then \n"];
(* WriteString[file," res="<>SPhenoForm[Length[Permutations[fields]]/Factorial[4]]<>"*"<>ToString[ctree[[1,1]]]<>indtree<>"! Check symmetry  \n"]; *)
WriteString[file," res="<>ToString[ctree[[1,1]]]<>indtree<>"! Check symmetry  \n"];
WriteString[file,"End if \n"];

WriteString[file,"\n\n! -----------------------------------------\n"];
WriteString[file,"! Wave Function                           \n"];
WriteString[file,"! -----------------------------------------\n"];
WriteString[file,"If(Include_in_Thresholds_Wave) Then \n"];
WriteString[file,"Do i1=1,"<>ToString[getGen[fields[[1]]]]<>"\n"];
indtree =MakeIndicesCoupling[{fields[[1]],i1},{fields[[2]],gt2},{fields[[3]],gt3},ctree[[2]]];
WriteString[file,"res= res -0.5_dp*"<>ToString[ctree[[1,1]]]<>indtree<>"*PiForMatching"<>SPhenoForm[RE[fields[[1]]]]<>"(i1,gt1) \n"];
WriteString[file,"End Do\n"];
WriteString[file,"Do i1=1,"<>ToString[getGen[fields[[2]]]]<>"\n"];
indtree =MakeIndicesCoupling[{fields[[1]],gt1},{fields[[2]],i1},{fields[[3]],gt3},ctree[[2]]];
WriteString[file,"res= res -0.5_dp*"<>ToString[ctree[[1,1]]]<>indtree<>"*PiForMatching"<>SPhenoForm[RE[fields[[2]]]]<>"(i1,gt2) \n"];
WriteString[file,"End Do\n"];

WriteString[file,"Do i1=1,"<>ToString[getGen[fields[[3]]]]<>"\n"];
indtree =MakeIndicesCoupling[{fields[[1]],gt1},{fields[[2]],gt2},{fields[[3]],i1},ctree[[2]]];
WriteString[file,"res= res -0.5_dp*"<>ToString[ctree[[1,1]]]<>indtree<>"*PiForMatching"<>SPhenoForm[RE[fields[[3]]]]<>"(i1,gt3) \n"];
WriteString[file,"End Do\n"];


WriteString[file,"\n\n! -----------------------------------------\n"];
WriteString[file,"! Scalar Contributions                    \n"];
WriteString[file,"! -----------------------------------------\n"];

WriteString[file,"! C-Contributions \n"];
WriteString[file,"  If(Include_in_Thresholds_ScalarC0) Then \n"];
MakeCall["MatchingFor"<>nameRoutine<>"_ScalarC",Flatten[{NewMassParameters,namesAllreallyAll}],{"gt1","gt2","gt3"},{"temp"},file];
WriteString[file,"  res=res+temp  \n"];
WriteString[file,"End if \n\n"];

WriteString[file,"! B-Contributions \n"];
WriteString[file,"  If(Include_in_Thresholds_ScalarB0) Then \n"];
MakeCall["MatchingFor"<>nameRoutine<>"_ScalarB",Flatten[{NewMassParameters,namesAllreallyAll}],{"gt1","gt2","gt3"},{"temp"},file];
WriteString[file,"  res=res+temp  \n"];
WriteString[file,"End if \n\n"];



WriteString[file,"! -----------------------------------------\n"];
WriteString[file,"! Fermion Contributions                   \n"];
WriteString[file,"! -----------------------------------------\n"];

WriteString[file,"If(Include_in_Thresholds_Fermion) Then \n"];
MakeCall["  MatchingFor"<>nameRoutine<>"_FermionC",Flatten[{NewMassParameters,namesAllreallyAll}],{"gt1","gt2","gt3"},{"temp"},file];
WriteString[file,"  res=res+temp  \n"];
WriteString[file,"End if \n\n"];



WriteString[file,"End Subroutine MatchingFor"<>nameRoutine <>"\n\n"];

WriteMatchingContributions[fields,nameRoutine,"Scalar","C",file];
WriteMatchingContributions[fields,nameRoutine,"Scalar","B",file];
WriteMatchingContributions[fields,nameRoutine,"Fermion","C",file];
];

WriteMatchingContributions[fields_,nameRoutine_,type_,top_,file_]:=Block[{i,j,k,perfields,topologyD0,exf1,exf2,exf3,exf4,p1,p2,p3,p4,c1,c2,c3,c4,ind1,ind2,ind3,ind4,nrint,diagrams},


MakeSubroutineTitle["MatchingFor"<>nameRoutine<>"_"<>type<>top,Flatten[{NewMassParameters,namesAllreallyAll}],If[Length[fields]==4,{"gt1","gt2","gt3","gt4"},{"gt1","gt2","gt3"}],{"res"},file];
WriteString[file,"Implicit None \n"];
MakeVariableList[NewMassParameters,",Intent(in)",file];
MakeVariableList[namesAllreallyAll,",Intent(in)",file];
If[Length[fields]==4,
WriteString[file,"Integer,Intent(in) :: gt1,gt2,gt3,gt4 \n"];,
WriteString[file,"Integer,Intent(in) :: gt1,gt2,gt3 \n"]; 
]; 
WriteString[file,"Integer :: i1,i2,i3,i4 \n"];
WriteString[file,"Integer :: ex1,ex2,ex3,ex4 \n"];
If[type==="Fermion",
WriteString[file,"Complex(dp) ::  coup1L, coup2L, coup3L, coup4L \n"];
WriteString[file,"Complex(dp) ::  coup1R, coup2R, coup3R, coup4R \n"];,
WriteString[file,"Complex(dp) ::  coup1, coup2, coup3, coup4 \n"];
];
WriteString[file,"Complex(dp), Intent(out) ::  res \n\n"];

WriteString[file,"res = 0._dp \n"];

(* independent permutations *)
Switch[Length[fields],
4,
Switch[top,
"D",
perfields={fields,{fields[[1]],fields[[2]],fields[[4]],fields[[3]]},{fields[[1]],fields[[3]],fields[[2]],fields[[4]]}};
nrint=4;,
"C" | "CP",
perfields={fields,{fields[[1]],fields[[3]],fields[[2]],fields[[4]]},{fields[[1]],fields[[4]],fields[[3]],fields[[2]]},
{fields[[3]],fields[[4]],fields[[1]],fields[[2]]},{fields[[2]],fields[[4]],fields[[1]],fields[[3]]},{fields[[3]],fields[[2]],fields[[1]],fields[[4]]}};
If[top==="C",nrint=3;,nrint=4;];,
"B" | "BP",
perfields={fields,{fields[[1]],fields[[4]],fields[[2]],fields[[3]]},{fields[[1]],fields[[3]],fields[[2]],fields[[4]]}};
If[top==="B",nrint=2;,nrint=3;];
];,
3,
Switch[top,
"C",
perfields=fields;
nrint=3;,
"B",
perfields={fields,{fields[[2]],fields[[1]],fields[[3]]},{fields[[3]],fields[[1]],fields[[2]]}};
nrint=2;
];
];

For[i=1,i<=Length[perfields],

exf1=perfields[[i,1]];
exf2=perfields[[i,2]];
exf3=perfields[[i,3]];
If[Length[fields]===4,exf4=perfields[[i,4]];];

WriteString[file,"! -------------------------------------------------\n"];
WriteString[file,"! "<>ToString[i]<>". Topology \n"];
WriteString[file,"! -------------------------------------------------\n"];

Switch[{Length[fields],top},
{4,"D"} ,
Switch[i,
1,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt3 \n"];WriteString[file,"ex4=gt4 \n"];,
2,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt4 \n"];WriteString[file,"ex4=gt3 \n"];,
3,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt3 \n"];WriteString[file,"ex3=gt2 \n"];WriteString[file,"ex4=gt4 \n"];
];,
{4,"C"} |  {4,"CP"} ,
Switch[i,
1,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt3 \n"];WriteString[file,"ex4=gt4 \n"];,
2,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt3 \n"];WriteString[file,"ex3=gt2 \n"];WriteString[file,"ex4=gt4 \n"];,
3,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt4 \n"];WriteString[file,"ex3=gt3 \n"];WriteString[file,"ex4=gt2 \n"];,
4,WriteString[file,"ex3=gt1 \n"];WriteString[file,"ex4=gt2 \n"];WriteString[file,"ex1=gt3 \n"];WriteString[file,"ex2=gt4 \n"];,
5,WriteString[file,"ex3=gt1 \n"];WriteString[file,"ex4=gt3 \n"];WriteString[file,"ex1=gt2 \n"];WriteString[file,"ex2=gt4 \n"];,
6,WriteString[file,"ex3=gt1 \n"];WriteString[file,"ex4=gt4 \n"];WriteString[file,"ex1=gt3 \n"];WriteString[file,"ex2=gt2 \n"];
];,
{4,"B"} | {4,"BP"},
Switch[i,
1,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt3 \n"];WriteString[file,"ex4=gt4 \n"];,
2,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt4 \n"];WriteString[file,"ex4=gt3 \n"];,
3,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt3 \n"];WriteString[file,"ex3=gt2 \n"];WriteString[file,"ex4=gt4 \n"];
];,
{3,"C"},WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt3 \n"];,
{3,"B"},
Switch[i,
1,WriteString[file,"ex1=gt1 \n"];WriteString[file,"ex2=gt2 \n"];WriteString[file,"ex3=gt3 \n"];,
2,WriteString[file,"ex1=gt2 \n"];WriteString[file,"ex2=gt1 \n"];WriteString[file,"ex3=gt3 \n"];,
3,WriteString[file,"ex1=gt3 \n"];WriteString[file,"ex2=gt1 \n"];WriteString[file,"ex3=gt2 \n"];
];
];

diagrams=GenerateMatchingDiagrams[If[Length[fields]===4,{exf1,exf2,exf3,exf4},{exf1,exf2,exf3}],type,top];


For[j=1,j<=Length[diagrams],

(* get more handy names for the particles in the loop *)
Switch[nrint,
4,
p1=(Internal[1] /.diagrams[[j,2]]); p2 =(Internal[2] /. diagrams[[j,2]]);p3 =(Internal[3] /. diagrams[[j,2]]); p4 =(Internal[4] /. diagrams[[j,2]]);
WriteString[file,"! "<>ToString[p1] <>","<>ToString[p2] <>","<>ToString[p3] <>","<>ToString[p4] <>"\n"];,
3,
p1=(Internal[1] /.diagrams[[j,2]]); p2 =(Internal[2] /. diagrams[[j,2]]);p3 =(Internal[3] /. diagrams[[j,2]]);
WriteString[file,"! "<>ToString[p1] <>","<>ToString[p2] <>","<>ToString[p3] <>"\n"];,
2,
p1=(Internal[1] /.diagrams[[j,2]]); p2 =(Internal[2] /. diagrams[[j,2]]);
WriteString[file,"! "<>ToString[p1] <>","<>ToString[p2]  <>"\n"];
]; 


(* Extract the vertices *)
c1=getSPhenoCoupling2[diagrams[[j,1,1]],SPhenoCouplingsAllreallyAll];
c2=getSPhenoCoupling2[diagrams[[j,1,2]],SPhenoCouplingsAllreallyAll];
If[nrint>2,c3=getSPhenoCoupling2[diagrams[[j,1,3]],SPhenoCouplingsAllreallyAll];];
If[nrint>3,c4=getSPhenoCoupling2[diagrams[[j,1,4]],SPhenoCouplingsAllreallyAll];];

(* Generate the index structure *)
ind1 =MakeIndicesCouplingWrapper[diagrams[[j,3,1]]/.diagrams[[j,2]],c1[[2]]];
ind2 =MakeIndicesCouplingWrapper[diagrams[[j,3,2]]/.diagrams[[j,2]],c2[[2]]];
If[nrint>2,ind3 =MakeIndicesCouplingWrapper[diagrams[[j,3,3]]/.diagrams[[j,2]],c3[[2]]];];
If[nrint>3,ind4 =MakeIndicesCouplingWrapper[diagrams[[j,3,4]]/.diagrams[[j,2]],c4[[2]]];];

(* loop over generations of particles in the loop *)
If[getGenSPheno[p1]>1,WriteString[file,"Do i1=1,"<> ToString[GetGenerationFlag[p1]]<>"\n"];];
If[getGenSPheno[p2]>1,WriteString[file,"  Do i2=1,"<> ToString[GetGenerationFlag[p2]]<>"\n"];];
If[nrint>2,If[getGenSPheno[p3]>1,WriteString[file,"    Do i3=1,"<> ToString[GetGenerationFlag[p3]]<>"\n"];];];
If[nrint>3,If[getGenSPheno[p4]>1,WriteString[file,"      Do i4=1,"<> ToString[GetGenerationFlag[p4]]<>"\n"];];];

(* Check if any mass is heavier than the thresholds *)
Switch[nrint,
4,
WriteString[file, "If (("<>SPhenoMassSq[p1,i1]<>".gt.MatchingThreshold).Or.("<>SPhenoMassSq[p2,i2]<>".gt.MatchingThreshold).Or.("<>SPhenoMassSq[p3,i3]<>".gt.MatchingThreshold).Or.("<>SPhenoMassSq[p4,i4]<>".gt.MatchingThreshold)) Then\n"];,
3,
WriteString[file, "If (("<>SPhenoMassSq[p1,i1]<>".gt.MatchingThreshold).Or.("<>SPhenoMassSq[p2,i2]<>".gt.MatchingThreshold).Or.("<>SPhenoMassSq[p3,i3]<>".gt.MatchingThreshold)) Then\n"];,
2,
WriteString[file, "If (("<>SPhenoMassSq[p1,i1]<>".gt.MatchingThreshold).Or.("<>SPhenoMassSq[p2,i2]<>".gt.MatchingThreshold)) Then\n"];
];

(* Write the vertices to Fortran code *)
WriteVertexToFile[1,c1,ind1,getVertexType[diagrams[[j,1,1]]],file];
WriteVertexToFile[2,c2,ind2,getVertexType[diagrams[[j,1,2]]],file];
If[nrint>2,WriteVertexToFile[3,c3,ind3,getVertexType[diagrams[[j,1,3]]],file];];
If[nrint>3,WriteVertexToFile[4,c4,ind4,getVertexType[diagrams[[j,1,4]]],file];];

(* Calculate the color factor *)
cfactor = getChargeFactor[diagrams[[j]],diagrams[[j,3]] /. diagrams[[j,2]] /. {i1->in1,i2->in2,i3->in3,i4->in4}];

Switch[type,
"Fermion",
Switch[Length[fields],
4,
WriteString[file,"res = res + "<>SPhenoForm[cfactor]<>"*ScalarQuarticFermionDiagram(coup1L,coup1R,coup2L,coup2R,coup3L,coup3R,coup4L,coup4R,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>","<>SPhenoMassSq[p3,i3]<>","<>SPhenoMassSq[p4,i4]<>") \n"];,
3,
WriteString[file,"res = res + "<>SPhenoForm[cfactor]<>"*ScalarCubicFermionDiagram(coup1L,coup1R,coup2L,coup2R,coup3L,coup3R,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>","<>SPhenoMassSq[p3,i3]<>") \n"];
];,
"Scalar",
Switch[{Length[fields],top},
{4,"D"},
WriteString[file,"res = res + "<>SPhenoForm[cfactor]<>"*ScalarQuarticScalarD0diagram(coup1,coup2,coup3,coup4,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>","<>SPhenoMassSq[p3,i3]<>","<>SPhenoMassSq[p4,i4]<>") \n"];,
{4,"C"},
WriteString[file,"res = res + "<>SPhenoForm[cfactor]<>"*ScalarQuarticScalarC0diagram(coup1,coup2,coup3,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>","<>SPhenoMassSq[p3,i3]<>") \n"];,
{4,"CP"},
WriteString[file,"res = res + coup4/"<>SPhenoMassSq[p4,i4]<>"*"<>SPhenoForm[cfactor]<>"*ScalarQuarticScalarC0diagram(coup1,coup2,coup3,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>","<>SPhenoMassSq[p3,i3]<>") \n"];,
{4,"B"},
WriteString[file,"res = res + "<>SPhenoForm[cfactor]<>"*ScalarQuarticScalarB0diagram(coup1,coup2,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>") \n"];,
{4,"BP"},
WriteString[file,"res = res + coup3/"<>SPhenoMassSq[p3,i3]<>"*"<>SPhenoForm[cfactor]<>"*ScalarQuarticScalarB0diagram(coup1,coup2,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>") \n"];,
{3,"C"},
WriteString[file,"res = res + "<>SPhenoForm[cfactor]<>"*ScalarCubicScalarC0diagram(coup1,coup2,coup3,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>","<>SPhenoMassSq[p3,i3]<>") \n"];,
{3,"B"},
WriteString[file,"res = res + "<>SPhenoForm[cfactor]<>"*ScalarCubicScalarB0diagram(coup1,coup2,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>","<>") \n"];
];
];
WriteString[file, "End if \n"];

If[nrint>3,If[getGenSPheno[p4]>1,WriteString[file,"    End Do \n"];];];
If[nrint>2,If[getGenSPheno[p3]>1,WriteString[file,"   End Do \n"];];];
If[getGenSPheno[p2]>1,WriteString[file,"  End Do \n"];];
If[getGenSPheno[p1]>1,WriteString[file,"End Do \n"];];
j++;];
(* ]; *)
 i++;]; 

WriteString[file, "res=oo16pi2*res \n"];
WriteString[file,"End Subroutine MatchingFor"<>nameRoutine <>"_"<>type<>top<>" \n\n"];
];


WriteMatchingWaveContributions[field_,nameRoutine_,file_]:=Block[{i,j,k,perfields,topologyD0,exf1,exf2,exf3,exf4,p1,p2,p3,p4,c1,c2,c3,c4,ind1,ind2,ind3,ind4,diagramsAll,diagrams},


MakeSubroutineTitle["MatchingFor"<>nameRoutine<>"_Wave",Flatten[{NewMassParameters,namesAllreallyAll}],{},{"res"},file];
WriteString[file,"Implicit None \n"];
MakeVariableList[NewMassParameters,",Intent(in)",file];
MakeVariableList[namesAllreallyAll,",Intent(in)",file];
WriteString[file,"Integer :: i1,i2 \n"];
WriteString[file,"Integer :: ex1,ex2 \n"];
WriteString[file,"Complex(dp) ::  coup1, coup2, coup1L, coup1R, coup2L, coup2R \n"];
WriteString[file,"Complex(dp), Intent(out) ::  res("<>ToString[getGen[field]]<>","<>ToString[getGen[field]]<>") \n"];

WriteString[file,"res = 0._dp \n"];


If[getGenSPheno[field]>1,WriteString[file,"Do ex1=1,"<> ToString[GetGenerationFlag[field]]<>"\n"];];
If[getGenSPheno[field]>1,WriteString[file,"  Do ex2=1,"<> ToString[GetGenerationFlag[field]]<>"\n"];];
topologyB0={C[External[1],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[External[2],FieldToInsert[2],AntiField[FieldToInsert[1]]]};

(* insert all fields in the given model *)
diagramsAll=InsFields[{topologyB0/.{External[1]->field,External[2]->AntiField[field]},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2],External[1]->field,External[2]->AntiField[field],IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexInternal[1]->i1,IndexInternal[2]->i2}}];

For[i=1,i<=2,
If[i==1,
diagrams=Select[diagramsAll,Intersection[getType/@({Internal[1],Internal[2]}/.#[[2]])] == {S}&];,
diagrams=Select[diagramsAll,Intersection[getType/@({Internal[1],Internal[2]}/.#[[2]])] == {F}&];
];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2],Internal[3],Internal[4]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];

For[j=1,j<=Length[diagrams],

(* get more handy names for the particles in the loop *)
p1=(Internal[1] /.diagrams[[j,2]]); p2 =(Internal[2] /. diagrams[[j,2]]);

(* write a comment to the Fortran code what particles are in the loop *)
WriteString[file,"! "<>ToString[p1] <>","<>ToString[p2] <>"\n"]; 


(* Extract the vertices *)
c1=getSPhenoCoupling2[diagrams[[j,1,1]],SPhenoCouplingsAllreallyAll];
c2=getSPhenoCoupling2[diagrams[[j,1,2]],SPhenoCouplingsAllreallyAll];

(* Generate the index structure *)
ind1 =MakeIndicesCoupling[{External[1],IndexExternal[1]}/.diagrams[[j,2]],{Internal[1],i1}/.diagrams[[j,2]],{AntiField[Internal[2]],i2}/.diagrams[[j,2]],c1[[2]]];
ind2 =MakeIndicesCoupling[{External[2],IndexExternal[2]}/.diagrams[[j,2]],{Internal[2],i2}/.diagrams[[j,2]],{AntiField[Internal[1]],i1}/.diagrams[[j,2]],c2[[2]]]; 


(* loop over generations of particles in the loop *)
If[getGenSPheno[p1]>1,WriteString[file,"Do i1=1,"<> ToString[GetGenerationFlag[p1]]<>"\n"];];
If[getGenSPheno[p2]>1,WriteString[file,"  Do i2=1,"<> ToString[GetGenerationFlag[p2]]<>"\n"];];

(* Check if any mass is heavier than the thresholds *)
WriteString[file, "If (("<>SPhenoMassSq[p1,i1]<>".gt.MatchingThreshold).Or.("<>SPhenoMassSq[p2,i2]<>".gt.MatchingThreshold)) Then\n"];

(* Write the vertices to Fortran code *)
WriteVertexToFile[1,c1,ind1,getVertexType[diagrams[[j,1,1]]],file];
WriteVertexToFile[2,c2,ind2,getVertexType[diagrams[[j,1,2]]],file];

(* Calculate the color factor *)
cfactor = getChargeFactor[diagrams[[j]],{{{External[1],ex1},{Internal[1],in1},{AntiField[Internal[2]],in2}},
{{External[2],ex2},{AntiField[Internal[1]],in1},{Internal[2],in2}}} /. diagrams[[j,2]]];

If[i==1,
WriteString[file,"If ((ex1.eq.ex2).or.("<>SPhenoMassSq[External[1]/.diagrams[[j,2]],ex1]<>".eq."<>SPhenoMassSq[External[2]/.diagrams[[j,2]],ex2]<>" )) Then \n"];
WriteString[file,"  res(ex1,ex2) = res(ex1,ex2) + "<>SPhenoForm[cfactor]<>"*ScalarWaveScalardiagram(coup1,coup2,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>") \n"];
WriteString[file,"Else \n"];
WriteString[file,"  res(ex1,ex2) = res(ex1,ex2) + 2._dp/("<>SPhenoMassSq[External[1]/.diagrams[[j,2]],ex1]<>"-"<>SPhenoMassSq[External[2]/.diagrams[[j,2]],ex2]<>" )*"<>SPhenoForm[cfactor]<>"*ScalarWaveOffScalardiagram(coup1,coup2,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>") \n"];
WriteString[file,"End if \n"];,
WriteString[file,"If (ex1.eq.ex2).or.("<>SPhenoMassSq[External[1]/.diagrams[[j,2]],ex1]<>".eq."<>SPhenoMassSq[External[2]/.diagrams[[j,2]],ex2]<>" )) Then \n"];
WriteString[file,"  res(ex1,ex2) = res(ex1,ex2) + "<>SPhenoForm[cfactor]<>"*ScalarWaveFermiondiagram(coup1L,coup1R,coup2L,coup2R,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>") \n"];
WriteString[file,"Else \n"];
WriteString[file,"  res(ex1,ex2) = res(ex1,ex2) + 2._dp/("<>SPhenoMassSq[External[1]/.diagrams[[j,2]],ex1]<>"-"<>SPhenoMassSq[External[2]/.diagrams[[j,2]],ex2]<>" )*"<>SPhenoForm[cfactor]<>"*ScalarWaveOffFermiondiagram(coup1L,coup1R,coup2L,coup2R,"<>SPhenoMassSq[p1,i1]<>","<>SPhenoMassSq[p2,i2]<>") \n"];
WriteString[file,"End if \n"];
];

WriteString[file, "End if \n"];

If[getGenSPheno[p1]>1,WriteString[file,"    End Do \n"];];
If[getGenSPheno[p2]>1,WriteString[file,"   End Do \n"];];
j++;];
i++;];

topology={C[External[1],External[2],FieldToInsert[1],AntiField[FieldToInsert[1]]] };

(* insert all fields in the given model *)
diagramsAll=InsFields[{topology/.{External[1]->field,External[2]->AntiField[field]},{Internal[1]->FieldToInsert[1],External[1]->field,External[2]->AntiField[field],IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexInternal[1]->i1}}];

diagrams=Select[diagramsAll,Intersection[getType/@({Internal[1]}/.#[[2]])] == {S}&];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];

For[j=1,j<=Length[diagrams],

(* get more handy names for the particles in the loop *)
p1=(Internal[1] /.diagrams[[j,2]]); 

(* write a comment to the Fortran code what particles are in the loop *)
WriteString[file,"! "<>ToString[p1]  <>"\n"]; 


(* Extract the vertices *)
c1=getSPhenoCoupling2[diagrams[[j,1,1]],SPhenoCouplingsAllreallyAll];

(* Generate the index structure *)
ind1 =MakeIndicesCoupling4[{External[1],IndexExternal[1]}/.diagrams[[j,2]],{External[2],IndexExternal[2]}/.diagrams[[j,2]],{Internal[1],i1}/.diagrams[[j,2]],{AntiField[Internal[1]],i1}/.diagrams[[j,2]],c1[[2]]];


(* loop over generations of particles in the loop *)
If[getGenSPheno[p1]>1,WriteString[file,"Do i1=1,"<> ToString[GetGenerationFlag[p1]]<>"\n"];];


(* Check if any mass is heavier than the thresholds *)
WriteString[file, "If (("<>SPhenoMassSq[p1,i1]<>".gt.MatchingThreshold)) Then\n"];

(* Write the vertices to Fortran code *)
WriteVertexToFile[1,c1,ind1,getVertexType[diagrams[[j,1,1]]],file];

(* Calculate the color factor *)
cfactor = getChargeFactor[diagrams[[j]],{{{External[1],ex1},{External[2],ex2},{Internal[1],in1},{AntiField[Internal[1]],in1}}} /. diagrams[[j,2]]];

WriteString[file,"If (ex1.eq.ex2).or.("<>SPhenoMassSq[External[1]/.diagrams[[j,2]],ex1]<>".eq."<>SPhenoMassSq[External[2]/.diagrams[[j,2]],ex2]<>" )) Then \n"];
WriteString[file,"  res(ex1,ex2) = res(ex1,ex2) + 0._dp \n"];
WriteString[file,"Else \n"];
WriteString[file,"  res(ex1,ex2) = res(ex1,ex2) + 2._dp/("<>SPhenoMassSq[External[1]/.diagrams[[j,2]],ex1]<>"-"<>SPhenoMassSq[External[2]/.diagrams[[j,2]],ex2]<>" )*"<>SPhenoForm[cfactor]<>"*ScalarWaveOffScalardiagramA0(coup1,"<>SPhenoMassSq[p1,i1]<>") \n"];
WriteString[file,"End if \n"];

WriteString[file, "End if \n"];

If[getGenSPheno[p2]>1,WriteString[file,"   End Do \n"];];
j++;];



If[getGenSPheno[field]>1,WriteString[file,"  End Do\n"];];
If[getGenSPheno[field]>1,WriteString[file,"End Do\n"];];

WriteString[file, "res=oo16pi2*res \n"];
WriteString[file,"End Subroutine MatchingFor"<>nameRoutine <>"_Wave \n\n"];
];


(* ::Input::Initialization:: *)
GenerateMatchingDiagrams[{exf1_,exf2_,exf3_,exf4_},"Scalar","B"]:=Block[{topology,diagrams},
topology={C[External[1],External[2],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[External[3],External[4],FieldToInsert[2],AntiField[FieldToInsert[1]]]};

(* insert all fields in the given model *)
diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2],External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexExternal[4]->ex4,IndexInternal[1]->i1,IndexInternal[2]->i2},
{{{exf1,ex1},{exf2,ex2},{Internal[1],i1},{AntiField[Internal[2]],i2}},{{exf3,ex3},{exf4,ex4},{Internal[2],i2},{AntiField[Internal[1]],i1}}}}];

(* drop diagrams with vector bosons and fermions *)
diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2]}/.#[[2]])] == {S}&];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];
Return[diagrams];
];

GenerateMatchingDiagrams[{exf1_,exf2_,exf3_,exf4_},"Scalar","BP"]:=Block[{topology,diagrams},
topology={C[External[1],External[2],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[FieldToInsert[3],FieldToInsert[2],AntiField[FieldToInsert[1]]],C[External[3],External[4],AntiField[FieldToInsert[3]]]};

(* insert all fields in the given model *)
diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2], Internal[3]->FieldToInsert[3],External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexExternal[4]->ex4,IndexInternal[1]->i1,IndexInternal[2]->i2,IndexInternal[3]->i3},
{{{exf1,ex1},{exf2,ex2},{Internal[1],i1},{AntiField[Internal[2]],i2}},{{Internal[3],in3},{Internal[2],i2},{AntiField[Internal[1]],i1}},{{exf3,ex3},{exf4,ex4},{AntiField[Internal[3]],i3}}}}];

(* drop diagrams with vector bosons and fermions *)
diagrams=Select[diagrams,Intersection[{RE[Internal[3]/.#[[2]]]},IncludeParticlesInThresholds]=!={}&]; (* propgator always needs to be heavy *)
diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2]}/.#[[2]])] == {S}&];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];
Return[diagrams];
];

GenerateMatchingDiagrams[{exf1_,exf2_,exf3_,exf4_},"Scalar","C"]:=Block[{topology,diagrams},
topology={C[External[1],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[External[2],FieldToInsert[2],AntiField[FieldToInsert[3]]],C[External[3],External[4],FieldToInsert[3],AntiField[FieldToInsert[1]]]};

diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3],External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexExternal[4]->ex4,IndexInternal[1]->i1,IndexInternal[2]->i2,IndexInternal[3]->i3},
{{{exf1,ex1},{Internal[1],i1},{AntiField[Internal[2]],i2}},{{exf2,ex2},{Internal[2],i2},{AntiField[Internal[3]],i3}},{{exf3,ex3},{exf4,ex4},{Internal[3],i3},{AntiField[Internal[1]],i1}}}}];

diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2],Internal[3]}/.#[[2]])] == {S}&];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2],Internal[3]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];
Return[diagrams];
];

GenerateMatchingDiagrams[{exf1_,exf2_,exf3_,exf4_},"Scalar","CP"]:=Block[{topology,diagrams},
topology={C[External[1],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[External[2],FieldToInsert[2],AntiField[FieldToInsert[3]]],C[FieldToInsert[4],FieldToInsert[3],AntiField[FieldToInsert[1]]],C[External[3],External[4],AntiField[FieldToInsert[4]]]};

diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3],Internal[4]->FieldToInsert[4],External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexExternal[4]->ex4,IndexInternal[1]->i1,IndexInternal[2]->i2,IndexInternal[3]->i3,IndexInternal[4]->i4},
{{{exf1,ex1},{Internal[1],i1},{AntiField[Internal[2]],i2}},{{exf2,ex2},{Internal[2],i2},{AntiField[Internal[3]],i3}},{{Internal[4],i4},{Internal[3],i3},{AntiField[Internal[1]],i1}},{{exf3,ex3},{exf4,ex4},{AntiField[Internal[4]],i4}}}}];

diagrams=Select[diagrams,Intersection[{RE[Internal[4]/.#[[2]]]},IncludeParticlesInThresholds]=!={}&]; (* propgator always needs to be heavy *)
diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2],Internal[3]}/.#[[2]])] == {S}&];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2],Internal[3]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];
Return[diagrams];
];

GenerateMatchingDiagrams[{exf1_,exf2_,exf3_},"Scalar","B"]:=Block[{topology,diagrams},
topology={C[External[1],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[External[2],External[3],FieldToInsert[2],AntiField[FieldToInsert[1]]]};

diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2],External[1]->exf1,External[2]->exf2,External[3]->exf3,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexInternal[1]->i1,IndexInternal[2]->i2},
{{{exf1,ex1},{Internal[1],i1},{AntiField[Internal[2]],i2}},{{exf2,ex2},{exf3,ex3},{Internal[2],i2},{AntiField[Internal[1]],i1}}}}];

diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2]}/.#[[2]])] == {S}&];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];
Return[diagrams];
];

GenerateMatchingDiagrams[{exf1_,exf2_,exf3_,exf4_},type_,"D"]:=Block[{topology,diagrams},
topology={C[External[1],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[External[2],FieldToInsert[2],AntiField[FieldToInsert[3]]],C[External[3],FieldToInsert[3],AntiField[FieldToInsert[4]]],C[External[4],AntiField[FieldToInsert[1]],FieldToInsert[4]]};

diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3], Internal[4]->FieldToInsert[4],External[1]->exf1,External[2]->exf2,External[3]->exf3,External[4]->exf4,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexExternal[4]->ex4,IndexInternal[1]->i1,IndexInternal[2]->i2,IndexInternal[3]->i3,IndexInternal[4]->i4},
{{{exf1,ex1},{Internal[1],i1},{AntiField[Internal[2]],i2}},{{exf2,ex2},{Internal[2],i2},{AntiField[Internal[3]],i3}},{{exf3,ex3},{Internal[3],i3},{AntiField[Internal[4]],i4}},{{exf4,ex4},{AntiField[Internal[1]],i1},{Internal[4],i4}}}}];

If[type==="Fermion",
diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2],Internal[3],Internal[4]}/.#[[2]])] == {F}&];,
diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2],Internal[3],Internal[4]}/.#[[2]])] == {S}&];
];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2],Internal[3],Internal[4]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];
Return[diagrams];
];

GenerateMatchingDiagrams[{exf1_,exf2_,exf3_},type_,"C"]:=Block[{topology,diagrams},
topology={C[External[1],FieldToInsert[1],AntiField[FieldToInsert[2]]] ,C[External[2],FieldToInsert[2],AntiField[FieldToInsert[3]]],C[External[3],FieldToInsert[3],AntiField[FieldToInsert[1]]]};

diagrams=InsFields[{topology/.{External[1]->exf1,External[2]->exf2,External[3]->exf3},{Internal[1]->FieldToInsert[1], Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3], IExternal[1]->exf1,External[2]->exf2,External[3]->exf3,IndexExternal[1]->ex1,IndexExternal[2]->ex2,IndexExternal[3]->ex3,IndexInternal[1]->i1,IndexInternal[2]->i2,IndexInternal[3]->i3},
{{{exf1,ex1},{Internal[1],i1},{AntiField[Internal[2]],i2}},{{exf2,ex2},{Internal[2],i2},{AntiField[Internal[3]],i3}},{{exf3,ex3},{Internal[3],i3},{AntiField[Internal[1]],i1}}}}];

If[type==="Fermion",
diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2],Internal[3]}/.#[[2]])] == {F}&];,
diagrams=Select[diagrams,Intersection[getType/@({Internal[1],Internal[2],Internal[3]}/.#[[2]])] == {S}&];
];
diagrams=Select[diagrams,Intersection[RE/@({Internal[1],Internal[2],Internal[3]}/.#[[2]]),IncludeParticlesInThresholds]=!={}&];
Return[diagrams];
];


(* ::Input::Initialization:: *)
RunHighScaleModel[readL_]:=Block[{i,sphenofile},
(* Wrapper routine to run high scale model *)
Print[StyleForm["Run high scale model and generate matching","Section",FontSize->12]];
WriteSPhenoFile[readL];
RunModel[readL];
IncludeFiles;
];

IncludeFiles:=Block[{i,files},
(* copy files from the high scale model to the current model *)
$sarahSPhenoMatchDir=ToFileName[{$sarahCurrentSPhenoDir,MatchingToModel<>"To"<>ModelName}];
If[FileExistsQ[$sarahSPhenoMatchDir]=!=True,
CreateDirectory[$sarahSPhenoMatchDir];
];

files={"Model_Data_"<>MatchingToModel<>"To"<>ModelName<>".f90","Couplings_"<>MatchingToModel<>"To"<>ModelName<>".f90","TreeLevelMasses_"<>MatchingToModel<>"To"<>ModelName<>".f90","TadpoleEquations_"<>MatchingToModel<>"To"<>ModelName<>".f90","Matching_"<>MatchingToModel<>"To"<>ModelName<>".f90"};
For[i=1,i<=Length[files],
If[FileExistsQ[ToFileName[$sarahSPhenoMatchDir,files[[i]]]],DeleteFile[ToFileName[$sarahSPhenoMatchDir,files[[i]]]]];
CopyFile[ToFileName[ToFileName[{$sarahOutputDir,MatchingToModel,"EWSB","SPheno"<>MatchingToModel<>"To"<>ModelName}],files[[i]]],ToFileName[$sarahSPhenoMatchDir,files[[i]]]];
i++;];


];

RunModel[readL_]:=Block[{},
(* run high scale model in new mathematica session *)

inputfile=OpenWrite["SARAH-Intermediate.m"];
WriteString[inputfile,"<<"<>$sarahDir<>"/SARAH.m \n"];
WriteString[inputfile,"Start[\""<>MatchingToModel<>"\"] \n"];

WriteString[inputfile,"MakeSPheno[InputFile->\"SPheno.m.MatchTo"<>ModelName<>"\",ReadLists->"<>ToString[readL]<>"] \n"];
WriteString[inputfile,"Exit \n"];
Close[inputfile];

Switch[$OperatingSystem,
"Unix",
	Run["math < SARAH-Intermediate.m "];,
"MacOSX",
	Run["alias math '/Applications/Mathematica.app/Contents/MacOS/MathKernel' "];
	Run["/Applications/Mathematica.app/Contents/MacOS/MathKernel < SARAH-Intermediate.m"];,
_,
	If[Run["math"]=!=0,
	unknown::system="Not possible to start second Kernel. Please write a mail to florian.staub@cern.ch.";
	Message[unknown::system];
	];
];

Run["rm SARAH-Intermediate.m"];
];

WriteSPhenoFile[readL_]:=Block[{i,sphenofile},

(* write SPheno.m to run high scale model with given boundary conditions and to generate matching routines  *)

MakeSPhenoFortran;
sphenofile=ToFileName[{$sarahDir,"Models","MSSM"},"SPheno.m.MatchTo"<>ModelName];
WriteString[sphenofile,"ModelName = \""<>MatchingToModel<>"To"<>ModelName<>"\"\n"];


WriteString[sphenofile,"SA`AddOneLoopDecay=False;\n"];
WriteString[sphenofile,"SA`Add2LoopCorrections=False;\n"];
WriteString[sphenofile,"SkipFlavorKit=True;\n"];
WriteString[sphenofile,"AddMatchingRoutines=True;\n"];
WriteString[sphenofile,"OnlyLowEnergySPheno=True;\n"];
WriteString[sphenofile,"OutputSeparateSPhenoDir=True;\n"];

WriteString[sphenofile,"MatchingToGaugeES="<>ToString[InputForm[MatchingToGaugeES]]<>";\n"];
WriteString[sphenofile,"HighscaleMatchingConditions = "<>ToString[InputForm[HighscaleMatchingConditions/.subSPhenoForm]]<>";\n"];
WriteString[sphenofile,"ParametrisationExternalStates = "<>ToString[InputForm[ParametrisationExternalStates]]<>";\n"];
WriteString[sphenofile,"IncludeParticlesInThresholds = "<>ToString[InputForm[IncludeParticlesInThresholds]]<>";\n"];
 
WriteString[sphenofile,"MINPAR = {\n"];
For[i=1,i<=Length[InputHighScale],
WriteString[sphenofile,"{"<>ToString[i]<>","<>ToString[InputHighScale[[i]]]<>"}"];
If[i<Length[InputHighScale],WriteString[sphenofile,",\n"];];
i++;];
WriteString[sphenofile,"};\n"];


WriteString[sphenofile,"ParametersToSolveTadpoles="<>ToString[InputForm[ParametersToSolveTadpoleMatchingScale]]<>";\n"];
WriteString[sphenofile,"BoundaryMatchingScale="<>ToString[InputForm[BoundaryMatchingScale]]<>";\n"];
WriteString[sphenofile,"BoundaryLowScaleInput=BoundaryMatchingScale;\n"];

WriteString[sphenofile,"ListDecayParticles={};\n"];
WriteString[sphenofile,"ListDecayParticles3B={};\n"];

WriteString[sphenofile,"ParametersEffModel="<>ToString[InputForm[Sort[Select[parameters,FreeQ[listAllParametersAndVEVs,#[[1]]]==False&],Position[listAllParametersAndVEVs,#1[[1]]][[1,1]]<Position[listAllParametersAndVEVs,#2[[1]]][[1,1]]&]/.subSPhenoForm]]<>";\n"];
WriteString[sphenofile,"RealParametersEffModel="<>ToString[InputForm[Select[listAllParametersAndVEVs,FreeQ[realVar,#]==False&]/.subSPhenoForm]]<>";\n"];

Close[sphenofile];
];



