(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



GenerateSPhenoTreeMasses[Eigenstates_]:=Block[{i,j, currentRegime, readRegime},
(*
Print["----------------------------------------------"];
Print["Writing Routines for Tree Level-Masses"];
Print["----------------------------------------------"];
*)
Print[StyleForm["Write Tree Level-Masses","Section",FontSize->12]];
 
(* $sarahCurrentSPhenoDir=ToFileName[{$sarahCurrentOutputDir,"SPheno"}]; *)
(* CreateDirectory[$sarahCurrentSPhenoDir]; *)
sphenoTree=OpenWrite[ToFileName[$sarahCurrentSPhenoDir,"TreeLevelMasses_"<>ModelName<>".f90"]];

listRGEparameters = listAllParameters;

listBrokenGaugeCouplings=DeleteCases[Transpose[BetaGauge][[1]],strongCoupling];
subStableVEVs=Flatten[{Table[{listBrokenGaugeCouplings[[i]]^x_ listVEVs[[j]]^y_ -> listBrokenGaugeCouplings[[i]]^x listVEVsStable[[j]]^y,a__ listBrokenGaugeCouplings[[i]] listVEVs[[j]]^y_ -> a listBrokenGaugeCouplings[[i]] listVEVsStable[[j]]^y},{i,1,Length[listBrokenGaugeCouplings]},{j,1,Length[listVEVs]}],Table[{listBrokenGaugeCouplings[[i]]^x_ listVEVs[[j]]listVEVs[[k]] -> listBrokenGaugeCouplings[[i]]^x listVEVsStable[[j]]listVEVsStable[[k]],a__ listBrokenGaugeCouplings[[i]] listVEVs[[j]]listVEVs[[k]] -> a listBrokenGaugeCouplings[[i]] listVEVsStable[[j]]listVEVsStable[[k]]},{i,1,Length[listBrokenGaugeCouplings]},{j,1,Length[listVEVs]},{k,1,Length[listVEVs]}]}];

If[IntermediateScale ===True && Head[HeavyFields]=!=List,
WriteCalcTreeMassesDummy;,

InitSPhenoTreeMasses[Eigenstates];

If[IntermediateScale =!=True,
WriteTreeMassesHeader;
];

MassesForEffpot=False;
WriteCalcAllTreeMasses;

WriteRunningFermionMasses;

If[IntermediateScale =!= True,
MassesForEffpot=True;
WriteCalcAllTreeMasses;
MassesForEffpot=False;
];

If[IntermediateScale =!=True,
WriteMassRoutines; 
MassesForEffpot=True;
WriteMassRoutines; 
MassesForEffpot=False;
WriteCalcAllTreeMassesSM;
];

If[IntermediateScale =!= True && Head[RegimeNr]===Integer,
currentRegime = "Regime-"<>ToString[RegimeNr];
For[i=1,i<RegimeNr,
readRegime = "Regime-"<>ToString[i];
AppendSourceCode[ToFileName[StringReplace[$sarahCurrentSPhenoDir,{currentRegime->readRegime,ToString[EigenstateName]->ToString[ListOfRegimeEigenstates[[i]]]}],"TreeMasses_"<>ModelName<>".f90"],sphenoTree];
i++;];
];

GenerateSortGoldstones[Eigenstates];

If[IntermediateScale =!= True,
WriteString[sphenoTree,"\n"];
WriteString[sphenoTree, "End Module TreeLevelMasses_"<>ModelName<>" \n \n"];
];
];

Close[sphenoTree];

];


InitSPhenoTreeMasses[Eigenstates_]:=Block[{i,j,k, type,massMatrixTemp},

Print["  Getting needed Information"]; 

massesTree={};
mixTree={};
mixVB = {};

AllMassesSPheno={};

For[k=1,k<=Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[k]]][MatterSector]]===List,
mixTree=Join[mixTree,DEFINITION[NameOfStates[[k]]][MatterSector]];
massesTree=Join[massesTree,MassMatricesFullND[NameOfStates[[k]]]];
];

If[Head[DEFINITION[NameOfStates[[k]]][GaugeSector]]===List,
mixVB = Join[mixVB,DEFINITION[NameOfStates[[k]]][GaugeSector]];
];
k++;];


parDef=ParticleDefinitions[Eigenstates];
paraDef=ParameterDefinitions;
listNotMixedMasses=ListUnmixed[Eigenstates];

NewMassParameters={};
NewMassParametersSM={};
NewMasses = {};
ExistingParameters = Transpose[parameters][[1]];
ListTree = Table[{},{Length[massesTree]}];
ListMassES={};
ListMixingMat={};

For[i=1,i<=Length[massesTree],
If[Length[mixTree[[i,2,1]]]== 2,
currentName =  mixTree[[i,2,1,1]] /.diracSubBack1[Eigenstates] /.diracSubBack2[Eigenstates];,
currentName = mixTree[[i,2,1]] /.diracSubBack1[Eigenstates] /.diracSubBack2[Eigenstates];
];

If[(IntermediateScale=!=True || FreeQ[HeavyFields,currentName]==False) && getTypeOld[currentName]=!=A,
If[Length[mixTree[[i,2,1]]]== 2,
CurrentMass = ToExpression[SPhenoMass[mixTree[[i,2,1,1]]]];
CurrentMass2 = ToExpression[SPhenoMassSq[mixTree[[i,2,1,1]]]];
CurrentNameSP = {ToExpression[SPhenoForm[mixTree[[i,2,1,2]]]],ToExpression[SPhenoForm[mixTree[[i,2,2,2]]]]};
currentName= mixTree[[i,2,1,1]] /.diracSubBack1[Eigenstates] /.diracSubBack2[Eigenstates];
typeMass=FermionMassNonSymm;
mixParameter1=mixTree[[i,2,1,2]];
mixParameter2=mixTree[[i,2,2,2]];,

CurrentMass=ToExpression[SPhenoMass[mixTree[[i,2,1]]]];
CurrentMass2=ToExpression[SPhenoMassSq[mixTree[[i,2,1]]]];
CurrentNameSP = mixTree[[i,2,2]];
currentName = mixTree[[i,2,1]] /.diracSubBack1[Eigenstates] /.diracSubBack2[Eigenstates];
mixParameter1=mixTree[[i,2,2]];
mixParameter2 = None;
If[getTypeOld[mixTree[[i,1,1]]]===S,
typeMass=ScalarMass;,
typeMass=FermionMassSymm;
];

];

ListTree[[i]]=Join[ListTree[[i]],{ToString[CurrentMass],CurrentNameSP,massesTree[[i]],typeMass}];
pos=Position[parDef,currentName ];
If[pos=!={},
ListMassES=Join[ListMassES,{{currentName ,ToString[CurrentMass],PDG /. Extract[parDef,pos[[1,1]]][[2]]}}];,
ListMassES=Join[ListMassES,{{currentName ,ToString[CurrentMass],PDG}}];
];

pos=Position[paraDef,mixParameter1];
If[pos=!={},
ListMixingMat=Join[ListMixingMat,{{mixParameter1,LesHouches /. Extract[paraDef,pos[[1,1]]][[2]] }}];
];

If[mixParameter2=!=None,
pos=Position[paraDef,mixParameter2];
If[pos=!={},
ListMixingMat=Join[ListMixingMat,{{mixParameter2,LesHouches /. Extract[paraDef,pos[[1,1]]][[2]] }}];
];
];

SPhenoParameters = Join[SPhenoParameters,{{CurrentMass,{generation},{Length[massesTree[[i]]]}},{CurrentMass2,{generation},{Length[massesTree[[i]]]}}}];
parameters = Join[parameters,{{CurrentMass,{generation},{Length[massesTree[[i]]]}},{CurrentMass2,{generation},{Length[massesTree[[i]]]}}}];
If[mixParameter2=!=None,
NewMassParameters = Join[NewMassParameters,{CurrentMass,CurrentMass2,mixParameter1,mixParameter2}];
AllMassesSPheno=Join[AllMassesSPheno,{CurrentMass,CurrentMass2}];
NewMasses = Join[NewMasses,{{CurrentMass,Length[massesTree[[i]]]}}];
If[FreeQ[SMParticles,currentName]==False,
NewMassParametersSM = Join[NewMassParametersSM,{CurrentMass,CurrentMass2,mixParameter1,mixParameter2}];
];,
NewMassParameters = Join[NewMassParameters,{CurrentMass,CurrentMass2,mixParameter1}];
AllMassesSPheno=Join[AllMassesSPheno,{CurrentMass,CurrentMass2}];
If[FreeQ[SMParticles,currentName]==False,
NewMassParametersSM = Join[NewMassParametersSM,{CurrentMass,CurrentMass2,mixParameter1}];
];
NewMasses = Join[NewMasses,{{CurrentMass,Length[massesTree[[i]]]}}];
];
realVar=Join[realVar,{CurrentMass,CurrentMass2}];


invP=TransposeChecked[Select[parameters,(FreeQ[massesTree[[i]],#[[1]]]==False)&]][[1]];
(*
invP={};
For[j=1,j\[LessEqual]Length[parameters],
If[FreeQ[massesTree[[i]],parameters[[j,1]]]\[Equal]False,
invP=Join[invP,{parameters[[j,1]]}];
];
j++;]; *)
ListTree[[i]]=Join[ListTree[[i]],{invP,CurrentMass,CurrentMass2}];
];
i++;];


ListTree = DeleteCases[ListTree,{}];

For[i=1,i<=Length[listNotMixedMasses],
If[listNotMixedMasses[[i,4]]=!=0 && (getType[listNotMixedMasses[[i,1]]]=!=V || SA`NewGaugeSector ==False),
CurrentMass= SPhenoMass[listNotMixedMasses[[i,1]]];
CurrentMass2= SPhenoMassSq[listNotMixedMasses[[i,1]]];

NewMassParameters = Join[NewMassParameters,{CurrentMass,CurrentMass2}];
AllMassesSPheno=Join[AllMassesSPheno,{CurrentMass,CurrentMass2}];
NewMasses = Join[NewMasses,{{CurrentMass,getGenSPheno[listNotMixedMasses[[i,1]]]}}];
realVar = Join[realVar,{CurrentMass,CurrentMass2}];
SPhenoParameters = Join[SPhenoParameters,{{CurrentMass,{generation},{getGenSPheno[listNotMixedMasses[[i,1]]]}},{CurrentMass2,{generation},{getGenSPheno[listNotMixedMasses[[i,1]]]}}}];
parameters = Join[parameters,{{CurrentMass,{generation},{getGenSPheno[listNotMixedMasses[[i,1]]]}},{CurrentMass2,{generation},{getGenSPheno[listNotMixedMasses[[i,1]]]}}}];
];
i++;];

If[Head[Head[DEFINITION[Eigenstates][Phases]]]=!=DEFINITION,
For[i=1,i<=Length[DEFINITION[Eigenstates][Phases]],
NewMassParameters = Join[NewMassParameters,{DEFINITION[Eigenstates][Phases][[i,2]]}];
i++;];
];

mixVB = Select[mixVB,(getType[#[[1,1]],False,ALL]===V)&];

ListTreeVB={};
For[i=1,i<=Length[mixVB],
ListTreeVB = Join[ListTreeVB,{{StringReplace[ToString[Intersection[getBlank/@mixVB[[i,2]]]],{","->"","{"->"","}"->""," "->""}], Transpose[Select[parameters,(FreeQ[MassMatrix[mixVB[[i,2,1]]],#[[1]]]==False)&]][[1]],SPhenoForm[mixVB[[i,3]]],SPhenoForm/@DeleteCases[Intersection[SPhenoMass/@getBlank/@mixVB[[i,2]]],0.],SPhenoForm/@DeleteCases[Intersection[SPhenoMassSq/@getBlank/@mixVB[[i,2]]],0.],AssociatedMixingAngles[mixVB[[i,3]]],MassMatrix[mixVB[[i,2,1]]],mixVB[[i,2]]}}];
NewMassParameters=Join[NewMassParameters,DeleteCases[Flatten[{Intersection[SPhenoMass/@getBlank/@mixVB[[i,2]]],Intersection[SPhenoMassSq/@getBlank/@mixVB[[i,2]]],mixVB[[i,3]],AssociatedMixingAngles[mixVB[[i,3]]]}],0.]];
realVar = Join[realVar,DeleteCases[Flatten[{Intersection[SPhenoMass/@getBlank/@mixVB[[i,2]]],Intersection[SPhenoMassSq/@getBlank/@mixVB[[i,2]]]}],0.]];
AllMassesSPheno=Join[AllMassesSPheno,DeleteCases[Flatten[{Intersection[SPhenoMass/@getBlank/@mixVB[[i,2]]],Intersection[SPhenoMassSq/@getBlank/@mixVB[[i,2]]]}],0.]];

If[FreeQ[subAlways,Last[mixVB[[i]]]],
pos=Position[paraDef,Last[mixVB[[i]]]];
If[pos=!={},
If[(LesHouches /. Extract[paraDef,pos[[1,1]]][[2]])=!=None && (LesHouches /. Extract[paraDef,pos[[1,1]]][[2]])=!=LesHouches,
ListMixingMat=Join[ListMixingMat,{{Last[mixVB[[i]]],LesHouches /. Extract[paraDef,pos[[1,1]]][[2]] }}];
];
];
];

If[Select[mixVB[[i,2]],(FreeQ[SMParticles,(getBlank[#])]==False)&]=!={},
NewMassParametersSM=Join[NewMassParametersSM,DeleteCases[Flatten[{Intersection[SPhenoMass/@getBlank/@mixVB[[i,2]]],Intersection[SPhenoMassSq/@getBlank/@mixVB[[i,2]]],mixVB[[i,3]],AssociatedMixingAngles[mixVB[[i,3]]]}],0.]];
];

For[j=1,j<=Length[mixVB[[i,2]]],
If[FreeQ[parameters,SPhenoMass[getBlank[mixVB[[i,2,j]]]]],
parameters = Join[parameters,{{SPhenoMass[getBlank[mixVB[[i,2,j]]]],{generation},{1}},{SPhenoMassSq[getBlank[mixVB[[i,2,j]]]],{generation},{1}}}];
SPhenoParameters = Join[SPhenoParameters,{{SPhenoMass[getBlank[mixVB[[i,2,j]]]],{generation},{1}},{SPhenoMassSq[getBlank[mixVB[[i,2,j]]]],{generation},{1}}}];
];
j++;];

i++;];


For[i=1,i<=Length[subDependencesSPheno],
If[FreeQ[NewMassParameters,subDependencesSPheno[[i,1]]] && FreeQ[parameters,subDependencesSPheno[[i,1]]]==False,
NewMassParameters = Join[NewMassParameters,{subDependencesSPheno[[i,1]]}];
];
i++;];

NewMassParameters=Intersection[NewMassParameters];
NewMassParametersSM=Intersection[NewMassParametersSM];

ExistingParameters = Complement[ExistingParameters,NewMassParameters];
];



WriteTreeMassesHeader :=Block[{},

Print["  Writing header"];

WriteCopyRight[sphenoTree];

WriteString[sphenoTree, "Module TreeLevelMasses_"<>ModelName<>" \n \n"];
WriteString[sphenoTree, "Use Control \n"];
WriteString[sphenoTree, "Use Mathematics \n"];
WriteString[sphenoTree, "Use MathematicsQP \n"];
WriteString[sphenoTree, "Use Model_Data_"<>ModelName<>" \n"];
WriteString[sphenoTree, "!Use StandardModel \n \n \n"];

WriteString[sphenoTree, "Logical :: SignOfMassChanged =.False.  \n"];
WriteString[sphenoTree, "Logical :: SignOfMuChanged =.False.  \n"];

(* WriteString[sphenoTree, "Real(dp) :: epsM = 1.0E-5_dp  \n"]; *)

WriteString[sphenoTree, "Contains \n \n"];



];

WriteRunningFermionMasses:=Block[{i,pos,fields,names,j},
SA`SMfermionmasses ={};
SA`SMfermionmassesIN ={};
fields={Electron,DownQuark,UpQuark};
names={"Leptons","Down-Quarks","Up-Quarks"};
For[i=1,i<=3,
If[FreeQ[ParticleDefinitions[EWSB],names[[i]]]===False,
SA`SMfermionmasses =Join[SA`SMfermionmasses,{SPhenoMass[fields[[i]]],SPhenoMassSq[fields[[i]]]}];
pos=Position[SPhenoParameters,SPhenoMass[fields[[i]]]][[1,1]];
SPhenoParameters=Join[SPhenoParameters,{SPhenoParameters[[pos]]/.SPhenoMass[fields[[i]]]->ToExpression[ToString[SPhenoMass[fields[[i]]]]<>"IN"]}];
SPhenoParameters=Join[SPhenoParameters,{SPhenoParameters[[pos]]/.SPhenoMass[fields[[i]]]->ToExpression[ToString[SPhenoMassSq[fields[[i]]]]<>"IN"]}];
SA`SMfermionmassesIN =Join[SA`SMfermionmassesIN,{ToExpression[ToString[SPhenoMass[fields[[i]]]]<>"IN"],ToExpression[ToString[SPhenoMassSq[fields[[i]]]]<>"IN"]}];
realVar=Join[realVar,{ToExpression[ToString[SPhenoMass[fields[[i]]]]<>"IN"],ToExpression[ToString[SPhenoMassSq[fields[[i]]]]<>"IN"]}];
];
i++;];


MakeSubroutineTitle["RunningFermionMasses",Join[Join[listVEVs,listAllParameters]],SPhenoForm/@SA`SMfermionmassesIN,{"kont"},sphenoTree];
WriteString[sphenoTree, "Implicit None \n \n"];
WriteString[sphenoTree, "Integer, Intent(inout) :: kont \n"];
MakeVariableList[listAllParameters,",Intent(in)",sphenoTree];
MakeVariableList[listVEVs,",Intent(in)",sphenoTree];
MakeVariableList[SA`SMfermionmassesIN ,",Intent(inout)",sphenoTree];
MakeVariableList[SA`SMfermionmasses ,"",sphenoTree];

For[j=1,j<=3,
If[FreeQ[ParticleDefinitions[EWSB],names[[j]]]===False,
i=Position[ListTree,SPhenoMass[fields[[j]]]][[1,1]];
MakeCall["Calculate"<>ListTree[[i,1]],Flatten[{ListTree[[i,5]],ListTree[[i,2,1]],ListTree[[i,2,2]],ListTree[[i,6]]}],{},{"kont"},sphenoTree]; 
WriteString[sphenoTree,SPhenoForm[ListTree[[i,7]]] <>" = "<>SPhenoForm[ListTree[[i,6]]]  <>"**2 \n"];
WriteString[sphenoTree,ToString[SPhenoMass[fields[[j]]]]<>"IN(1:2) = "<>ToString[SPhenoMass[fields[[j]]]]<>"(1:2) \n"];
WriteString[sphenoTree,ToString[SPhenoMassSq[fields[[j]]]]<>"IN(1:2) = "<>ToString[SPhenoMassSq[fields[[j]]]]<>"(1:2) \n"];
];
j++;];

WriteString[sphenoTree,"End Subroutine RunningFermionMasses \n\n"];
];


WriteCalcAllTreeMasses:=Block[{i2,suffix},

Print["  Writing routine for calculating all masses"];

If[MassesForEffpot===True,
suffix="EffPot";,
suffix="";
];

subCouplingsSPheno={};
For[i2=1,i2<=4,
subCouplingsSPheno=Join[subCouplingsSPheno,(subValue[i2,1] /. subIndFinal[i2,i2])];
i2++;];

If[IntermediateScale === True,
MakeSubroutineTitle["TreeMassesRegime"<>ToString[RegimeNr],Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{"GenerationMixing","kont"},sphenoTree];,
MakeSubroutineTitle["TreeMasses"<>suffix,Join[NewMassParameters,Join[listVEVs,listAllParameters]],{},{"GenerationMixing","kont"},sphenoTree];
];

WriteString[sphenoTree, "Implicit None \n \n"];


MakeVariableList[listAllParameters,",Intent(in)",sphenoTree];
MakeVariableList[NewMassParameters,",Intent(out)",sphenoTree];
MakeVariableList[listVEVs,",Intent(in)",sphenoTree];
If[NewNumericalDependences=!={},
MakeVariableList[Transpose[NewNumericalDependences ][[1]],"",sphenoTree];
];

WriteString[sphenoTree,"Logical, Intent(in) :: GenerationMixing \n"];
WriteString[sphenoTree,"Integer, Intent(inout) :: kont \n"];

WriteString[sphenoTree,"Integer :: i1,i2,i3,i4,j1,j2,j3,kontSave \n"];

nmixF=Select[listNotMixedMasses,getType[#[[1]]]===F&&#[[2]]=!=0&];
For[i=1,i<=Length[nmixF],
WriteString[sphenoTree,"Complex(dp) :: "<>ToString[SPhenoMass[nmixF[[i,1]]]]<>"C \n"];
i++];


WriteString[sphenoTree, "Iname = Iname + 1 \n"];
WriteString[sphenoTree, "NameOfUnit(Iname) = 'TreeMasses" <>Modelname,"'\n \n"];
WriteString[sphenoTree, "kont = 0 \n"];

For[i=1,i<=Length[NewNumericalDependences],
WriteString[sphenoTree, FortranLineBreak[SPhenoForm[NewNumericalDependences[[i,1]]] <> " = " <> SPhenoForm[NewNumericalDependences[[i,2]]],5] <> "\n"];
i++;];

For[i=1,i<=Length[ListTreeVB],
MakeCall["Calculate"<>ListTreeVB[[i,1]]<>suffix,ListTreeVB[[i,2]],{},Flatten[{ListTreeVB[[i,3]],ListTreeVB[[i,4]],ListTreeVB[[i,5]],SPhenoForm/@ListTreeVB[[i,6]],"kont"}],sphenoTree];
i++;];
 
(* Print["Write other Tree-Level Masses"]; *)

Print["  Writing all masses: ",Dynamic[DynamicMassNr],"/",Length[listNotMixedMasses]+Length[ListTree],"(",Dynamic[DynamicMassName],")"];
For[i=1,i<=Length[listNotMixedMasses],
DynamicMassNr=i;
DynamicMassName=listNotMixedMasses[[i,1]];
(* Print["Write Tree-Level Masses for ",listNotMixedMasses[[i,1]] ]; *)
Switch[getType[listNotMixedMasses[[i,1]]],
F,
If[Length[Dimensions[listNotMixedMasses[[i,5]]]]==2,
WriteString[sphenoTree,"! ------------------------------- \n"];
WriteString[sphenoTree,"! Mass of "<>SPhenoForm[listNotMixedMasses[[i,1]]]<>" \n"];
WriteString[sphenoTree,"Do i1=1,"<>ToString[getGenSPheno[listNotMixedMasses[[i,1]]]] <>"\n"];
If[FreeQ[listNotMixedMasses[[i,4]],sum],
WriteString[sphenoTree,SPhenoMass[listNotMixedMasses[[i,1]],i1] <>"= "<>SPhenoForm[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ,SPhenoMass[listNotMixedMasses[[i,1]],i1],sphenoTree];
];
WriteString[sphenoTree,SPhenoMassSq[listNotMixedMasses[[i,1]],i1] <>"= "<>SPhenoMass[listNotMixedMasses[[i,1]],i1] <>"**2 \n"];
WriteString[sphenoTree,"End Do \n \n"];,
If[listNotMixedMasses[[i,4]]=!=0,
WriteString[sphenoTree,"! ------------------------------- \n"];
WriteString[sphenoTree,"! Mass of "<>SPhenoForm[listNotMixedMasses[[i,1]]]<>" \n"];
If[FreeQ[listNotMixedMasses[[i,4]],sum],
WriteString[sphenoTree,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>"C = "<>SPhenoForm[listNotMixedMasses[[i,4]]  /. subCouplingsSPheno]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]]   /. subCouplingsSPheno ,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]],sphenoTree];
];

WriteString[sphenoTree,"If (RotateNegativeFermionMasses) Then \n"];
If[FreeQ[ParticlePhases,listNotMixedMasses[[i,1]]]==False,
pos = Position[ParticlePhases,listNotMixedMasses[[i,1]]][[1,1]];
WriteString[sphenoTree,SPhenoForm[ParticlePhases[[pos,2]]] <> " = Abs("<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"C)/"<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"C\n"];
If[FreeQ[MajoranaPart,listNotMixedMasses[[i,1]]]==False,
WriteString[sphenoTree,SPhenoForm[ParticlePhases[[pos,2]]] <> " = Sqrt("<>SPhenoForm[ParticlePhases[[pos,2]]]<>")\n"];
];
];
WriteString[sphenoTree,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>" = Abs("<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"C) \n"];
WriteString[sphenoTree,ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" = "<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"**2 \n"];
WriteString[sphenoTree,"Else \n"];
If[FreeQ[ParticlePhases,listNotMixedMasses[[i,1]]]==False,
pos = Position[ParticlePhases,listNotMixedMasses[[i,1]]][[1,1]];
WriteString[sphenoTree,SPhenoForm[ParticlePhases[[pos,2]]] <> " = 1._dp\n"];
];
WriteString[sphenoTree,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>" = Real("<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"C,dp) \n"];
WriteString[sphenoTree,ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" = "<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"**2 \n"];
WriteString[sphenoTree,"End if\n"];
WriteString[sphenoTree,"! ------------------------------- \n"];

];
];,
_,
If[getType[listNotMixedMasses[[i,1]]]===S || SA`NewGaugeSector ==False,
If[Length[Dimensions[listNotMixedMasses[[i,5]]]]==2,
WriteString[sphenoTree,"! ------------------------------- \n"];
WriteString[sphenoTree,"! Mass of "<>SPhenoForm[listNotMixedMasses[[i,1]]]<>" \n"];
WriteString[sphenoTree,"Do i1=1,"<>ToString[getGenSPheno[listNotMixedMasses[[i,1]]]] <>"\n"];
If[FreeQ[listNotMixedMasses[[i,4]],sum],
WriteString[sphenoTree,SPhenoMassSq[listNotMixedMasses[[i,1]],i1] <>"= "<>SPhenoForm[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ,SPhenoMassSq[listNotMixedMasses[[i,1]],i1],sphenoTree];
];

WriteString[sphenoTree, "  If ("<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>".ne."<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>") Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in "<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>"' \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "  If ("<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>".Ge.0._dp) Then \n"];
WriteString[sphenoTree,"        "<>SPhenoMass[listNotMixedMasses[[i,1]],i1] <>"= sqrt("<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1] <>") \n"];
WriteString[sphenoTree, "  Else \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from "<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>"' \n"];
WriteString[sphenoTree, "      Write(10,*) 'mass squarred is negative: ',"<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>" \n"];
WriteString[sphenoTree, "    End If \n"];
];
If[MassesForEffpot===False,
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine "<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>"' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) "<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>" \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine "<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>"' \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) "<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1]<>" \n"];
];
If[MassesForEffpot=!=True,
WriteString[sphenoTree,"        "<>SPhenoMass[listNotMixedMasses[[i,1]],i1] <>"= 1._dp \n"];
WriteString[sphenoTree,"        "<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1] <>"= 1._dp \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];
];
WriteString[sphenoTree, " End if \n"];


WriteString[sphenoTree,"End Do \n \n"];,
If[listNotMixedMasses[[i,4]]=!=0,
If[FreeQ[listNotMixedMasses[[i,4]],sum],
WriteString[sphenoTree,FortranLineBreak[ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" = "<>SPhenoForm[listNotMixedMasses[[i,4]] /.subCouplingsSPheno],5]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]] /. subCouplingsSPheno ,ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]],sphenoTree];
]; 

WriteString[sphenoTree, "  If ("<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>".ne."<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>") Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in "<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>"' \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "  If ("<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>".Ge.0._dp) Then \n"];
WriteString[sphenoTree,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>" = sqrt("<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]  <>") \n"];
WriteString[sphenoTree, "  Else \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from "<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>"' \n"];
WriteString[sphenoTree, "      Write(10,*) 'mass squarred is negative: ',"<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" \n"];
WriteString[sphenoTree, "    End If \n"];
];
If[MassesForEffpot===False,
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine "<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>"' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) "<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine "<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>"' \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) "<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" \n"];
];
If[MassesForEffpot=!=True,
WriteString[sphenoTree,"        "<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]] <>"= 1._dp \n"];
WriteString[sphenoTree,"        "<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]] <>"= 1._dp \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];
];
WriteString[sphenoTree, " End if \n\n\n"];
WriteString[sphenoTree,"! ------------------------------- \n"];


];
];
];
];
i++;];

For[i=1,i<=Length[ListTree],
DynamicMassNr=i+Length[listNotMixedMasses];
DynamicMassName=ListTree[[i,1]];

If[FreeQ[GoldstoneGhost,ListMassES[[i,1]]]==False,
WriteString[sphenoTree, "kontSave = kont \n"];
];
Switch[ListTree[[i,4]],
ScalarMass,
MakeCall["Calculate"<>ListTree[[i,1]]<>suffix,Flatten[{ListTree[[i,5]],ListTree[[i,2]],ListTree[[i,6]],ListTree[[i,7]]}],{},{"kont"},sphenoTree];,
FermionMassSymm,MakeCall["Calculate"<>ListTree[[i,1]]<>suffix,Flatten[{ListTree[[i,5]],ListTree[[i,2]],ListTree[[i,6]]}],{},{"kont"},sphenoTree];
WriteString[sphenoTree,SPhenoForm[ListTree[[i,7]]] <>" = "<>SPhenoForm[ListTree[[i,6]]]  <>"**2 \n"];,
FermionMassNonSymm,MakeCall["Calculate"<>ListTree[[i,1]]<>suffix,Flatten[{ListTree[[i,5]],ListTree[[i,2,1]],ListTree[[i,2,2]],ListTree[[i,6]]}],{},{"kont"},sphenoTree]; 
WriteString[sphenoTree,SPhenoForm[ListTree[[i,7]]] <>" = "<>SPhenoForm[ListTree[[i,6]]]  <>"**2 \n"];
];

If[FreeQ[GoldstoneGhost,ListMassES[[i,1]]]==False,
WriteString[sphenoTree, "kont = kontSave \n"];
];
i++;];
DynamicMassName="All Done";

WriteString[sphenoTree, "\n \n "];


If[SPhenoOnlyForHM=!=True,

If[MassesForEffpot=!=True,
If[IntermediateScale === True,
MakeCall["SortGoldstones"<>ToString[RegimeNr],NewMassParameters,{},{"kont"},sphenoTree];,
MakeCall["SortGoldstones",NewMassParameters,{},{"kont"},sphenoTree];
];
];

If[IntermediateScale =!= True,

If[OnlyLowEnergySPheno=!=True,
WriteString[sphenoTree,"If ((HighScaleModel.Eq.\"LOW\").and.(.not.SUSYrunningFromMZ)) Then \n "];
];
WriteString[sphenoTree,"If (SignOfMassChanged) Then  \n"];
WriteString[sphenoTree," If (.Not.IgnoreNegativeMasses) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \" Stopping calculation because of negative mass squared.\" \n"];
WriteString[sphenoTree,"  Call TerminateProgram \n"];
WriteString[sphenoTree," Else \n"];
WriteString[sphenoTree,"  SignOfMassChanged= .False. \n"];
WriteString[sphenoTree,"  kont=0  \n"];
WriteString[sphenoTree," End If \n"];
WriteString[sphenoTree,"End If \n"];
WriteString[sphenoTree,"If (SignOfMuChanged) Then \n"];
WriteString[sphenoTree," If (.Not.IgnoreMuSignFlip) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \" Stopping calculation because of negative mass squared in tadpoles.\" \n"];
WriteString[sphenoTree,"  Call TerminateProgram \n"];
WriteString[sphenoTree," Else \n"];
WriteString[sphenoTree,"  SignOfMuChanged= .False. \n"];
WriteString[sphenoTree,"  kont=0 \n"];
WriteString[sphenoTree," End If \n"];
WriteString[sphenoTree,"End If \n"];
If[OnlyLowEnergySPheno=!=True,
WriteString[sphenoTree,"End if \n "];
];

];


If[MassesForEffpot=!=True,
WriteString[sphenoTree, "\n ! -------------------------------- \n"];
WriteString[sphenoTree, "! Setting Goldstone masses \n"];
WriteString[sphenoTree, "! -------------------------------- \n \n"];

(*
For[i=1,i\[LessEqual]Length[GoldstoneGhost],
If[Head[GoldstoneGhost[[i,2]]]===Symbol,
WriteString[sphenoTree,SPhenoMass[GoldstoneGhost[[i,2]],1]<>"="<>SPhenoMass[GoldstoneGhost[[i,1]],i] <>"*sqrt("<>SPhenoForm[RXi[ToExpression[StringDrop[ToString[GoldstoneGhost[[i,1]]],1]]]]<>")\n" ];
WriteString[sphenoTree,SPhenoMassSq[GoldstoneGhost[[i,2]],1]<>"="<>SPhenoMassSq[GoldstoneGhost[[i,1]],i] <>"*"<>SPhenoForm[RXi[ToExpression[StringDrop[ToString[GoldstoneGhost[[i,1]]],1]]]]<>"\n" ];,
WriteString[sphenoTree,SPhenoMass[GoldstoneGhost[[i,2,0]],GoldstoneGhost[[i,2,1,1]]]<>"="<>SPhenoMass[GoldstoneGhost[[i,1]],i] <>"*sqrt("<>SPhenoForm[RXi[ToExpression[StringDrop[ToString[GoldstoneGhost[[i,1]]],1]]]]<>")\n" ];
WriteString[sphenoTree,SPhenoMassSq[GoldstoneGhost[[i,2,0]],GoldstoneGhost[[i,2,1,1]]]<>"="<>SPhenoMassSq[GoldstoneGhost[[i,1]],i] <>"*"<>SPhenoForm[RXi[ToExpression[StringDrop[ToString[GoldstoneGhost[[i,1]]],1]]]]<>"\n" ];
];
i++;];
*)
];
];
If[MassesForEffpot=!=True,
WriteSetDependentParameters[sphenoTree];
];

WriteString[sphenoTree, "Iname = Iname - 1 \n \n"];
If[IntermediateScale === True,

WriteString[sphenoTree, "Contains \n \n"];
WriteMassRoutines; 
WriteString[sphenoTree, "End Subroutine  TreeMassesRegime"<>ToString[RegimeNr]<>" \n \n \n"];,
WriteString[sphenoTree, "End Subroutine  TreeMasses"<>suffix<>" \n \n \n"];
];


];



WriteCalcAllTreeMassesDummy:=Block[{i2},

Print["  Writing routine for calculating SM masses"];


MakeSubroutineTitle["TreeMassesRegime"<>ToString[RegimeNr],{},{},{"GenerationMixing","kont"},sphenoTree];

WriteString[sphenoTree, "Implicit None \n \n"];
WriteString[sphenoTree, "! Nothing to do\n \n"];

WriteString[sphenoTree, "End Subroutine  TreeMassesRegime"<>ToString[RegimeNr]<>" \n \n \n"];

];

WriteMassRoutines :=Block[{suffix},
For[i=1,i<=Length[ListTree],
(* Print["Writing Subroutine for Calculating ",ListTree[[i,1]]]; *)
Switch[ListTree[[i,4]],
ScalarMass,
If[MassesForEffpot===True && getGenSPhenoStart[ListMassES[[i,1]]]>1,
WriteTreeMassFunctionScalarGoldstone[ListTree[[i,1]],ListMassES[[i,1]], SPhenoForm[ListTree[[i,2]]], ListTree[[i,3]],ListTree[[i,5]]];,
WriteTreeMassFunctionScalar[ListTree[[i,1]],ListMassES[[i,1]], SPhenoForm[ListTree[[i,2]]], ListTree[[i,3]],ListTree[[i,5]]];
];,
FermionMassSymm,WriteTreeMassFunctionFermionSymm[ListTree[[i,1]],ListMassES[[i,1]], SPhenoForm[ListTree[[i,2]]], ListTree[[i,3]],ListTree[[i,5]]];,
FermionMassNonSymm,WriteTreeMassFunctionFermionNonSymm[ListTree[[i,1]],ListMassES[[i,1]], SPhenoForm[ListTree[[i,2,1]]],SPhenoForm[ListTree[[i,2,2]]], ListTree[[i,3]],ListTree[[i,5]]];
];
i++;];

For[i=1,i<=Length[ListTreeVB],
(* Print["Writing Subroutine for Calculating ",ListTreeVB[[i,4]]]; *)
WriteTreeMassFunctionVector[ListTreeVB[[i,1]],ListTreeVB[[i,3]], ListTreeVB[[i,4]], ListTreeVB[[i,6]],ListTreeVB[[i,7]],ListTreeVB[[i,2]],ListTreeVB[[i,8]]];
i++;];

];


WriteTreeMassFunctionScalar[Name_,particle_,MixingName_,MatrixFunction_,Parameters_]:=Block[{i2,i3,pos,suffix,subVEVfixed},
If[MassesForEffpot===True,
suffix="EffPot";
subVEVfixed=subStableVEVs;,
suffix="";
subVEVfixed={};
];
MakeSubroutineTitle["Calculate"<>Name<>suffix,Parameters,{},{MixingName,Name,Name<>"2","kont"},sphenoTree];

MakeVariableList[Parameters,", Intent(in)",sphenoTree];
WriteString[sphenoTree, "Integer, Intent(inout) :: kont \n"];
WriteString[sphenoTree, "Integer :: i1,i2,i3,i4, ierr \n"];
WriteString[sphenoTree,"Integer :: j1,j2,j3,j4, pos \n"];

dimMatrix = ToString[Dimensions[MatrixFunction][[1]]];
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> Name <>"("<>dimMatrix <>"), " ];
WriteString[sphenoTree,  Name <>"2("<>dimMatrix <>") \n" ];

If[FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "Complex(dp), Intent(out) :: "<> MixingName<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Complex(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>")  \n\n"];,
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> MixingName<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Real(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>")  \n\n"];
];

If[MassesForEffpot===True,
WriteString[sphenoTree, "Real(dp) :: "<> Name <>"2temp("<>dimMatrix <>"), Q2 \n" ];
If[FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName<>"temp("<>dimMatrix <>","<>dimMatrix <>"), "<> MixingName<>"temp2("<>dimMatrix <>","<>dimMatrix <>") \n \n"];,
WriteString[sphenoTree, "Real(dp) :: "<> MixingName<>"temp("<>dimMatrix <>","<>dimMatrix <>"),"<> MixingName<>"temp2("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
];
];

WriteString[sphenoTree, "Real(dp) ::  test(2) \n\n"];

If[FreeQ[ConditionForMassOrdering,particle]==False,
WriteString[sphenoTree, "Real(dp) :: "<> Name <>"2temp("<>dimMatrix <>") \n" ];
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName<>"temp("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
];


WriteString[sphenoTree, "Iname = Iname + 1 \n"];
WriteString[sphenoTree, "NameOfUnit(Iname) = '"<>"Calculate"<> Name<>"'\n \n"];

For[i2=1,i2<=ToExpression[dimMatrix],
For[i3=i2,i3<=ToExpression[dimMatrix],
MakeSPhenoCoupling[MatrixFunction[[i2,i3]] /. subVEVfixed,"mat("<>ToString[i2]<>","<>ToString[i3]<>")",sphenoTree];
i3++;];
i2++;];

WriteString[sphenoTree, "\n \n "];

WriteString[sphenoTree,"Do i1=2,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "  Do i2 = 1, i1-1 \n"];
(* If[FreeQ[realVar,ToExpression[MixingName]], *)
If[conj[particle]=!=particle && FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "  mat(i1,i2) = Conjg(mat(i2,i1)) \n"];,
WriteString[sphenoTree, "  mat(i1,i2) = mat(i2,i1) \n"];
];
WriteString[sphenoTree, "  End do \n"];
WriteString[sphenoTree, "End do \n"]; 

WriteString[sphenoTree, "\n \n"];

If[FreeQ[QuadruplePrecision,particle],stringQP="";,stringQP="QP";];

 WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(mat,"<> Name <>"2,"<>  MixingName <>",ierr,test) \n \n \n"]; 

If[MassesForEffpot===True &&  FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree,"! Fix order\n"];
WriteString[sphenoTree,"  "<>MixingName<>"temp2="<>MixingName<>"\n"];
WriteString[sphenoTree,"Do i1=1,"<>dimMatrix<>"\n"];
WriteString[sphenoTree,"  pos=Maxloc(Abs("<>MixingName<>"temp2(i1,:)),1)\n"];
WriteString[sphenoTree,"  "<>MixingName<>"temp(pos,:)="<>MixingName<>"(i1,:)\n"];
WriteString[sphenoTree,"  "<>Name<>"2temp(pos)="<>Name<>"2(i1)\n"];
WriteString[sphenoTree,"  "<>MixingName<>"temp2(:,pos)=0._dp\n"];
WriteString[sphenoTree,"End do\n"];
WriteString[sphenoTree,"  "<>Name<>"2 = "<>Name<>"2temp\n"];
WriteString[sphenoTree,"  "<>MixingName<>" = "<>MixingName<>"temp\n"];
];

If[MassesForEffpot===True,
WriteString[sphenoTree,"! Fix phases\n"];
WriteString[sphenoTree,"Do i1=1,"<>dimMatrix<>"\n"];
WriteString[sphenoTree,"  pos=Maxloc(Abs("<>MixingName<>"(i1,:)),1)\n"];
WriteString[sphenoTree,"  If (Real("<>MixingName<>"(i1,pos),dp).lt.0._dp) Then\n"];
WriteString[sphenoTree,"    "<>MixingName<>"(i1,:)=-"<>MixingName<>"(i1,:)\n"];
WriteString[sphenoTree,"  End if\n"];
WriteString[sphenoTree,"End do\n"];
];

WriteString[sphenoTree,"If ((ierr.Eq.-8).Or.(ierr.Eq.-9)) Then \n"];
WriteString[sphenoTree,"  Write(ErrCan,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"  If (ErrorLevel.Eq.2) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"    Call TerminateProgram \n"];
WriteString[sphenoTree,"  End If \n"];
WriteString[sphenoTree, "  ierr = 0 \n"];
WriteString[sphenoTree, "End If \n \n"];

WriteString[sphenoTree, "If ((ierr.Ne.0.).And.(ErrorLevel.Ge.-1)) Then \n"];
WriteString[sphenoTree, "  Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "  Write(10,*) 'Diagonalization failed, ierr : ',ierr \n"];
WriteString[sphenoTree, "  kont = ierr \n"];
WriteString[sphenoTree, "  Iname = Iname - 1 \n"];
WriteString[sphenoTree, "  Return \n"];
WriteString[sphenoTree, "End If \n\n\n"];

If[FreeQ[ConditionForMassOrdering,particle]==False,
pos =Position[ConditionForMassOrdering,particle][[1,1]];
WriteString[sphenoTree,ConditionForMassOrdering[[pos,2]]];
];
WriteString[sphenoTree, "Do i1=1,"<>dimMatrix<> "\n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  If (Abs("<>Name<>"2(i1)).Le.MaxMassNumericalZero) "<>Name<>"2(i1) = 1.E-10_dp \n"]; 
];
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).ne."<>Name<>"2(i1)) Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).Ge.0._dp) Then \n"];
WriteString[sphenoTree, "  "<>Name <>"(i1)=Sqrt("<>Name <> "2(i1) ) \n"];
WriteString[sphenoTree, "  Else \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(10,*) 'a mass squarred is negative: ',i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree, "    End If \n"];
];
WriteString[sphenoTree, "  "<>Name <>"(i1) = 1._dp \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) i1,"<>Name<>"2(i1) \n"];
];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  "<>Name<>"2(i1) = 1._dp \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];
];
WriteString[sphenoTree, "! kont = -104 \n"];
WriteString[sphenoTree, " End if \n"];
WriteString[sphenoTree, "End Do \n"];


WriteString[sphenoTree, "Iname = Iname - 1 \n \n"];
WriteString[sphenoTree, "End Subroutine " <> "Calculate"<>Name <>suffix <>" \n\n"];


];


WriteTreeMassFunctionScalarGoldstone[Name_,particle_,MixingName_,MatrixFunction_,Parameters_]:=Block[{i2,i3,pos,suffix,subVEVfixed},
If[MassesForEffpot===True,
suffix="EffPot";
subVEVfixed=subStableVEVs;
subVEVfixedAll = Table[listVEVs[[i]]->ToExpression[ToString[listVEVs[[i]]]<>"Fix"],{i,1,Length[listVEVs]}],
suffix="";
subVEVfixed={};
];
MakeSubroutineTitle["Calculate"<>Name<>suffix,Parameters,{},{MixingName,Name,Name<>"2","kont"},sphenoTree];

MakeVariableList[Parameters,", Intent(in)",sphenoTree];
WriteString[sphenoTree, "Integer, Intent(inout) :: kont \n"];
WriteString[sphenoTree, "Integer :: i1,i2,i3,i4, ierr, pos \n"];
WriteString[sphenoTree,"Integer :: j1,j2,j3,j4 \n"];

dimMatrix = ToString[Dimensions[MatrixFunction][[1]]];
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> Name <>"("<>dimMatrix <>"), " ];
WriteString[sphenoTree,  Name <>"2("<>dimMatrix <>") \n" ];

If[FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "Complex(dp), Intent(out) :: "<> MixingName<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName<>"FIX("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Complex(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>")  \n\n"];,
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> MixingName<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Real(dp) :: "<> MixingName<>"FIX("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Real(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>")  \n\n"];
];

WriteString[sphenoTree, "Real(dp) ::  test(2), Q2 \n\n"];

If[FreeQ[ConditionForMassOrdering,particle]==False,
WriteString[sphenoTree, "Real(dp) :: "<> Name <>"2temp("<>dimMatrix <>") \n" ];
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName<>"temp("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
];


WriteString[sphenoTree, "Iname = Iname + 1 \n"];
WriteString[sphenoTree, "NameOfUnit(Iname) = '"<>"Calculate"<> Name<>"'\n \n"];

(*
WriteString[sphenoTree, "! Get rotation matrix at the minimum \n"];
For[i2=1,i2\[LessEqual]ToExpression[dimMatrix],
For[i3=i2,i3\[LessEqual]ToExpression[dimMatrix],
MakeSPhenoCoupling[MatrixFunction[[i2,i3]] /. subVEVfixedAll /. RXi[a__]\[Rule]0,"mat("<>ToString[i2]<>","<>ToString[i3]<>")",sphenoTree];
i3++;];
i2++;];

WriteString[sphenoTree, "\n \n "];

WriteString[sphenoTree,"Do i1=2,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "  Do i2 = 1, i1-1 \n"];
If[FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "  mat(i1,i2) = Conjg(mat(i2,i1)) \n"];,
WriteString[sphenoTree, "  mat(i1,i2) = mat(i2,i1) \n"];
];
WriteString[sphenoTree, "  End do \n"];
WriteString[sphenoTree, "End do \n"]; 

WriteString[sphenoTree, "\n \n"];

If[FreeQ[QuadruplePrecision,particle],stringQP="";,stringQP="QP";];

 WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(mat,"<> Name <>"2,"<>  MixingName <>"FIX,ierr,test) \n \n \n"]; 


WriteString[sphenoTree, "! Get rotation mass matrix away from the minimum \n"];
*)

For[i2=1,i2<=ToExpression[dimMatrix],
For[i3=i2,i3<=ToExpression[dimMatrix],
MakeSPhenoCoupling[MatrixFunction[[i2,i3]] /. subVEVfixed /. RXi[a__]->0,"mat("<>ToString[i2]<>","<>ToString[i3]<>")",sphenoTree];
i3++;];
i2++;];


WriteString[sphenoTree, "\n \n "];

WriteString[sphenoTree,"Do i1=2,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "  Do i2 = 1, i1-1 \n"];
(* If[FreeQ[realVar,ToExpression[MixingName]],*)
If[conj[particle]=!=particle && FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "  mat(i1,i2) = Conjg(mat(i2,i1)) \n"];,
WriteString[sphenoTree, "  mat(i1,i2) = mat(i2,i1) \n"];
];
WriteString[sphenoTree, "  End do \n"];
WriteString[sphenoTree, "End do \n"]; 

WriteString[sphenoTree, "\n \n"];

(*
WriteString[sphenoTree, "mat = MatMul(MatMul("<>  MixingName <>"FIX, mat), Transpose("<>  MixingName <>"FIX)) \n"];
*)
(*
WriteString[sphenoTree, "! Put mixing with Goldstones to zero\n"];
For[i2=1,i2\[LessEqual]getGenSPhenoStart[particle]-1,
For[i3=i2+1,i3\[LessEqual]ToExpression[dimMatrix],
WriteString[sphenoTree,"mat("<>ToString[i2]<>","<>ToString[i3]<>") = 0._dp \n"];
WriteString[sphenoTree,"mat("<>ToString[i3]<>","<>ToString[i2]<>") = 0._dp \n"];
i3++;];
i2++;];
*)

 WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(mat,"<> Name <>"2,"<>  MixingName <>",ierr,test) \n \n \n"];

(* WriteString[sphenoTree,MixingName <>"= MatMul("<>MixingName<>","<>MixingName<>"Fix) \n"]; *)
If[MassesForEffpot===True,
WriteString[sphenoTree,"! Fix phases\n"];
WriteString[sphenoTree,"Do i1=1,"<>dimMatrix<>"\n"];
WriteString[sphenoTree,"  pos=Maxloc(Abs("<>MixingName<>"(i1,:)),1)\n"];
WriteString[sphenoTree,"  If (Real("<>MixingName<>"(i1,pos),dp).lt.0._dp) Then\n"];
WriteString[sphenoTree,"    "<>MixingName<>"(i1,:)=-"<>MixingName<>"(i1,:)\n"];
WriteString[sphenoTree,"  End if\n"];
WriteString[sphenoTree,"End do\n"];
];

(*
For[i2=1,i2\[LessEqual]getGenSPhenoStart[particle]-1,
WriteString[sphenoTree, Name <>"2("<>ToString[i2]<>") = 0._dp \n"];
i2++;];
*)

WriteString[sphenoTree,"If ((ierr.Eq.-8).Or.(ierr.Eq.-9)) Then \n"];
WriteString[sphenoTree,"  Write(ErrCan,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"  If (ErrorLevel.Eq.2) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"    Call TerminateProgram \n"];
WriteString[sphenoTree,"  End If \n"];
WriteString[sphenoTree, "  ierr = 0 \n"];
WriteString[sphenoTree, "End If \n \n"];

WriteString[sphenoTree, "If ((ierr.Ne.0.).And.(ErrorLevel.Ge.-1)) Then \n"];
WriteString[sphenoTree, "  Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "  Write(10,*) 'Diagonalization failed, ierr : ',ierr \n"];
WriteString[sphenoTree, "  kont = ierr \n"];
WriteString[sphenoTree, "  Iname = Iname - 1 \n"];
WriteString[sphenoTree, "  Return \n"];
WriteString[sphenoTree, "End If \n\n\n"];

(*
If[FreeQ[ConditionForMassOrdering,particle]\[Equal]False,pos =Position[ConditionForMassOrdering,particle][[1,1]];WriteString[sphenoTree,ConditionForMassOrdering[[pos,2]]];];
*)


WriteString[sphenoTree, "Do i1=1,"<>dimMatrix<> "\n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  If (Abs("<>Name<>"2(i1)).Le.MaxMassNumericalZero) "<>Name<>"2(i1) = 1.E-10_dp \n"]; 
];
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).ne."<>Name<>"2(i1)) Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).Ge.0._dp) Then \n"];
WriteString[sphenoTree, "  "<>Name <>"(i1)=Sqrt("<>Name <> "2(i1) ) \n"];
WriteString[sphenoTree, "  Else \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(10,*) 'a mass squarred is negative: ',i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree, "    End If \n"];
];
WriteString[sphenoTree, "  "<>Name <>"(i1) = 1._dp \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) i1,"<>Name<>"2(i1) \n"];
];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  "<>Name<>"2(i1) = 1._dp \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];
];
WriteString[sphenoTree, "! kont = -104 \n"];
WriteString[sphenoTree, " End if \n"];
WriteString[sphenoTree, "End Do \n"];


WriteString[sphenoTree, "Iname = Iname - 1 \n \n"];
WriteString[sphenoTree, "End Subroutine " <> "Calculate"<>Name <>suffix <>" \n\n"];


];


WriteTreeMassFunctionFermionSymm[Name_,particle_,MixingName_,MatrixFunction_,Parameters_]:=Block[{i2,i3,suffix,subVEVfixed},

If[MassesForEffpot===True,
suffix="EffPot";
subVEVfixed=subStableVEVs;,
suffix="";
subVEVfixed={};
];

MakeSubroutineTitle["Calculate"<>Name<>suffix ,Parameters,{},{MixingName,Name,"kont"},sphenoTree];

MakeVariableList[Parameters," ,Intent(in)",sphenoTree];

WriteString[sphenoTree, "Integer, Intent(inout) :: kont \n"];
WriteString[sphenoTree, "Integer :: i1,i2,i3,i4, ierr, pos \n"];
WriteString[sphenoTree,"Integer :: j1,j2,j3,j4 \n"];
WriteString[sphenoTree,"Logical :: SecondDiagonalisationNeeded \n"];

dimMatrix = ToString[Dimensions[MatrixFunction][[1]]];
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> Name <>"("<>dimMatrix <>") \n" ];
WriteString[sphenoTree, "Complex(dp), Intent(out) :: " MixingName<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n" ];
WriteString[sphenoTree, "Complex(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>"), mat2"<>"("<>dimMatrix<>","<>dimMatrix<>"), phaseM, E"<>dimMatrix<>"("<>dimMatrix<>") \n\n"];
WriteString[sphenoTree, "Real(dp) :: "<>MixingName<>"a("<>dimMatrix<>","<>dimMatrix<>"), test(2), eig("<>dimMatrix<>") \n\n"];

If[FreeQ[ConditionForMassOrdering,particle]==False,
WriteString[sphenoTree, "Real(dp) :: "<> Name <>"temp("<>dimMatrix <>") \n" ];
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName<>"temp("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
];



WriteString[sphenoTree, "Iname = Iname + 1 \n"];
WriteString[sphenoTree, "NameOfUnit(Iname) = '"<>"Calculate"<> Name<>"'\n \n"];


For[i2=1,i2<=ToExpression[dimMatrix],
For[i3=i2,i3<=ToExpression[dimMatrix],
MakeSPhenoCoupling[MatrixFunction[[i2,i3]]/.subVEVfixed,"mat("<>ToString[i2]<>","<>ToString[i3]<>")",sphenoTree];
i3++;];
i2++;];

WriteString[sphenoTree, "\n \n "];

WriteString[sphenoTree,"Do i1=2,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "  Do i2 = 1, i1-1 \n"];
WriteString[sphenoTree, "  mat(i1,i2) = mat(i2,i1) \n"];
WriteString[sphenoTree, "  End do \n"];
WriteString[sphenoTree, "End do \n"]; 


WriteString[sphenoTree, "\n \n"];

If[FreeQ[QuadruplePrecision,particle],stringQP="";,stringQP="QP";];

WriteString[sphenoTree, "If (Maxval(Abs(Aimag(mat))).Eq.0._dp) Then \n"];
WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(Real(mat,dp),Eig,"<>  MixingName <>"a,ierr,test) \n \n "];

WriteString[sphenoTree, "  Do i1=1,"<>dimMatrix <>"\n"];
(* WriteString[sphenoTree, "   If (Eig(i1).Lt.0._dp) Then \n"]; *)
WriteString[sphenoTree, "   If ((Eig(i1).Lt.0._dp).or.(Abs(eig(i1)).lt.1E-15)) Then \n"];
WriteString[sphenoTree, "    "<>Name<>"(i1) = - Eig(i1) \n"];
WriteString[sphenoTree, "    "<>MixingName<>"(i1,:) = (0._dp,1._dp)*" <>MixingName <>"a(i1,:) \n"];
WriteString[sphenoTree, "   Else \n"];
WriteString[sphenoTree, "    "<>Name<>"(i1) = Eig(i1) \n"];
WriteString[sphenoTree, "    "<>MixingName<>"(i1,:) = "<>MixingName<>"a(i1,:)\n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "   End Do \n \n"];

If[MassesForEffpot===True,
WriteString[sphenoTree, "  Do i1=1,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "   pos=Maxloc(Abs("<>MixingName<>"(i1,:)),1) \n"];
WriteString[sphenoTree, "   If (Abs(Real("<>MixingName<>"(i1,pos),dp)).gt.Abs(Aimag("<>MixingName<>"(i1,pos)))) Then \n"];
WriteString[sphenoTree, "      If (Real("<>MixingName<>"(i1,pos),dp).lt.0._dp) Then \n"];
WriteString[sphenoTree, "        "<>MixingName<>"(i1,:)=-"<>MixingName<>"(i1,:) \n"];
WriteString[sphenoTree, "       End If \n"];
WriteString[sphenoTree, "    Else \n"];
WriteString[sphenoTree, "      If (Aimag("<>MixingName<>"(i1,pos)).lt.0._dp) Then \n"];
WriteString[sphenoTree, "        "<>MixingName<>"(i1,:)=-"<>MixingName<>"(i1,:) \n"];
WriteString[sphenoTree, "      End If \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, " End Do \n \n"];
];

WriteString[sphenoTree, "Do i1=1,"<>ToString[ToExpression[dimMatrix]-1]<>"\n"];
WriteString[sphenoTree, "  Do i2=i1+1,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "    If ("<>Name<>"(i1).Gt."<>Name<>"(i2)) Then \n"];
WriteString[sphenoTree, "      Eig(1) = "<>Name<>"(i1) \n"];
WriteString[sphenoTree, "      "<>Name<>"(i1) = "<>Name <>"(i2) \n"];
WriteString[sphenoTree, "      "<>Name<>"(i2) =  Eig(1) \n"];
WriteString[sphenoTree, "      E"<>dimMatrix<>" = " <>MixingName<>"(i1,:) \n"];
WriteString[sphenoTree, "      "<>MixingName<>"(i1,:) = "<>MixingName<>"(i2,:) \n"];
WriteString[sphenoTree, "      "<>MixingName<>"(i2,:) = E"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "   End Do \n"];
WriteString[sphenoTree, "End Do \n \n"];

WriteString[sphenoTree, "Else \n \n"];

WriteString[sphenoTree, "mat2 = Matmul( Transpose(Conjg( mat) ), mat ) \n"];
WriteString[sphenoTree, "Call Eigensystem"<>stringQP<>"(mat2, Eig, "<>MixingName<>", ierr, test) \n"];
WriteString[sphenoTree, "mat2 = Matmul( Conjg("<>MixingName<>"), Matmul( mat, Transpose( Conjg("<>MixingName<>")))) \n"];

WriteString[sphenoTree, "! Special efforts are needed for matrices like the Higgsinos one \n"];
WriteString[sphenoTree, "SecondDiagonalisationNeeded = .False. \n"];
WriteString[sphenoTree, "Do i1=1,"<>dimMatrix<>"-1\n"];
WriteString[sphenoTree, "If (MaxVal(Abs(mat2(i1,(i1+1):"<>dimMatrix<>"))).gt.Abs(mat2(i1,i1))) SecondDiagonalisationNeeded = .True. \n\n"];
WriteString[sphenoTree, "  If (Eig(i1).ne.Eig(i1)) Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "  If ((Abs(Eig(i1)).Le.MaxMassNumericalZero).and.(Eig(i1).lt.0._dp)) Eig(i1) = Abs(Eig(i1))+1.E-10_dp \n"]; 
WriteString[sphenoTree, "  If (Eig(i1).Le.0._dp) Then \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(10,*) 'a mass squarred is negative: ',i1,Eig(i1) \n"];
WriteString[sphenoTree, "      Write(*,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(*,*) 'a mass squarred is negative: ',i1,Eig(i1) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) i1,Eig(i1) \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) i1,Eig(i1) \n"];
];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  Eig(i1) = 1._dp \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];
];
WriteString[sphenoTree, "! kont = -104 \n"];
WriteString[sphenoTree, " End if \n"];
WriteString[sphenoTree, "End do \n"];

WriteString[sphenoTree, "If (SecondDiagonalisationNeeded) Then \n"];
WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(Real(mat2,dp),Eig,"<>  MixingName <>"a,ierr,test) \n \n "];
WriteString[sphenoTree, "    "<>MixingName<>" = MatMul("<>MixingName<>","<>MixingName<>"a)\n"];

WriteString[sphenoTree, "  Do i1=1,"<>dimMatrix <>"\n"];
(* WriteString[sphenoTree, "   If (Eig(i1).Lt.0._dp) Then \n"]; *)
WriteString[sphenoTree, "   If ((Eig(i1).Lt.0._dp).or.(Abs(eig(i1)).lt.1E-15)) Then \n"];
WriteString[sphenoTree, "    "<>Name<>"(i1) = - Eig(i1) \n"];
WriteString[sphenoTree, "    "<>MixingName<>"(i1,:) = (0._dp,1._dp)*" <>MixingName <>"a(i1,:) \n"];
WriteString[sphenoTree, "   Else \n"];
WriteString[sphenoTree, "    "<>Name<>"(i1) = Eig(i1) \n"];
WriteString[sphenoTree, "    "<>MixingName<>"(i1,:) = "<>MixingName<>"a(i1,:)\n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "   End Do \n \n"];

WriteString[sphenoTree, "Else \n"];


WriteString[sphenoTree, "Do i1=1,"<>dimMatrix<>"\n"];
WriteString[sphenoTree, "  If (Eig(i1).ne.Eig(i1)) Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "If (Abs(mat2(i1,i1)).gt.0._dp) Then \n"];
WriteString[sphenoTree, "  phaseM = Sqrt( mat2(i1,i1) / Abs(mat2(i1,i1))) \n"];
WriteString[sphenoTree, "  "<>MixingName<>"(i1,:)= phaseM * "<>MixingName<>"(i1,:) \n"];
WriteString[sphenoTree, "End if \n"];
WriteString[sphenoTree, "  If ((Abs(Eig(i1)).Le.MaxMassNumericalZero).and.(Eig(i1).lt.0._dp)) Eig(i1) = Abs(Eig(i1))+1.E-10_dp \n"]; 
WriteString[sphenoTree, "  If (Eig(i1).Le.0._dp) Then \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(10,*) 'a mass squarred is negative: ',i1,Eig(i1) \n"];
WriteString[sphenoTree, "      Write(*,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(*,*) 'a mass squarred is negative: ',i1,Eig(i1) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) i1,Eig(i1) \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) i1,Eig(i1) \n"];
];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  Eig(i1) = 1._dp \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];
];
WriteString[sphenoTree, "! kont = -104 \n"];
WriteString[sphenoTree, " End if \n"];

WriteString[sphenoTree, "End Do \n"];
WriteString[sphenoTree, Name <> " = Sqrt( Eig ) \n \n"];
WriteString[sphenoTree, "End if ! Second diagonalisation \n"];
WriteString[sphenoTree, "End If \n \n"]; 


WriteString[sphenoTree,"If ((ierr.Eq.-8).Or.(ierr.Eq.-9)) Then \n"];
WriteString[sphenoTree,"  Write(ErrCan,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"  If (ErrorLevel.Eq.2) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"    Call TerminateProgram \n"];
WriteString[sphenoTree,"  End If \n"];
WriteString[sphenoTree, "  ierr = 0 \n"];
WriteString[sphenoTree, "End If \n \n"];

WriteString[sphenoTree, "If (ierr.Ne.0.) Then \n"];
WriteString[sphenoTree, "  Write(ErrCan,*) 'Warning from Subroutine Calculate"<>Name<>", ierr =',ierr \n"];
WriteString[sphenoTree, "  kont = ierr \n"];
WriteString[sphenoTree, "  Iname = Iname - 1 \n"];
WriteString[sphenoTree, "  Return \n"];
WriteString[sphenoTree, "End If \n\n\n"];

If[FreeQ[ConditionForMassOrdering,particle]==False,
pos =Position[ConditionForMassOrdering,particle][[1,1]];
WriteString[sphenoTree,ConditionForMassOrdering[[pos,2]]];
];


WriteString[sphenoTree, "Iname = Iname - 1 \n \n"];
WriteString[sphenoTree, "End Subroutine " <> "Calculate"<>Name <>suffix <> " \n\n"];


];


WriteTreeMassFunctionFermionNonSymm[Name_,particle_,MixingName1_,MixingName2_,MatrixFunction_,Parameters_]:=Block[{i2,i3,suffix,subVEVfixed},

If[MassesForEffpot===True,
suffix="EffPot";
subVEVfixed=subStableVEVs;,
suffix="";
subVEVfixed={};
];

MakeSubroutineTitle["Calculate"<>Name<>suffix ,Parameters,{},{MixingName1,MixingName2,Name,"kont"},sphenoTree];


MakeVariableList[Parameters,",Intent(in)",sphenoTree];

WriteString[sphenoTree, "Integer, Intent(inout) :: kont \n"];
WriteString[sphenoTree, "Integer :: i1,i2,i3,i4, ierr \n"];
WriteString[sphenoTree,"Integer :: j1,j2,j3,j4 \n"];

dimMatrix = ToString[Dimensions[MatrixFunction][[1]]];
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> Name <>"("<>dimMatrix <>") \n " ];
WriteString[sphenoTree,  "Complex(dp), Intent(out) :: "<>MixingName1<>"("<>dimMatrix <>","<>dimMatrix <>"), "<>MixingName2<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n " ];

If[FreeQ[ConditionForMassOrdering,particle]==False,
WriteString[sphenoTree, "Real(dp) :: "<> Name <>"temp("<>dimMatrix <>") \n" ];
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName1<>"temp("<>dimMatrix <>","<>dimMatrix <>") \n "];
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName2<>"temp("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
];


WriteString[sphenoTree, "Complex(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>")=0._dp, mat2"<>"("<>dimMatrix<>","<>dimMatrix<>")=0._dp, phaseM \n\n"];
WriteString[sphenoTree,  "Complex(dp) :: "<>MixingName1<>"2("<>dimMatrix <>","<>dimMatrix <>"), "<>MixingName2<>"2("<>dimMatrix <>","<>dimMatrix <>") \n \n " ];
WriteString[sphenoTree,  "Real(dp) :: "<>MixingName1<>"1("<>dimMatrix <>","<>dimMatrix <>"), "<>MixingName2<>"1("<>dimMatrix <>","<>dimMatrix <>"), test(2), " <> Name <>"2("<>dimMatrix <>") \n \n " ];



WriteString[sphenoTree, "Iname = Iname + 1 \n"];
WriteString[sphenoTree, "NameOfUnit(Iname) = '"<>"Calculate"<> Name<>"'\n \n"];


WriteString[sphenoTree, Name <>" = 0._dp \n"];
WriteString[sphenoTree, MixingName1 <>" = 0._dp \n"];
WriteString[sphenoTree, MixingName2 <>" = 0._dp \n"]; 

For[i2=1,i2<=ToExpression[dimMatrix],
For[i3=1,i3<=ToExpression[dimMatrix],
MakeSPhenoCoupling[MatrixFunction[[i2,i3]]/. subVEVfixed,"mat("<>ToString[i2]<>","<>ToString[i3]<>")",sphenoTree];
i3++;];
i2++;];

WriteString[sphenoTree, "\n \n"];

If[FreeQ[QuadruplePrecision,particle],stringQP="";,stringQP="QP";];


WriteString[sphenoTree, "mat2 = Matmul(Transpose(Conjg(mat)),mat) \n"];

WriteString[sphenoTree, "If (Maxval(Abs(Aimag(mat2))).Eq.0._dp) Then \n"];
WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(Real(mat2,dp),"<>Name<>"2,"<>  MixingName2 <>"1,ierr,test) \n"];
WriteString[sphenoTree, MixingName2<>"2 = "<>MixingName2<>"1 \n"];
WriteString[sphenoTree, "Else \n"];
WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(mat2,"<>Name<>"2,"<>  MixingName2 <>"2,ierr,test) \n "];
WriteString[sphenoTree, "End If \n \n"];

WriteString[sphenoTree,"If ((ierr.Eq.-8).Or.(ierr.Eq.-9)) Then \n"];
WriteString[sphenoTree,"  Write(ErrCan,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"  If (ErrorLevel.Eq.2) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"    Call TerminateProgram \n"];
WriteString[sphenoTree,"  End If \n"];
WriteString[sphenoTree, "  ierr = 0 \n"];
WriteString[sphenoTree, "End If \n \n"];


WriteString[sphenoTree, "mat2 = Matmul(mat,Transpose(Conjg(mat))) \n"];

WriteString[sphenoTree, "If (Maxval(Abs(Aimag(mat2))).Eq.0._dp) Then \n"];
WriteString[sphenoTree, "Call EigenSystem"<>stringQP"(Real(mat2,dp),"<>Name<>"2,"<>  MixingName1 <>"1,ierr,test) \n \n \n"];
WriteString[sphenoTree, MixingName1<>"2 = "<>MixingName1<>"1 \n"];
WriteString[sphenoTree, "Else \n"];
WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(mat2,"<>Name<>"2,"<>  MixingName1 <>"2,ierr,test) \n \n \n"];
WriteString[sphenoTree, "End If \n"];
WriteString[sphenoTree, MixingName1 <>"2 = Conjg("<>MixingName1<>"2) \n \n"];


WriteString[sphenoTree,"If ((ierr.Eq.-8).Or.(ierr.Eq.-9)) Then \n"];
WriteString[sphenoTree,"  Write(ErrCan,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"  If (ErrorLevel.Eq.2) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"    Call TerminateProgram \n"];
WriteString[sphenoTree,"  End If \n"];
WriteString[sphenoTree, "  ierr = 0 \n"];
WriteString[sphenoTree, "End If \n \n"];


WriteString[sphenoTree, "mat2 = Matmul(Matmul( Conjg("<>MixingName1<>"2),mat),Transpose( Conjg("<>MixingName2<>"2))) \n"];
WriteString[sphenoTree, "Do i1=1,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "If (Abs(mat2(i1,i1)).gt.0._dp) Then \n"];
WriteString[sphenoTree, "phaseM = mat2(i1,i1) / Abs(mat2(i1,i1)) \n"];
WriteString[sphenoTree, MixingName2<>"2(i1,:) = phaseM *"<>MixingName2<>"2(i1,:) \n "];
WriteString[sphenoTree, "End if \n"];
WriteString[sphenoTree, "End Do \n \n"];


WriteString[sphenoTree, "Do i1=1,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "If (Abs("<>MixingName2<>"2(i1,i1)).gt.0._dp) Then \n"];
WriteString[sphenoTree, "phaseM = "<>MixingName2<>"2(i1,i1) / Abs("<>MixingName2<>"2(i1,i1)) \n"];
WriteString[sphenoTree, MixingName2<>"2(i1,:) = Conjg(phaseM) *"<>MixingName2<>"2(i1,:) \n "];
WriteString[sphenoTree, MixingName1<>"2(i1,:) = phaseM *"<>MixingName1<>"2(i1,:) \n "];
WriteString[sphenoTree, "End if \n"];
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).ne."<>Name<>"2(i1)) Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "  If (Abs("<>Name<>"2(i1)).Le.MaxMassNumericalZero) "<>Name<>"2(i1) = Abs("<>Name<>"2(i1))+1.E-10_dp \n"]; 
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).Le.0._dp) Then \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(10,*) 'a mass squarred is negative: ',i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree, "      Write(*,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(*,*) 'a mass squarred is negative: ',i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) i1,"<>Name<>"2(i1) \n"];
];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  "<>Name<>"2(i1) = 1._dp \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];];
WriteString[sphenoTree, "! kont = -104 \n"];
WriteString[sphenoTree, " End if \n"];

WriteString[sphenoTree, "End Do \n \n"];

WriteString[sphenoTree, "If (ierr.Ne.0.) Then \n"];
WriteString[sphenoTree, "  Write(ErrCan,*) 'Warning from Subroutine Calculate"<>Name<>", ierr =',ierr \n"];
WriteString[sphenoTree, "  kont = ierr \n"];
WriteString[sphenoTree, "  Iname = Iname - 1 \n"];
WriteString[sphenoTree, "  Return \n"];
WriteString[sphenoTree, "End If \n\n\n"];


WriteString[sphenoTree, Name <>" = Sqrt( "<>Name <>"2 ) \n"];
WriteString[sphenoTree, MixingName1 <> " = "<>MixingName1<>"2 \n"];
WriteString[sphenoTree, MixingName2 <> " = "<>MixingName2<>"2 \n"]; 

If[FreeQ[ConditionForMassOrdering,particle]==False,
pos =Position[ConditionForMassOrdering,particle][[1,1]];
WriteString[sphenoTree,ConditionForMassOrdering[[pos,2]]];
];


WriteString[sphenoTree, "Iname = Iname - 1 \n \n"];
WriteString[sphenoTree, "End Subroutine " <> "Calculate"<>Name <>suffix <> " \n\n"];


];


SetPoleMasses[file_]:=Block[{},
WriteString[file,SPhenoForm[SPhenoMass[VectorW]] <> " = mW \n"];
WriteString[file,SPhenoForm[SPhenoMassSq[VectorW]] <> " = mW2 \n"];
WriteString[file,SPhenoForm[SPhenoMass[VectorZ]] <> " = mZ \n"];
WriteString[file,SPhenoForm[SPhenoMassSq[VectorZ]] <> " = mZ2 \n"];

WriteString[file,SPhenoForm[SPhenoMass[Electron]] <> "(1:3) = mf_l \n"];
WriteString[file,SPhenoForm[SPhenoMassSq[Electron]] <> "(1:3) = mf_l**2 \n"];
WriteString[file,SPhenoForm[SPhenoMass[TopQuark]] <> "(1:3) = mf_u \n"];
WriteString[file,SPhenoForm[SPhenoMassSq[TopQuark]] <> "(1:3) = mf_u**2 \n"];
WriteString[file,SPhenoForm[SPhenoMass[BottomQuark]] <> "(1:3) = mf_d \n"];
WriteString[file,SPhenoForm[SPhenoMassSq[BottomQuark]] <> "(1:3) = mf_d**2 \n"];
];



WriteTreeMassFunctionVector[Name_,MixingName_,ResMasses_,Angles_,MatrixFunction_,Parameters_,AllInvFields_]:=Block[{i,i2,i3,pos,suffix,subVEVfixed},

If[MassesForEffpot===True,
suffix="EffPot";
subVEVfixed=subStableVEVs;,
suffix="";
subVEVfixed={};
];

MakeSubroutineTitle["Calculate"<>Name<>suffix ,Parameters,{},Flatten[{MixingName,ResMasses,Table[ResMasses[[i2]]<>"2",{i2,1,Length[ResMasses]}],SPhenoForm/@Angles,"kont"}],sphenoTree];

MakeVariableList[Parameters,", Intent(in)",sphenoTree];
If[Angles=!={},
MakeVariableList[Angles,", Intent(out)",sphenoTree];
];
WriteString[sphenoTree, "Integer, Intent(inout) :: kont \n"];
WriteString[sphenoTree, "Integer :: i1,i2,i3,i4, ierr \n"];
WriteString[sphenoTree,"Integer :: j1,j2,j3,j4 \n"];

dimMatrix = ToString[Dimensions[MatrixFunction][[1]]];
For[i2=1,i2<=Length[ResMasses],
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> ResMasses[[i2]] <>", " <> ResMasses[[i2]]<>"2" <>"\n" ];
i2++;
];
WriteString[sphenoTree, "Real(dp) :: "<>Name<>"2("<>dimMatrix<>"),"<>Name<>"("<>dimMatrix<>")  \n\n"];

If[FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "Complex(dp), Intent(out) :: "<> MixingName<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Complex(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>")  \n\n"];,
WriteString[sphenoTree, "Real(dp), Intent(out) :: "<> MixingName<>"("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
WriteString[sphenoTree, "Real(dp) :: mat"<>"("<>dimMatrix<>","<>dimMatrix<>")  \n\n"];
];

WriteString[sphenoTree, "Real(dp) ::  test(2) \n\n"];

If[FreeQ[ConditionForMassOrdering,particle]==False,
WriteString[sphenoTree, "Real(dp) :: "<> Name <>"2temp("<>dimMatrix <>") \n" ];
WriteString[sphenoTree, "Complex(dp) :: "<> MixingName<>"temp("<>dimMatrix <>","<>dimMatrix <>") \n \n"];
];


WriteString[sphenoTree, "Iname = Iname + 1 \n"];
WriteString[sphenoTree, "NameOfUnit(Iname) = '"<>"Calculate"<> Name<>"'\n \n"];

For[i2=1,i2<=ToExpression[dimMatrix],
For[i3=i2,i3<=ToExpression[dimMatrix],
MakeSPhenoCoupling[MatrixFunction[[i2,i3]]/.subVEVfixed,"mat("<>ToString[i2]<>","<>ToString[i3]<>")",sphenoTree];
i3++;];
i2++;];

WriteString[sphenoTree, "\n \n "];

WriteString[sphenoTree,"Do i1=2,"<>dimMatrix <>"\n"];
WriteString[sphenoTree, "  Do i2 = 1, i1-1 \n"];
If[FreeQ[realVar,ToExpression[MixingName]],
WriteString[sphenoTree, "  mat(i1,i2) = Conjg(mat(i2,i1)) \n"];,
WriteString[sphenoTree, "  mat(i1,i2) = mat(i2,i1) \n"];
];
WriteString[sphenoTree, "  End do \n"];
WriteString[sphenoTree, "End do \n"]; 

WriteString[sphenoTree, "\n \n"];

If[FreeQ[QuadruplePrecision,particle],stringQP="";,stringQP="QP";];


 WriteString[sphenoTree, "Call EigenSystem"<>stringQP<>"(mat,"<> Name <>"2,"<>  MixingName <>",ierr,test) \n \n \n"]; 

WriteString[sphenoTree, MixingName <>" = Transpose("<>MixingName<>") \n"];

WriteString[sphenoTree,"If ((ierr.Eq.-8).Or.(ierr.Eq.-9)) Then \n"];
WriteString[sphenoTree,"  Write(ErrCan,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"  If (ErrorLevel.Eq.2) Then \n"];
WriteString[sphenoTree,"  Write(*,*) \"Possible numerical problem in \"//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"    Call TerminateProgram \n"];
WriteString[sphenoTree,"  End If \n"];
WriteString[sphenoTree, "  ierr = 0 \n"];
WriteString[sphenoTree, "End If \n \n"];

WriteString[sphenoTree, "If ((ierr.Ne.0.).And.(ErrorLevel.Ge.-1)) Then \n"];
WriteString[sphenoTree, "  Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "  Write(10,*) 'Diagonalization failed, ierr : ',ierr \n"];
WriteString[sphenoTree, "  kont = ierr \n"];
WriteString[sphenoTree, "  Iname = Iname - 1 \n"];
WriteString[sphenoTree, "  Return \n"];
WriteString[sphenoTree, "End If \n\n\n"];


WriteString[sphenoTree, "Do i1=1,"<>dimMatrix<> "\n"];
WriteString[sphenoTree, "  If (Abs("<>Name<>"2(i1)).Le.1.E-10_dp*(Maxval("<>Name<>"2))) "<>Name<>"2(i1) = 1.E-10_dp \n"]; 
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).ne."<>Name<>"2(i1)) Then \n"];
WriteString[sphenoTree, "      Write(*,*) 'NaN appearing in '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Call TerminateProgram \n"];
WriteString[sphenoTree, "    End If \n"];
WriteString[sphenoTree, "  If ("<>Name<>"2(i1).Ge.0._dp) Then \n"];
WriteString[sphenoTree, "  "<>Name <>"(i1) =Sqrt("<>Name <> "2(i1) ) \n"];
WriteString[sphenoTree, "  Else \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "    If (ErrorLevel.Ge.0) Then \n"];
WriteString[sphenoTree, "      Write(10,*) 'Warning from Subroutine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree, "      Write(10,*) 'a mass squarred is negative: ',i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree, "    End If \n"];
];
WriteString[sphenoTree, "  "<>Name <>"(i1)= 1._dp \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  "<>Name <>"2(i1)= 1._dp  \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(ErrCan,*) i1,"<>Name<>"2(i1) \n"];
WriteString[sphenoTree,"     Write(*,*) 'Warning from routine '//NameOfUnit(Iname) \n"];
WriteString[sphenoTree,"     Write(*,*) 'in the calculation of the masses' \n"];
WriteString[sphenoTree,"     Write(*,*) 'occurred a negative mass squared!' \n"];
WriteString[sphenoTree,"     Write(*,*) i1,"<>Name<>"2(i1) \n"];
];
WriteString[sphenoTree, "  "<>Name <>"(i1)= 1._dp \n"];
If[MassesForEffpot===False,
WriteString[sphenoTree, "  "<>Name <>"2(i1) = 1._dp  \n"];
WriteString[sphenoTree,"   SignOfMassChanged = .True. \n"];
];
WriteString[sphenoTree, "! kont = -104 \n"];
WriteString[sphenoTree, " End if \n"];
WriteString[sphenoTree, "End Do \n \n"];

For[i=1,i<=Length[AllInvFields],
If[FreeQ[massless,AllInvFields[[i]]] && FreeQ[Take[AllInvFields,{1,i-1}],getBlank[AllInvFields[[i]]]],
WriteString[sphenoTree, SPhenoForm[SPhenoMass[getBlank[AllInvFields[[i]]]]] <>" = "<>Name<>"("<>ToString[i]<>") \n"];
WriteString[sphenoTree, SPhenoForm[SPhenoMassSq[getBlank[AllInvFields[[i]]]]] <>" = "<>Name<>"2("<>ToString[i]<>") \n"];
];
i++;];

For[i=1,i<=Length[Angles],
If[MassesForEffpot=!=True,
WriteString[sphenoTree, SPhenoForm[Angles[[i]]] <>" = "<>SPhenoForm[Angles[[i]] /. subDependencesSPheno] <>"\n"];
];
i++;];


WriteString[sphenoTree, "\n "];


WriteString[sphenoTree, "Iname = Iname - 1 \n \n"];
WriteString[sphenoTree, "End Subroutine " <> "Calculate"<>Name <>suffix <> " \n\n"];


];


WriteCalcAllTreeMassesSM:=Block[{i2},

Print["  Writing routine for calculating SM masses"];

subCouplingsSPheno={};
For[i2=1,i2<=4,
subCouplingsSPheno=Join[subCouplingsSPheno,(subValue[i2,1] /. subIndFinal[i2,i2])];
i2++;];

MakeSubroutineTitle["TreeMassesSM",Join[NewMassParametersSM,Join[listVEVs,listAllParameters]],{},{"GenerationMixing","kont"},sphenoTree];


WriteString[sphenoTree, "Implicit None \n \n"];


MakeVariableList[listAllParameters,",Intent(in)",sphenoTree];
MakeVariableList[NewMassParametersSM,",Intent(out)",sphenoTree];
MakeVariableList[listVEVs,",Intent(in)",sphenoTree];
If[NewNumericalDependences=!={},
MakeVariableList[Transpose[NewNumericalDependences ][[1]],"",sphenoTree];
];

WriteString[sphenoTree,"Logical, Intent(in) :: GenerationMixing \n"];
WriteString[sphenoTree,"Integer, Intent(inout) :: kont \n"];

WriteString[sphenoTree,"Integer :: i1,i2,i3,i4,j1,j2,j3,kontSave \n"];


WriteString[sphenoTree, "Iname = Iname + 1 \n"];
WriteString[sphenoTree, "NameOfUnit(Iname) = 'TreeMasses" <>Modelname,"'\n \n"];
WriteString[sphenoTree, "kont = 0 \n"];

For[i=1,i<=Length[NewNumericalDependences],
WriteString[sphenoTree, FortranLineBreak[SPhenoForm[NewNumericalDependences[[i,1]]] <> " = " <> SPhenoForm[NewNumericalDependences[[i,2]]],5] <> "\n"];
i++;];

 For[i=1,i<=Length[ListTree],
If[FreeQ[SMParticles,ListMassES[[i,1]]]==False,
If[FreeQ[GoldstoneGhost,ListMassES[[i,1]]]==False,
WriteString[sphenoTree, "kontSave = kont \n"];
];
Switch[ListTree[[i,4]],
ScalarMass,
MakeCall["Calculate"<>ListTree[[i,1]],Flatten[{ListTree[[i,5]],ListTree[[i,2]],ListTree[[i,6]],ListTree[[i,7]]}],{},{"kont"},sphenoTree];,
FermionMassSymm,MakeCall["Calculate"<>ListTree[[i,1]],Flatten[{ListTree[[i,5]],ListTree[[i,2]],ListTree[[i,6]]}],{},{"kont"},sphenoTree];
WriteString[sphenoTree,SPhenoForm[ListTree[[i,7]]] <>" = "<>SPhenoForm[ListTree[[i,6]]]  <>"**2 \n"];,
FermionMassNonSymm,MakeCall["Calculate"<>ListTree[[i,1]],Flatten[{ListTree[[i,5]],ListTree[[i,2,1]],ListTree[[i,2,2]],ListTree[[i,6]]}],{},{"kont"},sphenoTree]; 
WriteString[sphenoTree,SPhenoForm[ListTree[[i,7]]] <>" = "<>SPhenoForm[ListTree[[i,6]]]  <>"**2 \n"];
];

If[FreeQ[GoldstoneGhost,ListMassES[[i,1]]]==False,
WriteString[sphenoTree, "kont = kontSave \n"];
];
];
i++;];

WriteString[sphenoTree, "\n \n "];

For[i=1,i<=Length[ListTreeVB],
If[Select[ListTreeVB[[i,8]],(FreeQ[SMParticles,#]==False)&]=!={},
MakeCall["Calculate"<>ListTreeVB[[i,1]],ListTreeVB[[i,2]],{},Flatten[{ListTreeVB[[i,3]],ListTreeVB[[i,4]],ListTreeVB[[i,5]],SPhenoForm/@ListTreeVB[[i,6]],"kont"}],sphenoTree];
];
i++;];


(* Print["Write other Tree-Level Masses"]; *)

Print["  Writing SM Masses: ",Dynamic[DynamicMassSMNr],"/",Length[listNotMixedMasses],"(",Dynamic[DynamicMassNameSM],")"];

For[i=1,i<=Length[listNotMixedMasses],
DynamicMassSMNr=i;
DynamicMassNameSM=listNotMixedMasses[[i,1]];
If[FreeQ[SMParticles, listNotMixedMasses[[i,1]]]==False,
Switch[getType[listNotMixedMasses[[i,1]]],
F,
If[Length[Dimensions[listNotMixedMasses[[i,5]]]]==2,
WriteString[sphenoTree,"Do i1=1,"<>ToString[getGenSPheno[listNotMixedMasses[[i,1]]]] <>"\n"];
If[FreeQ[listNotMixedMasses[[i,4]],sum],
WriteString[sphenoTree,SPhenoMass[listNotMixedMasses[[i,1]],i1] <>"= "<>SPhenoForm[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ,SPhenoMass[listNotMixedMasses[[i,1]],i1],sphenoTree];
];
WriteString[sphenoTree,SPhenoMassSq[listNotMixedMasses[[i,1]],i1] <>"= "<>SPhenoMass[listNotMixedMasses[[i,1]],i1] <>"**2 \n"];
WriteString[sphenoTree,"End Do \n \n"];,
If[listNotMixedMasses[[i,4]]=!=0,
If[FreeQ[listNotMixedMasses[[i,4]],sum],
(* WriteString[sphenoTree,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>" = "<>SPhenoForm[listNotMixedMasses[[i,4]] /.NewNumericalDependencesSub /. subCouplingsSPheno]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]]  /.NewNumericalDependencesSub /. subCouplingsSPheno ,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]],sphenoTree]; *)
WriteString[sphenoTree,FortranLineBreak[ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>" = "<>SPhenoForm[listNotMixedMasses[[i,4]] /. subCouplingsSPheno],5]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]]  /. subCouplingsSPheno ,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]],sphenoTree];
];


If[FreeQ[ParticlePhases,listNotMixedMasses[[i,1]]]==False,
pos = Position[ParticlePhases,listNotMixedMasses[[i,1]]][[1,1]];
WriteString[sphenoTree,SPhenoForm[ParticlePhases[[pos,2]]] <> " = Abs("<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>")/"<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"\n"];
];


WriteString[sphenoTree,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>" = Abs("<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>") \n"];
WriteString[sphenoTree,ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" = "<>ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]  <>"**2 \n"];
];
];,
_,
If[getType[listNotMixedMasses[[i,1]]]===S || SA`NewGaugeSector ==False,
If[Length[Dimensions[listNotMixedMasses[[i,5]]]]==2,
WriteString[sphenoTree,"Do i1=1,"<>ToString[getGenSPheno[listNotMixedMasses[[i,1]]]] <>"\n"];
If[FreeQ[listNotMixedMasses[[i,4]],sum],
WriteString[sphenoTree,SPhenoMassSq[listNotMixedMasses[[i,1]],i1] <>"= "<>SPhenoForm[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]] /. {gt1->i1, gt2->i1} ,SPhenoMassSq[listNotMixedMasses[[i,1]],i1],sphenoTree];
];
WriteString[sphenoTree,SPhenoMass[listNotMixedMasses[[i,1]],i1] <>"= sqrt("<>SPhenoMassSq[listNotMixedMasses[[i,1]],i1] <>") \n"];
WriteString[sphenoTree,"End Do \n \n"];,
If[listNotMixedMasses[[i,4]]=!=0,
If[FreeQ[listNotMixedMasses[[i,4]],sum],
WriteString[sphenoTree,FortranLineBreak[ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]<>" = "<>SPhenoForm[listNotMixedMasses[[i,4]]  /.subCouplingsSPheno],5]  <>" \n"];,
MakeSPhenoCoupling[listNotMixedMasses[[i,4]]   /. subCouplingsSPheno ,ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]],sphenoTree]; 
]; 
WriteString[sphenoTree,ToString[SPhenoMass[listNotMixedMasses[[i,1]]]]<>" = sqrt("<>ToString[SPhenoMassSq[listNotMixedMasses[[i,1]]]]  <>") \n"];
];
];
];
];
];
i++;];
DynamicMassNameSM="All Done";

WriteString[sphenoTree, "Iname = Iname - 1 \n \n"];

WriteString[sphenoTree, "End Subroutine  TreeMassesSM \n \n \n"];

];



GenerateSortGoldstones[eigenstates_]:=Block[{i,j,k,scalars, gold,cGold,mm,mTemp,ZTemp, mC, ZC},
If[IntermediateScale === True,
MakeSubroutineTitle["SortGoldstones"<>ToString[RegimeNr],NewMassParameters,{},{"kont"},sphenoTree];,
MakeSubroutineTitle["SortGoldstones",NewMassParameters,{},{"kont"},sphenoTree];
];

MakeVariableList[NewMassParameters,",Intent(inout)",sphenoTree];
WriteString[sphenoTree,"Integer, Intent(inout) :: kont \n"];
WriteString[sphenoTree,"Integer :: i1, i2, pos \n"];

gold=GoldstoneBosons[eigenstates];
scalars=Intersection[Transpose[gold][[2]] /. A_[_]->A];

For[i=1,i<=Length[scalars],
If[getGen[scalars[[i]]]>1,
dim=ToString[getGen[scalars[[i]]]];
WriteString[sphenoTree,"Real(dp) :: M"<>SPhenoForm[scalars[[i]]]<>"temp("<>dim<>") \n"];
WriteString[sphenoTree,"Complex(dp) :: Z"<>SPhenoForm[scalars[[i]]]<>"temp("<>dim<>","<>dim<>") \n"];
];
i++;];

WriteString[sphenoTree, "\n\n"];

For[i=1,i<=Length[scalars],
If[getGen[scalars[[i]]]>1,
WriteStrong[sphenoTree,"! ---- Order "<>SPhenoForm[scalars[[i]]]<>"--- \n"];
cGold=Select[gold,(FreeQ[#,scalars[[i]]]==False)&];
If[Length[cGold]>1,cGold=Sort[cGold,(#1[[2,1,1]]<#2[[2,1,1]])&]];
For[j=1,j<=Length[cGold],
WriteStrong[sphenoTree,"! Search for Goldstone of "<>SPhenoForm[cGold[[j,1]]]<>"--- \n"];
WriteString[sphenoTree,"pos = MinLoc(Abs("<>SPhenoForm[SPhenoMassSq[scalars[[i]]]]<>"-"<>SPhenoForm[SPhenoMassSq[cGold[[j,1]]]RXi[ToExpression[StringDrop[ToString[cGold[[j,1]]],1]]]]<>"),1) \n"];
WriteString[sphenoTree, "If (pos.ne."<>ToString[j]<>") Then \n"];
mTemp= "M"<>SPhenoForm[scalars[[i]]]<>"temp";
ZTemp= "Z"<>SPhenoForm[scalars[[i]]]<>"temp";
mC = SPhenoForm[SPhenoMassSq[scalars[[i]]]];
ZC=SPhenoForm[getMixingMatrix[scalars[[i]]]];
WriteString[sphenoTree,"  "<>mTemp<>" = "<>mC<>" \n"];
WriteString[sphenoTree,"  "<>ZTemp<>" = "<>ZC<>" \n"];
WriteString[sphenoTree,"  "<>mC<>"("<>ToString[j]<>") = "<>mTemp<>"(pos) \n"];
WriteString[sphenoTree,"  "<>ZC<>"("<>ToString[j]<>",:) = "<>ZTemp<>"(pos,:) \n"];
WriteString[sphenoTree,"  "<>mC<>"(pos) = "<>mTemp<>"("<>ToString[j]<>") \n"];
WriteString[sphenoTree,"  "<>ZC<>"(pos,:) = "<>ZTemp<>"("<>ToString[j]<>",:) \n"];
WriteString[sphenoTree,"End if \n"];
j++;];
WriteString[sphenoTree,"\n ! Reorder the physical states by their mass \n"];
dim=ToString[getGen[scalars[[i]]]];
WriteString[sphenoTree, "Do i1="<>ToString[Length[cGold]+1]<>","<>dim<>"\n "];
WriteString[sphenoTree, "pos = Minloc("<>mC<>"(i1:"<>dim<>"),1) + i1 -1  \n"];
WriteString[sphenoTree, "If (pos.ne.i1) Then \n"];
WriteString[sphenoTree,"  "<>mTemp<>" = "<>mC<>" \n"];
WriteString[sphenoTree,"  "<>ZTemp<>" = "<>ZC<>" \n"];
WriteString[sphenoTree,"  "<>mC<>"(i1) = "<>mTemp<>"(pos) \n"];
WriteString[sphenoTree,"  "<>ZC<>"(i1,:) = "<>ZTemp<>"(pos,:) \n"];
WriteString[sphenoTree,"  "<>mC<>"(pos) = "<>mTemp<>"(i1) \n"];
WriteString[sphenoTree,"  "<>ZC<>"(pos,:) = "<>ZTemp<>"(i1,:) \n"];
WriteString[sphenoTree, "End if \n"];
WriteString[sphenoTree,"End do \n"];
WriteString[sphenoTree,  SPhenoForm[SPhenoMass[scalars[[i]]]] <> " = sqrt("<>SPhenoForm[SPhenoMassSq[scalars[[i]]]]<>") \n"];
WriteString[sphenoTree,"\n \n \n"];
];
i++;];

If[IntermediateScale === True,
WriteString[sphenoTree,"End subroutine SortGoldstones"<>ToString[RegimeNr]<>" \n\n"];,
WriteString[sphenoTree,"End subroutine SortGoldstones \n\n"];
];
];
