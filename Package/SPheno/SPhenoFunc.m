(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)

(* Generating Module Elements *)

MakeFunction[name_,possibleParameters_, additionalParameters1_,additionalParameters2_, string_, file_]:=Block[{i, TitleSubroutine},

(* Basic function for MakeCall and MakeSubroutineTitle: *)
(* Takes a name for a function (name) and a Fortran command (string, i.e. Subroutine or Call) *)
(* as well as a list of parameters and creates a complete Fortran statement out of it *)
(* - possibleParameters: main part of the parameters *)
(* - additionalParameters1: additional parameters which are added BEFORE the main part of parameters *)
(* - additionalParameters2: additional parameters which are added AFTER the main part of parameters *)

TitleSubroutine = string<>" "<> name <>"(";

For[i=1,i<=Length[additionalParameters1],
TitleSubroutine = TitleSubroutine  <> additionalParameters1[[i]] <>","; 
i++;];

For[i=1,i<=Length[possibleParameters],
TitleSubroutine = TitleSubroutine <>SPhenoForm[possibleParameters[[i]]];
TitleSubroutine = TitleSubroutine <>",";
i++;];

For[i=1,i<=Length[additionalParameters2],
TitleSubroutine = TitleSubroutine  <> additionalParameters2[[i]] <>","; 
i++;];

TitleSubroutine = StringDrop[TitleSubroutine,-1] <>")";
WriteString[file,FortranLineBreak[TitleSubroutine,1]<>"\n\n"];

];

MakeSubroutineTitle[name_,possibleParameters_, additionalParameters1_,additionalParameters2_,file_]:=MakeFunction[name,possibleParameters, additionalParameters1,additionalParameters2,"Subroutine",file];

MakeCall[name_,possibleParameters_, additionalParameters1_,additionalParameters2_,file_]:=MakeFunction[name,possibleParameters, additionalParameters1,additionalParameters2,"Call",file]


(* ::Input::Initialization:: *)
MakeVariableList[PossibleParameters_,string_,file_]:=MakeVariableList[PossibleParameters,string,file,""];
MakeVariableList[PossibleParameters_,string_,file_,suffix_]:=Block[{i,j, NewString},
(* Write the varaible declaration to the Fortran file: *)
(* Takes a list of parameters and checks if they are Real or Complex and adds the dimension *)
(* "string" can be used to give the scope like Intent(in), Intent(out) or Intent(inout) *)


StringReal="";
StringComplex="";

For[i=1,i<=Length[PossibleParameters],
NewString = "";
NewString=NewString <> SPhenoForm[PossibleParameters[[i]]]<>suffix;
dimP=getDimSPheno[PossibleParameters[[i]]];
If[dimP=!={1} && dimP=!={}&& dimP=!={0},
NewString = NewString <>"(";
For[j=1,j<= Length[dimP],
NewString = NewString <>ToString[dimP[[j]]] <>",";
j++;];
NewString = StringDrop[NewString,-1]<>")";
];

If[MemberQ[realVar,PossibleParameters[[i]]]==False,
StringComplex = StringComplex<> NewString <>",";,
StringReal = StringReal<> NewString<>",";
];
i++;];

If[StringReal=!="", 
StringRealHead = "Real(dp)" <> string <> " :: ";
StringReal =  StringDrop[StringReal,-1];
StringReal = FortranLineBreakInterrupt[StringReal,0];
For[i=1,i<=Length[StringReal],
WriteString[file,StringRealHead <>StringReal[[i]]<>"\n\n"];
i++;];
];

If[StringComplex=!="", 
StringComplexHead ="Complex(dp)" <> string <> " :: ";
StringComplex = StringDrop[StringComplex,-1];
StringComplex = FortranLineBreakInterrupt[StringComplex,0];
For[i=1,i<=Length[StringComplex],
WriteString[file,StringComplexHead <>StringComplex[[i]]<>"\n\n"];
i++;];
];

Return[{StringReal,StringComplex}];
];


(* ::Input::Initialization:: *)
AddDim[x_]:=Block[{j,dimP,NewString},
(* Creates a string in Fortran format for the dimension of a parameter *)

NewString = "";
dimP=getDimSPheno[x];
If[dimP=!={1} && dimP=!={},  (* Check, if parameter is one-dimensional *)
NewString = NewString <>"(";
For[j=1,j<= Length[dimP],
NewString = NewString <>ToString[dimP[[j]]] <>",";
j++;];
NewString = StringDrop[NewString,-1]<>")";
];
Return[NewString];
];

AddDimAdj[x_]:=Block[{j,dimP,NewString},
(* Creates a string in Fortran format for the dimension of the ADJOINT of a parameter *)

NewString = "";
dimP=Reverse[getDimSPheno[x]];
If[dimP=!={1} && dimP=!={},
NewString = NewString <>"(";
For[j=1,j<= Length[dimP],
NewString = NewString <>ToString[dimP[[j]]] <>",";
j++;];
NewString = StringDrop[NewString,-1]<>")";
];
Return[NewString];
];

AddDimNames[x_]:=Block[{i,j,dimP,NewString},
(* Creates a string of the form "(gt1, gt2, ...)" depending on the number of generation indices of a parameter *)

NewString = "";
dimP=getIndexRangeSPheno[x];
NewString = NewString <>"(";
For[i=1,i<=Length[dimP],
For[j=1,j<=Length[dimP[[i]]],
NewString = NewString <>ToString[dimP[[i,j,1]] /. subGC[i] /. subIndFinal[i,i] ] <>",";
j++;];
i++;];

If[NewString==="(",
Return[""];,
NewString = StringDrop[NewString,-1]<>")";
];
Return[NewString];

];

getSPhenoCoupling[x_]:=getSPhenoCoupling[x,SPhenoCouplingsAll];

getSPhenoCoupling[x_,SPhenoCouplings_]:=Block[{pos,cList,pList},
(* Take a coupling of the form C[A,B,C] or Cp[A,B,C] involving specific fielda A,B,C (or D) and returns the variable names used in SPheno *)
(* The second argument gives the list of couplings which contains the coupling under considerations. The main possibilites are *)
(*  - SPhenoCouplingsAll: all tree level couplings *) 
(*  - SPhenoCouplingsLoop: all loop couplings (involving gauge eigenstates) *)
(*  - SPhenoCouplingsZW: couplings involving (massive) SM gauge bosons *)
(*  - SPhenoCouplingsEBT: couplings involving SM fermions *)
(*  - SPhenoCouplingsTadpoles: couplings needed for the calculation of one-loop tadpoles *)

(* RESULT: *)
(* This function returns a list of the form: *)
(* - Chiral couplings: {{coupL, couoR},{HC}} *)
(* - Non-Chiral couplings: {{coup},{HC}} *)
(* coupL/coupR are the two helicity compontents of a chiral coupling; HC contains the information if the hermitian conjugated is only saved in the given list *)
(* HC=False: the given coupling is part of the given list; HC=True: only the h.c. of the given coupling is contained in the given list *)


func = x /. Cp[a__]->C[a] /. A_[{a__}]->A;
If[FreeQ[SPhenoCouplings,func]==False,
pos=Position[SPhenoCouplings,func];
If[pos==={}, Print[x]];
cList=Extract[SPhenoCouplings,pos[[1,1]]][[2]];
pList=Last[Extract[SPhenoCouplings,pos[[1,1]]]];
If[getVertexType[x]===VVVV,
cList=OrderVVVV[List@@x,pList,Delete[cList,1]];
];
Return[{Delete[cList,1],pList}];,
pos=Position[SPhenoCouplings,ConjCoupling[func]];
If[pos==={}, Print[x]];
cList=Extract[SPhenoCouplings,pos[[1,1]]][[2]];
pList=Map[AntiField,Last[Extract[SPhenoCouplings,pos[[1,1]]]]];
If[getVertexType[x]===VVVV,
cList=OrderVVVV[List@@x,pList,Delete[cList,1]];
];
Return[{Delete[cList,1],pList}];
];

];

OrderVVVV[current_,standard_,names_]:=Block[{s1,s2,s3,c1,c2,c3,temp={1,2,3},res={},pos,nl={0},i},
s1 = g[standard[[1]],standard[[2]]]*g[standard[[3]],standard[[4]]] /. A_[{__}]->A;
s2 = g[standard[[1]],standard[[3]]]*g[standard[[2]],standard[[4]]] /. A_[{__}]->A;
s3 = g[standard[[1]],standard[[4]]]*g[standard[[2]],standard[[3]]] /. A_[{__}]->A;

c1 = g[current[[1]],current[[2]]]*g[current[[3]],current[[4]]] /. A_[{__}]->A;
c2 = g[current[[1]],current[[3]]]*g[current[[2]],current[[4]]] /. A_[{__}]->A;
c3 = g[current[[1]],current[[4]]]*g[current[[2]],current[[3]]] /. A_[{__}]->A;

pos= Position[{s1,s2,s3},c1];
pos = Select[Flatten[pos], MemberQ[temp,#]&];
res=Join[res,{pos[[1]]}];
temp=DeleteCases[temp,pos[[1]]];
pos= Position[{s1,s2,s3},c2];
pos = Select[Flatten[pos], MemberQ[temp,#]&];
res=Join[res,{pos[[1]]}];
temp=DeleteCases[temp,pos[[1]]];
res = Join[res,{temp[[1]]}];
For[i=1,i<=Length[res],
nl=Join[nl,{names[[res[[i]]]]}];
i++;];
Return[nl];
];


getSPhenoCoupling2[x_,SPhenoCouplings_]:=Block[{},

(* a slighty modified version of: 'getSPhenoCoupling'; the same comments do apply *)

func = x /. Cp[a__]->C[a] /. A_[{a__}]->A;

If[FreeQ[SPhenoCouplings,func]==False,
pos=Position[SPhenoCouplings,func];
cList=Extract[SPhenoCouplings,pos[[1,1]]][[2]];
pList=Last[Extract[SPhenoCouplings,pos[[1,1]]]];
Return[{Delete[cList,1],pList}];,
pos=Position[SPhenoCouplings,ConjCoupling[func]];
cList=Extract[SPhenoCouplings,pos[[1,1]]][[2]];
pList=Last[Extract[SPhenoCouplings,pos[[1,1]]]];
Return[{Delete[cList,1],pList}];
];

];


ConjCoupling[x_]:=Apply[C,Map[AntiField,x]];

AddDimNames2[x_]:=Block[{i,j,dimP,NewString},

(* a slightly modified version of 'AddDimNames'; the same comments do apply *)

NewString = "";
dimP={getIndexRangeSPheno[x]};
NewString = NewString <>"(";
For[i=1,i<=Length[dimP],
For[j=1,j<=Length[dimP[[i]]],
NewString = NewString <>ToString[dimP[[i,j,1]] /. subGC[i] /. subIndFinal[i,i] ] <>",";
j++;];
i++;];

If[NewString==="(",
Return[""];,
NewString = StringDrop[NewString,-1]<>")";
];
Return[NewString];

];


(* ::Input::Initialization:: *)

(* Sums and Loops *)


OpenDoes[x_,file_]:=Block[{i,j,k},
(* starts Do-loops in the Fortran code *)

openDo=0;
For[i=1,i<=Length[x],
For[j=1,j<=Length[x[[i]]],
For[k=1,k<=openDo,
WriteString[file, " "];
k++;];
WriteString[file,"Do "<> ToString[x[[i,j,1]] /. subGC[i] /.subIndFinal[i,i]] <>" = 1, " <>ToString[x[[i,j,2]]] <>"\n" ];
openDo++;
j++;];
i++;];
];


OpenDoes2[x_,file_]:=Block[{i,j,k},
(* starts Do-loops in the Fortran code *)

openDo2=0;
For[i=1,i<=Length[x],
For[j=1,j<=Length[x[[i]]],
For[k=1,k<=openDo2,
WriteString[file, " "];
k++;];
WriteString[file,"Do "<> ToString[x[[i,j,1]] /. subGC[i] /.subIndFinal[i,i]] <>" = 1, " <>ToString[x[[i,j,2]]] <>"\n" ];
openDo2++;
j++;];
i++;];
];


OpenDoName[x_,file_]:=Block[{},
openDo=0;
If[getDimParameters[x]=!={1} && getDimParameters[x]=!={},
dimP=getDimParameters[x];
For[k=1,k<=Length[dimP],
WriteString[sphenoRGE, "Do i"<>ToString[k]<>" = 1,"<>ToString[dimP[[k]]]<>"\n"];
openDo++;
k++;];
Switch[Length[dimP],
1,IndexString="(i1)";,
2,IndexString="(i1,i2)";,
3,IndexString="(i1,i2,i3)";
];,
IndexString="";
];

];

OpenDoName2[x_,file_]:=Block[{},
openDo2=0;
If[getDimParameters[x]=!={1} && getDimParameters[x]=!={},
dimP=getDimParameters[x];
For[k=1,k<=Length[dimP],
WriteString[sphenoRGE, "Do i"<>ToString[k]<>" = 1,"<>ToString[dimP[[k]]]<>"\n"];
openDo2++;
k++;];
Switch[Length[dimP],
1,IndexString="(i1)";,
2,IndexString="(i1,i2)";,
3,IndexString="(i1,i2,i3)";
];,
IndexString="";
];

];

CloseDoes[file_]:=Block[{i,j},
(* closes Do-loops in the Fortran code *)
For[i=1,i<=openDo,
For[k=1,k<=openDo-i,
WriteString[file, " "];
k++;];
WriteString[file, "End Do \n"];
i++];
];

CloseDoes2[file_]:=Block[{i,j},
(* closes Do-loops in the Fortran code *)
For[i=1,i<=openDo2,
For[k=1,k<=openDo2-i,
WriteString[file, " "];
k++;];
WriteString[file, "End Do \n"];
i++];
];

a_*sumSPheno[b_,c_,d_,e_] ^=sumSPheno[b,c,d,a*e];


(* ::Input::Initialization:: *)

(* Names and Indices *)

MakeIndices[x_]:=Block[{i,j},
newString="";
For[i=1,i<=Length[x],
For[j=1,j<=Length[x[[i]]],
newString = newString <>  ToString[x[[i,j,1]] /. subGC[i] /. subIndFinal[i,i]] <>",";
j++;];
i++;];

If[newString=!="",
newString = "(" <>StringDrop[newString,-1] <>")";
];
Return[newString];

];


(* ::Input::Initialization:: *)

getSignVertex[plist_,ref_,type_]:=Block[{i,temp,res=0,found=False,per},
temp = ref /. {A_[{b___}]->A};
ptemp=plist;
Switch[type,
VVV,per=permutationsVVV;,
SSV,per=permutationsSSV;
           temp = Select[temp,(getType[#]==S)&];
           ptemp = Select[ptemp,(getType[#]==S)&];
];
For[i=1,i<=Length[per],
If[found==False,
Switch[type,
VVV,
   If[{ptemp[[per[[i,1,1]]]],ptemp[[per[[i,1,2]]]],ptemp[[per[[i,1,3]]]]}===temp,
 found=True; 
 res=-per[[i,2]]
 ];,
SSV,
   If[{ptemp[[per[[i,1,1]]]],ptemp[[per[[i,1,2]]]]}===temp,
 found=True; 
 res=per[[i,2]];
 ];
];
];
i++;];
If[found==False,Print["Error in 'getSign' for vertex ",plist," ",ref]];
Return[res]; 
];


getSignVertexFA[plist_,ref_,type_]:=Block[{i,temp,res=0,found=False,per},
temp = ref /. {A_[{b___}]->A};
ptemp=plist;
Switch[type,
VVV,per=permutationsVVV;,
SSV,per=permutationsSSV;
           temp = Select[temp,(getType[#]==S)&];
           ptemp = Select[ptemp,(getType[#]==S)&];
];
For[i=1,i<=Length[per],
If[found==False,
Switch[type,
VVV,
   If[{ptemp[[per[[i,1,1]]]],ptemp[[per[[i,1,2]]]],ptemp[[per[[i,1,3]]]]}===temp,
 found=True; 
 res=per[[i,2]]
 ];,
SSV,
   If[{ptemp[[per[[i,1,1]]]],ptemp[[per[[i,1,2]]]]}===temp,
 found=True; 
 res=-per[[i,2]];
 ];
];
];
i++;];
If[found==False,Print["Error in 'getSign' for vertex ",plist," ",ref]];
Return[res]; 
];

getSignVertexOLD[plist_,ref_,type_]:=Block[{i,temp,res=0,found=False,per},
temp = ref /. {A_[{b___}]->A};
ptemp=plist;
Switch[type,
VVV,per=permutationsVVV;,
SSV,per=permutationsSSV;
           temp = Select[temp,(getType[#]==S)&];
           ptemp = Select[ptemp,(getType[#]==S)&];
];
For[i=1,i<=Length[per],
If[found==False,
Switch[type,
VVV,
   If[{ptemp[[per[[i,1,1]]]],ptemp[[per[[i,1,2]]]],ptemp[[per[[i,1,3]]]]}===temp,
 found=True; 
 res=per[[i,2]]
 ];,
SSV,
   If[{ptemp[[per[[i,1,1]]]],ptemp[[per[[i,1,2]]]]}===temp,
 found=True; 
 res=per[[i,2]];
(*  If[AntiField[ptemp[[per[[i,1,1]]]]]===ptemp[[per[[i,1,1]]]],res=-res;];  (* CHECK !! *)  *)
 ];
];
];
i++;];
If[found==False,Print["Error in 'getSign' for vertex ",plist," ",ref]];
Return[res];
];
permutationsVVV={{{1,2,3},1},{{2,1,3},-1},{{2,3,1},1},{{1,3,2},-1},{{3,1,2},1},{{3,2,1},-1}};
(* permutationsSSV={{{1,2,3},1},{{2,1,3},-1},{{3,1,2},1},{{3,2,1},-1},{{1,3,2},1},{{2,3,1},-1}}; *)
 permutationsSSV={{{1,2},1},{{2,1},-1}}; 

MakeIndicesCouplingWrapper[{a_,b_,c_,d_},proc_]:=MakeIndicesCoupling4[a,b,c,d,proc];
MakeIndicesCouplingWrapper[{a_,b_,c_},proc_]:=MakeIndicesCoupling[a,b,c,proc];

MakeIndicesCoupling[{p1_,in1_},{p2_,in2_},{p3_,in3_},proc_]:=MakeIndicesCoupling[{p1,in1},{p2,in2},{p3,in3},proc,False]

MakeIndicesCoupling[{p1_,in1_},{p2_,in2_},{p3_,in3_},proc_, adjoint_]:=Block[{pListTemp={},indexListTemp={},n2,i,HC,indRange={}},

(* Takes 3 external fields (p1,p2,p3) and the supposed generation indices (in1,in2, in3) and maps the generation indices in the correct order of 
a vertices involved in the current process (proc); adjoint is True/False depending on the fact, of the vertices or the adjoint vertices should be used. *) 

(* The result is a list of indices in the correct order as well as the information of the hermitian conjugated has to be used or not (HC=True/False). *)

If[getGenSPheno[p1]>1,
pListTemp = Join[pListTemp,{p1}];
indexListTemp = Join[indexListTemp,{in1}];
];

If[getGenSPheno[p2]>1,
pListTemp = Join[pListTemp,{p2}];
indexListTemp = Join[indexListTemp,{in2}];
];

If[getGenSPheno[p3]>1,
pListTemp = Join[pListTemp,{p3}];
indexListTemp = Join[indexListTemp,{in3}];
]; 

indRange={};

procTemp=proc /. a_[{x__}]->a;

If[adjoint==True,
procTemp = getConjugatedVertex[procTemp];
];

If[C@@procTemp=!=C@@{p1,p2,p3},
procTemp=getConjugatedVertex[procTemp];
HC=True;,
HC=False;
]; 


For[n2=1,n2<=3,
pos= Position[pListTemp,procTemp[[n2]],1];
If[pos=!={} && getGenSPheno[proc[[n2]]]>1,
indRange = Join[indRange,{Extract[indexListTemp,pos[[1,1]]]}];
pListTemp = Delete[pListTemp,pos[[1,1]]];
indexListTemp = Delete[indexListTemp,pos[[1,1]]];,
If[getGenSPheno[proc[[n2]]]>1,
Print["Not Found",procTemp[[n2]], procTemp,{p1,p2,p3}];
];
];
n2++;];


If[Length[indRange]>= 1,
ind="(";
For[n2=1,n2<=Length[indRange],
ind = ind <> ToString[indRange[[n2]]];
If[n2 =!= Length[indRange],ind=ind<>",";,ind=ind<>")";];
n2++;];,
ind="";
];
Return[{ind,HC,procTemp}];
];

MakeIndicesCoupling4color[{p1_,in1_},{p2_,in2_},{p3_,in3_},{p4_,in4_},proc_]:=Block[{pListTemp={},indexListTemp={},n2,i,HC,indRange={},ind},

pListTemp = Join[pListTemp,{p1}];
indexListTemp = Join[indexListTemp,{in1}];

pListTemp = Join[pListTemp,{p2}];
indexListTemp = Join[indexListTemp,{in2}];

pListTemp = Join[pListTemp,{p3}];
indexListTemp = Join[indexListTemp,{in3}];

pListTemp = Join[pListTemp,{p4}];
indexListTemp = Join[indexListTemp,{in4}];

indRange={};

procTemp=proc /. a_[{x__}]->a;

If[C@@procTemp=!=C@@{p1,p2,p3,p4},
procTemp=getConjugatedVertex[procTemp];
HC=True;,
HC=False;
]; 



For[n2=1,n2<=4,
pos= Position[pListTemp,procTemp[[n2]],1];
If[pos=!={},
indRange = Join[indRange,{Extract[indexListTemp,pos[[1,1]]]}];
pListTemp = Delete[pListTemp,pos[[1,1]]];
indexListTemp = Delete[indexListTemp,pos[[1,1]]];
];
n2++;];


Return[indRange];
];

MakeIndicesCoupling4[{p1_,in1_},{p2_,in2_},{p3_,in3_},{p4_,in4_},proc_]:=Block[{pListTemp={},indexListTemp={},n2,i,HC,indRange={}},

(* Takes 3 external fields (p1,p2,p3) and the supposed generation indices (in1,in2, in3) and maps the generation indices in the correct order of 
a vertices involved in the current process (proc); adjoint is True/False depending on the fact, of the vertices or the adjoint vertices should be used. *) 

(* The result is a list of indices in the correct order as well as the information of the hermitian conjugated has to be used or not (HC=True/False). *)

If[getGenSPheno[p1]>1,
pListTemp = Join[pListTemp,{p1}];
indexListTemp = Join[indexListTemp,{in1}];
];

If[getGenSPheno[p2]>1,
pListTemp = Join[pListTemp,{p2}];
indexListTemp = Join[indexListTemp,{in2}];
];

If[getGenSPheno[p3]>1,
pListTemp = Join[pListTemp,{p3}];
indexListTemp = Join[indexListTemp,{in3}];
]; 

If[getGenSPheno[p4]>1,
pListTemp = Join[pListTemp,{p4}];
indexListTemp = Join[indexListTemp,{in4}];
]; 

indRange={};

procTemp=proc /. a_[{x__}]->a;

If[adjoint==True,
procTemp = getConjugatedVertex[procTemp];
];

If[C@@procTemp=!=C@@{p1,p2,p3,p4},
procTemp=getConjugatedVertex[procTemp];
HC=True;,
HC=False;
]; 


For[n2=1,n2<=4,
pos= Position[pListTemp,procTemp[[n2]],1];
If[pos=!={} && getGenSPheno[proc[[n2]]]>1,
indRange = Join[indRange,{Extract[indexListTemp,pos[[1,1]]]}];
pListTemp = Delete[pListTemp,pos[[1,1]]];
indexListTemp = Delete[indexListTemp,pos[[1,1]]];,
If[getGenSPheno[proc[[n2]]]>1,
Print["Not Found",procTemp[[n2]], procTemp,{p1,p2,p3,p4}];
];
];
n2++;];


If[Length[indRange]>= 1,
ind="(";
For[n2=1,n2<=Length[indRange],
ind = ind <> ToString[indRange[[n2]]];
If[n2 =!= Length[indRange],ind=ind<>",";,ind=ind<>")";];
n2++;];,
ind="";
];

Return[{ind,HC}];
];

MakeIndicesCouplingPS[a___]=MakeIndicesCoupling[a];
(*

MakeIndicesCouplingPS[{p1_,in1_},{p2_,in2_},{p3_,in3_},proc_]:=MakeIndicesCouplingPS[{p1,in1},{p2,in2},{p3,in3},proc,False];
MakeIndicesCouplingPS[{p1_,in1_},{p2_,in2_},{p3_,in3_},proc_, adjoint_]:=Block[{pListTemp={},indexListTemp={},n2,i,HC,indRange={}},

(* Takes 3 external fields (p1,p2,p3) and the supposed generation indices (in1,in2, in3) and maps the generation indices in the correct order of 
a vertices involved in the current process (proc); adjoint is True/False depending on the fact, of the vertices or the adjoint vertices should be used. *) 

(* The result is a list of indices in the correct order as well as the information of the hermitian conjugated has to be used or not (HC=True/False). *)

If[getGenSPheno[p1]>1,
pListTemp = Join[pListTemp,{p1}];
indexListTemp = Join[indexListTemp,{in1}];
];

If[getGenSPheno[p2]>1,
pListTemp = Join[pListTemp,{p2}];
indexListTemp = Join[indexListTemp,{in2}];
];

If[getGenSPheno[p3]>1,
pListTemp = Join[pListTemp,{p3}];
indexListTemp = Join[indexListTemp,{in3}];
]; 

indRange={};

procTemp=proc /. a_[{x__}]\[Rule]a;

If[adjoint\[Equal]True,
procTemp = getConjugatedVertex[procTemp];
];

If[C@@procTemp=!=C@@{p1,p2,p3},
procTemp=getConjugatedVertex[procTemp];
HC=True;,
If[(Select[procTemp,(getType[#]\[Equal]F)&]===Reverse[Select[{p1,p2,p3},(getType[#]\[Equal]F)&]]) && Count[{p1,p2,p3},bar[x_]]===1,
If[Length[Intersection[RE/@Select[{p1,p2,p3},(getType[#]\[Equal]F)&]]]===1,
HC=True;,
HC=False;
];,
HC=False;
];
]; 


For[n2=1,n2\[LessEqual]3,
pos= Position[pListTemp,procTemp[[n2]],1];
If[pos=!={} && getGenSPheno[proc[[n2]]]>1,
indRange = Join[indRange,{Extract[indexListTemp,pos[[1,1]]]}];
pListTemp = Delete[pListTemp,pos[[1,1]]];
indexListTemp = Delete[indexListTemp,pos[[1,1]]];,
If[getGenSPheno[proc[[n2]]]>1,
Print["Not Found",procTemp[[n2]], procTemp,{p1,p2,p3}];
];
];
n2++;];


If[Length[indRange]\[GreaterEqual] 1,
ind="(";
For[n2=1,n2\[LessEqual]Length[indRange],
ind = ind <> ToString[indRange[[n2]]];
If[n2 =!= Length[indRange],ind=ind<>",";,ind=ind<>")";];
n2++;];,
ind="";
];

Return[{ind,HC}];
];

*)

getConjugatedVertex[vertex_]:= Map[AntiField,vertex];

getCorrespondingIndices[{p1_,n1_},{p2_,n2_},{p3_,n3_},q1_,q2_,q3_]:=Block[{i,listOrg,Norg,listFin,NFinCorr},
(* re-orders a list of given indices to other indices *)

listOrg={p1,p2,p3};
Norg={n1,n2,n3};
listFin={q1,q2,q3};
NFinCorr={};

For[i=1,i<=3,
pos=Position[listOrg,listFin[[i]],1][[1,1]];
NFinCorr=Join[NFinCorr,{Extract[Norg,pos]}];
listOrg=Delete[listOrg,pos];
Norg=Delete[Norg,pos];
i++;];
Return[NFinCorr];
];



MakeIndicesCoupling[{p1a_,in1a_},{p1b_,in1b_},{p2_,in2_},{p3_,in3_},proc_]:=Block[{pListTemp,indexListTemp,n2,i},

(* Takes 3 external fields (p1a,p2a,p3a) and the supposed generation indices (in1a,in2a, in3a) *)
(* maps the generation indices in the correct order of a vertices involved in the current process (proc) *) 

(* The result is a list of indices in the correct order as well as the information of the hermitian conjugated has to be used or not (HC=True/False). *)

pListTemp={};
indexListTemp={};

If[getGenSPheno[p1a]>1,
pListTemp = Join[pListTemp,{AntiField[p1a]}];
indexListTemp = Join[indexListTemp,{in1a}];
];

If[getGenSPheno[p1b]>1,
pListTemp = Join[pListTemp,{p1b}];
indexListTemp = Join[indexListTemp,{in1b}];
];

If[getGenSPheno[p2]>1,
pListTemp = Join[pListTemp,{p2}];
indexListTemp = Join[indexListTemp,{in2}];
];

If[getGenSPheno[p3]>1,
pListTemp = Join[pListTemp,{p3}];
indexListTemp = Join[indexListTemp,{in3}];
];

indRange={};

For[n2=1,n2<=4,
pos= Position[pListTemp,proc[[n2]] /. a_[{x__}]->a,1];
If[pos=!={} && getGenSPheno[proc[[n2]]]>1,
indRange = Join[indRange,{Extract[indexListTemp,pos[[1,1]]]}];
pListTemp = Delete[pListTemp,pos[[1,1]]];
indexListTemp = Delete[indexListTemp,pos[[1,1]]];
];
n2++;];



If[Length[indRange]>= 1,
ind="(";
For[n2=1,n2<=Length[indRange],
ind = ind <> ToString[indRange[[n2]]];
If[n2 =!= Length[indRange],ind=ind<>",";,ind=ind<>")";];
n2++;];,
ind="";
];

Return[ind];
];


SPhenoMass[x_]:=If[getType[x]===G,Return[SPhenoMass[getVectorBoson[x]]];,If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["M"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]]];,Return[0.]];];
SPhenoMassFK[x_]:=If[getType[x]===G,Return[SPhenoMassFK[getVectorBoson[x]]];,If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["M["<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"]"]];,Return[0]];];
SPhenoMassSq[x_]:=If[getType[x]===G,
If[FreeQ[massless,getVectorBoson[x]]==True,Return[ToExpression[ToString[SPhenoMass[x]]<>"2"]];,Return[0.]];,
If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression[ToString[SPhenoMass[x]]<>"2"]];,Return[0.]];
];
SPhenoMassSqOS[x_]:=If[getType[x]===G,
If[FreeQ[masslessSave,getVectorBoson[x]]==True,
Return[ToExpression[ToString[SPhenoMass[x]]<>"2OS"]];,
Return[0.]];,
If[FreeQ[masslessSave,getBlank[x]]==True,Return[ToExpression[ToString[SPhenoMass[x]]<>"2OS"]];,Return[0.]];
];
SPhenoMass[x_,nr_]:=Block[{},
If[getType[x]===G,Return[SPhenoMass[getVectorBoson[x],nr]];];
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]<>"("<>ToString[nr]<>")" ];,
If[FreeQ[massless,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]];,
Return["0._dp"];
];
];
];

SPhenoZFac[x_]:=ToExpression["ZRU"<>ToString[x]];
SPhenoZFacHead[x_]:=Block[{},
If[Head[x]===conj,
Return[ToExpression["ZRU"<>ToString[RE[x]]<>"c"]];,
Return[ToExpression["ZRU"<>ToString[x]]];
];
];

SPhenoMassOS[x_]:=If[getType[x]===G,Return[SPhenoMassOS[getVectorBoson[x]]];,If[FreeQ[masslessSave,getBlank[x]]==True,Return[ToExpression["M"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"OS"]];,Return[0.]];];

SPhenoMassOS[x_,nr_]:=Block[{},
If[getType[x]===G,Return[SPhenoMassOS[getVectorBoson[x],nr]];];
If[getGenSPheno[x]>1 && FreeQ[masslessSave,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]<>"OS("<>ToString[nr]<>")" ];,
 If[FreeQ[masslessSave,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]<>"OS"];,
Return["0."];
];
];
];


SPhenoMassFK[x_,nr_]:=Block[{},
If[getType[x]===G,Return[SPhenoMassFK[getVectorBoson[x],nr]];];
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return[ToString[SPhenoMassFK[x]]<>"["<>ToString[nr]<>"]" ];,
Return[ToString[SPhenoMassFK[x]]];
];
];

SPhenoWidth[x_]:=If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["gT"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]]];,Return[0.]];
SPhenoPartialWidth[x_]:=If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["gP"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]]];,Return[0.]];
SPhenoBR[x_]:=If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["BR"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]]];,Return[0.]];

SPhenoWidth[x_,nr_]:=Block[{},
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return[ToString[SPhenoWidth[x]]<>"("<>ToString[nr]<>")" ];,
Return[ToString[SPhenoWidth[x]]];
];
];

SPhenoWidth1L[x_]:=If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["gT1L"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]]];,Return[0.]];
SPhenoPartialWidth1L[x_]:=If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["gP1L"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]]];,Return[0.]];
SPhenoBR1L[x_]:=If[FreeQ[massless,getBlank[x]]==True,Return[ToExpression["BR1L"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]]];,Return[0.]];

SPhenoWidth1L[x_,nr_]:=Block[{},
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return[ToString[SPhenoWidth1L[x]]<>"("<>ToString[nr]<>")" ];,
Return[ToString[SPhenoWidth1L[x]]];
];
];


SPhenoRatioPseudo[x_,nr_]:=SPhenoRatioFun[x,nr,"ratP"];
SPhenoRatio[x_,nr_]:=SPhenoRatioFun[x,nr,"rat"];
SPhenoIncludeLoop[x_]:="Include_in_loop"<>SPhenoForm[x];

SPhenoRatioFun[x_,nr_,string_]:=Block[{},
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return[string<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr]<>")" ];,
Return[string<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]];
];
];

SPhenoRatioPseudoHB[x_,nr1_,nr2_]:=SPhenoHiggsBoundRatio[x,nr1,nr2,"rHB_P_"];
SPhenoRatioHB[x_,nr1_,nr2_]:=SPhenoHiggsBoundRatio[x,nr1,nr2,"rHB_S_"];
SPhenoRatioPseudoHBS[x_,nr1_,nr2_]:=SPhenoHiggsBoundRatio[x,nr1,nr2,"rHB_P_S_"];
SPhenoRatioPseudoHBP[x_,nr1_,nr2_]:=SPhenoHiggsBoundRatio[x,nr1,nr2,"rHB_P_P_"];
SPhenoRatioHBS[x_,nr1_,nr2_]:=SPhenoHiggsBoundRatio[x,nr1,nr2,"rHB_S_S_"];
SPhenoRatioHBP[x_,nr1_,nr2_]:=SPhenoHiggsBoundRatio[x,nr1,nr2,"rHB_S_P_"];

SPhenoHiggsBoundRatio[x_,nr1_,nr2_,string_]:=Block[{},
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return[string<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr1]<>","<>ToString[nr2]<>")" ];,
Return[string<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr1]<>")"];
];
];

SPhenoRatioSave[x_,nr1_,nr2_]:=Block[{},
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return["ratio"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr1]<>","<>ToString[nr2]<>")" ];,
Return["ratio"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr1]<>")"];
];
];


SPhenoRatioSavePseudo[x_,nr1_,nr2_]:=Block[{},
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return["ratioP"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr1]<>","<>ToString[nr2]<>")" ];,
Return["ratioP"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr1]<>")"];
];
];

SPhenoPartialWidth[x_,nr_,nr2_]:=Block[{},
If[getGenSPheno[x]>1,
Return["gP"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr]<>","<>ToString[nr2]")" ];,
Return["gP"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"(1,"<>ToString[nr2]")"];
];
];


SPhenoBR[x_,nr_,nr2_]:=Block[{},
If[getGenSPheno[x]>1,
Return["BR"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr]<>","<>ToString[nr2]<>")" ];,
Return["BR"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"(1,"<>ToString[nr2]<>")"];
];
];

SPhenoPartialWidth1L[x_,nr_,nr2_]:=Block[{},
If[getGenSPheno[x]>1,
Return["gP1L"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr]<>","<>ToString[nr2]")" ];,
Return["gP1L"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"(1,"<>ToString[nr2]")"];
];
];


SPhenoBR1L[x_,nr_,nr2_]:=Block[{},
If[getGenSPheno[x]>1,
Return["BR1L"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"("<>ToString[nr]<>","<>ToString[nr2]<>")" ];,
Return["BR1L"<>ToString[getBlank[x] /.diracSubBack1[SPheno`Eigenstates] /.diracSubBack2[SPheno`Eigenstates]]<>"(1,"<>ToString[nr2]<>")"];
];
];

SPhenoPDG[x_,nr_]:=Block[{},
If[getGenSPheno[x]>1,
Return["PDG"<>ToString[getBlank[x]]<>"("<>ToString[nr]<>")" ];,
Return["PDG"<>ToString[getBlank[x]]];
];
];

SPhenoNameArray[x_,nr_]:=Block[{},
If[getGenSPheno[x]>1,
Return["NameParticle"<>ToString[getBlank[x]]<>"("<>ToString[nr]<>")" ];,
Return["NameParticle"<>ToString[getBlank[x]]];
];
];


SPhenoPDG[x_]:=Block[{},
Return[ToExpression["PDG"<>ToString[getBlank[x]]]];
];

SPhenoPhase[x_] :=Block[{},
If[FreeQ[Gauginos,x]==True,
Return[0];,
Return[ToExpression["Phase"<>ToString[x]]];
];
];


SPhenoMassSq[x_,nr_]:=Block[{},
If[getType[x]===G,Return[SPhenoMassSq[getVectorBoson[x],nr]];];
If[getGenSPheno[x]>1 && FreeQ[massless,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]<>"2("<>ToString[nr]<>")" ];,
If[FreeQ[massless,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]<>"2"];,
Return["0._dp"];
];
];
];

SPhenoMassSqOS[x_,nr_]:=Block[{},
If[getType[x]===G,Return[SPhenoMassSqOS[getVectorBoson[x],nr]];];
If[getGenSPheno[x]>1 && FreeQ[masslessSave,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]<>"2OS("<>ToString[nr]<>")" ];,
If[FreeQ[masslessSave,getBlank[x]]==True,
Return[ToString[SPhenoMass[x]]<>"2OS"];,
Return["0._dp"];
];
];
];

MakeSquaredMass[x_]:=ToExpression[ToString[x]<>"2"];


getGenSPhenoStart[x_]:=Block[{part,max=1},

(* Returns the first PHYSICAL generation of field skipping the Goldstone fields *)

part=getBlank[x];
If[FreeQ[Transpose[GoldstoneGhost][[2]],part]==True,
Return[1];,
If[getGenSPheno[part]===1,
Return[2];,
While[FreeQ[Transpose[GoldstoneGhost][[2]],part[{max}]]==False,max++];
Return[max];
];
];
];


getGenSPheno[x_]:=Block[{part},

(* Returns the number of generation of a given field *)

If[FreeQ[GaugeMassES,getBlank[x]]==False,
part=Extract[GaugeMassESorg,Position[GaugeMassES,getBlank[x]][[1,1]]];,
part=getBlank[x];
];
Return[getGen[part]];
(*
If[FreeQ[Gauginos,part]\[Equal]False || FreeQ[bosons,part]\[Equal]False,
Return[1];,
Return[getGen[part]];
]; *)
];



getRotatedField[x_]:=If[FreeQ[GaugeMassES,getBlank[x]]==False,Return[Extract[GaugeMassESorg,Position[GaugeMassES,getBlank[x]][[1,1]]]];,
Return[x];];

SPhenoCouplingLeft[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"L"];
SPhenoCouplingRight[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"R"];

SPhenoCouplingV1[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"1"];
SPhenoCouplingV2[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"2"];
SPhenoCouplingV3[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"3"];

SPhenoCouplingV1Q[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"1Q"];
SPhenoCouplingV2Q[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"2Q"];
SPhenoCouplingV3Q[x_]:=ToExpression[ShortCoup[CouplingName[x]]<>"3Q"];

SPhenoCouplingColor[x_,y_]:=ToExpression[ShortCoup[CouplingName[x]]<>ShortColorForm[y]];

ShortColorForm[y_]:=Switch[y,
1,Return["1"];,
Delta[ct1,ct2],Return["aa"];,
Delta[ct1,ct3],Return["aa"];,
Delta[ct1,ct4],Return["aa"];,
Delta[ct2,ct3],Return["aa"];,
Delta[ct2,ct4],Return["aa"];,
Delta[ct3,ct4],Return["aa"];,
Delta[ct1,ct2] Delta[ct3,ct4],Return["aabb"];,
Delta[ct1,ct4] Delta[ct3,ct2],Return["abba"];,
Delta[ct1,ct3] Delta[ct2,ct4],Return["abab"];,
_,Return[StringReplace[SPhenoForm[y],{"("->"",")"->"",","->""," "->"","*"->""}]];
];

SPhenoCoupling[x_] :=ToExpression[ShortCoup[CouplingName[x]]];

ShortCoup[x_]:=StringReplace[x,"Coupling"->"cpl"];

SPhenoShortName[x_]:=Block[{temp},
temp="";
If[Head[x]===conj ||Head[x]===bar,
temp =temp<>"c";
];
Return[temp<>ToString[RE[x]]];
];


CouplingName[x_]:=Block[{i,texname,texnameL,texnameR,string,stringshort},
texname="\\Gamma^{";
string="";
For[i=1,i<=Length[x],
If[Head[x[[i]]]===conj || Head[x[[i]]]===bar,
string = string <>"c"<>SPhenoForm[getBlank[x[[i]]]];
texname=texname<>TeXOutput[AntiField[getBlank[x[[i]]]]];,
string = string <>SPhenoForm[getBlank[x[[i]]]];
texname=texname<>TeXOutput[getBlank[x[[i]]]]<>" ";
];
i++;];
texnameL=texname<>",L}";
texnameR=texname<>",R}";
texname=texname<>"}";
stringshort="cpl"<>string;
string="Coupling"<>string;
Format[ToExpression[stringshort<>"R"],TeXForm]=Format[texnameR,OutputForm];
Format[ToExpression[stringshort<>"L"],TeXForm]=Format[texnameL,OutputForm];
Format[ToExpression[stringshort],TeXForm]=Format[texname,OutputForm];
Return[string];
];

getDimSPheno[x_]:=Block[{pos},

(* Return the dimension of a parameter *)

If[Head[x]===Adj ||  Head[x]===Tp || Head[x]===conj || Head[x]===Conj,
pos=Position[SPhenoParameters,x[[1]]];,
pos=Position[SPhenoParameters,x]
];
If[pos=!={}, Return[Extract[SPhenoParameters,pos[[1,1]]][[3]]];,
Return[{}];
];
];

getIndexRangeSPheno[x_]:=Block[{},
pos=Position[SPhenoParameters,x];
If[pos=!={}, 
Return[Extract[SPhenoParameters,pos[[1,1]]][[4]]];,
Return[{}];
];
];




(* ::Input::Initialization:: *)

(* Fortran Output *)

Format[conj[x_],FortranForm]:=Format["Conjg("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[Conj[x_],FortranForm]:=Format["Conjg("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[Tp[x_],FortranForm]:=If[Length[getDimSPheno[x]]==2,
Format["Transpose("<>ToString[FortranForm[x]]<>")",OutputForm],
Format[ToString[FortranForm[x]],OutputForm]
]/;SARAHFortran==True;

Unprotect[Real,Complex,Rational, Integer, Times, Power,ArcCos,ArcSin,ArcTan,Sec,Csc,Cot, Complex,Exp];

Format[ArcCos[x_],FortranForm]:=Format["ACos("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[ArcSin[x_],FortranForm]:=Format["ASin("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[ArcTan[x_],FortranForm]:=Format["ATan("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[RealPart[x_],FortranForm]:=Format["Real("<>ToString[FortranForm[x]]<>",dp)",OutputForm]/;SARAHFortran==True;
Format[Csc[x_],FortranForm]:=Format["1/Sin("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[Sec[x_],FortranForm]:=Format["1/Cos("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[Cot[x_],FortranForm]:=Format["1/Tan("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[I,FortranForm]:=Format["(0._dp,1._dp)",OutputForm]/;SARAHFortran==True;
Format[FortranFalse,FortranForm]:=Format[".False.",OutputForm]/;SARAHFortran==True;
Format[FortranTrue,FortranForm]:=Format[".True.",OutputForm]/;SARAHFortran==True;
Format[NumberGenerations[x_],FortranForm]:=Format["NumberGenerations"<>ToString[FortranForm[x]],OutputForm]/;SARAHFortran==True;


(* Format[x_Power,FortranForm]:=Format["("<>ToString[FortranForm[x[[1]]]]<>")**("<>ToString[FortranForm[x[[2]]]]<>")",OutputForm]/;(Head[x[[1]]]===Rational &&SARAHFortran\[Equal]True); *)

Format[Power[a_,b_],FortranForm]:=Format["("<>ToString[FortranForm[a]]<>")**("<>ToString[FortranForm[b]]<>")",OutputForm]/;(Head[a]===Rational && b=!=1/2 &&SARAHFortran==True);

 Format[x_Complex, FortranForm]:=
Which[Re[x]===0,
Format[ToString[FortranForm[Im[x]]]<>"*(0.,1._dp)",OutputForm],
Im[x]===0,Format[ToString[FortranForm[Re[x]]]<>"*(1._dp,0.)",OutputForm];,
Re[x]=!=0 && Im[x]=!=0,Format["("<>ToString[FortranForm[Re[x]]]<>"*(1._dp,0)+"<>ToString[FortranForm[Im[x]]]<>"*(0,1._dp))",OutputForm]
]/;SARAHFortran==True;

(* Format[x_Complex, FortranForm]:=Format["("<>ToString[FortranForm[ Re[x]]]<>","<>ToString[FortranForm[ Im[x]]]<>")",OutputForm]; *)
Format[x_Real, FortranForm]:=Format[ToString[NumberForm[x,ExponentFunction->(Null&)]]<>"_dp",OutputForm]/;SARAHFortran==True;
Format[Sqrt[x_Integer], FortranForm]:=Format["sqrt("<>ToString[1.*x]<>"_dp)",OutputForm]/;SARAHFortran==True;
Format[Exp[x_], FortranForm]:=Format["exp("<>ToString[FortranForm[x]]<>")",OutputForm]/;SARAHFortran==True;
Format[1/Sqrt[x_Integer], FortranForm]:=Format["1._dp/sqrt("<>ToString[1.*x]<>"_dp)",OutputForm]/;SARAHFortran==True;
Format[x_Rational,FortranForm] :=Format[ToString[FortranForm[Numerator[x]]]<>"._dp/"<> ToString[FortranForm[Denominator[x]]]<>"._dp",OutputForm]/;SARAHFortran==True;
Format[Times[x_Integer,y_],FortranForm]:=Format[ToString[FortranForm[N[x]]]<>"*"<>ToString[FortranForm[y]],OutputForm] /; (Depth[y]<2 && SARAHFortran==True);
Format[Times[x_Integer,y_],FortranForm]:=Format[ToString[FortranForm[N[x]]]<>"*("<>ToString[FortranForm[y]]<>")",OutputForm] /; (Depth[y]<2 && SARAHFortran==True);
Protect[Real,Complex,Rational, Integer, Times,Power,ArcCos,ArcSin,Complex,Exp];


WriteStringFLB[file_,string_]:=WriteString[file,FortranLineBreak[StringReplace[string,{"+-"->" - ","+ -"->"-","+  -"->" - "}],3]];
FortranLineBreak[string_]:=FortranLineBreak[string,0];
FortranLineBreak[longString_,maxDiff_]:=Block[{i,i2,minLength,Counter,start,newString},

(* Function to break long string in several lines using & &  in Fortran. *)
(* maxDiff: the maximal difference between open and closed brackets to allow a line break *)

If[StringLength[longString] <75, Return[longString];];
minLength=70;
puffer=15;
start=minLength;
If[StringLength[longString]>start+puffer,testFin=puffer;,testFin = StringLength[longString] - start];

Counter=start;
newLetters=start;
newString=StringTake[longString,{1,start}];
openBracket=StringCount[newString,"("];
closeBracket=StringCount[newString,")"];


For[i=start+1,i<=StringLength[longString],
If[(StringLength[longString]- i)<10,
newString=newString<>StringTake[longString,{i}];
Counter++;
i++;,
diffBracket = openBracket - closeBracket;
If[diffBracket <=  maxDiff && diffBracket >= 0,BracketTrue=True;,BracketTrue=False;];
If[((StringTake[longString,{i}]===")")&&(StringTake[longString,{i+1}]=!=")")&&(StringTake[longString,{i+1,i+2}]=!=" )"))||((StringTake[longString,{i}]==="+"&&BracketTrue)||(StringTake[longString,{i}]==="-"&&BracketTrue) ||(StringTake[longString,{i}]===","&&BracketTrue)),

newString=newString<>StringTake[longString,{i}];
If[StringTake[longString,{i}]==")",closeBracket++];
If[StringTake[longString,{i}]=="(",openBracket++];

For[i2=1,i2<=85-newLetters,newString =newString <>" ";i2++;]; 
newString=newString<>"& \n"<>"& ";


If[StringLength[longString]-i<minLength+1,
ende=StringLength[longString];,
ende=i+minLength+1;
];

newString=newString <> StringTake[longString,{i+1,ende}];
Counter=ende;
openBracket=openBracket+StringCount[StringTake[longString,{i+1,ende}],"("];
closeBracket=closeBracket+StringCount[StringTake[longString,{i+1,ende}],")"];
newLetters=ende-i-1;
i=ende+1;,
newString=newString<>StringTake[longString,{i}];
If[StringTake[longString,{i}]==")",closeBracket++];
If[StringTake[longString,{i}]=="(",openBracket++];
newLetters++;
Counter++;
i++;
];
];
];
 Return[newString]; 
];



FortranLineBreakInterrupt[longString_,maxDiff_]:=Block[{i,i2,minLength,Counter,start,temp,lines,newString},
If[StringLength[longString] <75, Return[{longString}];];
minLength=70;
puffer=15;
start=minLength;
temp = {};
lines=0;
If[StringLength[longString]>start+puffer,testFin=puffer;,testFin = StringLength[longString] - start];

Counter=start;
newLetters=start;
newString=StringTake[longString,{1,start}];
openBracket=StringCount[newString,"("];
closeBracket=StringCount[newString,")"];

For[i=start+1,i<=StringLength[longString],
If[(StringLength[longString]- i)<10,
newString=newString<>StringTake[longString,{i}];
Counter++;
i++;,
diffBracket = openBracket - closeBracket;
If[diffBracket <=  maxDiff && diffBracket >= 0,BracketTrue=True;,BracketTrue=False;];
If[(StringTake[longString,{i}]===")")&&(StringTake[longString,{i+1}]=!=",")&&(StringTake[longString,{i+1}]=!=")")&&(StringTake[longString,{i+1,i+2}]=!=" )")||(StringTake[longString,{i}]==="+"&&BracketTrue)||(StringTake[longString,{i}]==="-"&&BracketTrue) ||(StringTake[longString,{i}]===","&&BracketTrue),

newString=newString<>StringTake[longString,{i}];
If[StringTake[longString,{i}]==")",closeBracket++];
If[StringTake[longString,{i}]=="(",openBracket++];

 If[lines<=35,
For[i2=1,i2<=85-newLetters,newString =newString <>" ";i2++;]; 
newString=newString<>"& \n"<>"& ";
lines++;,
lines = 0;
temp = Join[temp,{StringDrop[newString,-1]}];
newString="";
];

If[(StringLength[longString]-i)<(minLength+1),
ende=StringLength[longString];,
ende=i+minLength+1;
];

newString=newString <> StringTake[longString,{i+1,ende}];
Counter=ende;
openBracket=openBracket+StringCount[StringTake[longString,{i+1,ende}],"("];
closeBracket=closeBracket+StringCount[StringTake[longString,{i+1,ende}],")"];
newLetters=ende-i-1;
i=ende+1;,
newString=newString<>StringTake[longString,{i}];
If[StringTake[longString,{i}]==")",closeBracket++];
If[StringTake[longString,{i}]=="(",openBracket++];
newLetters++;
Counter++;
i++;
];
];
];
temp = Join[temp,{newString}];
Return[temp];
];


FortranLineBreak[leftside_,longString_,maxDiff_] := FortranLineBreak[leftside,longString,maxDiff,False]

FortranLineBreak[leftside_,longString_,maxDiff_,addfirst_]:=Block[{i,i2,minLength,Counter,start,lines,sign,newString},
If[StringLength[longString] <75, 
If[addfirst=!=True,
Return[leftside <>" = "<> longString];,
If[StringTake[longString,{1,1}]==="-",
Return[leftside <>" = "<>leftside <>longString];,
Return[leftside <>" = "<>leftside <>"+("<>longString<>")"];
];
];
];
minLength=70;
puffer=15;
start=minLength;
If[StringLength[longString]>start+puffer,testFin=puffer;,testFin = StringLength[longString] - start];

Counter=start;
newLetters=start;

If[addfirst==True,
If[StringTake[longString,{1,1}]==="-",
newString= leftside <>" = "<>leftside <>StringTake[longString,{1,start}];,
newString= leftside <>" = "<>leftside <>"+"<>StringTake[longString,{1,start}];
];,
newString= leftside <>" = "<>StringTake[longString,{1,start}];
];
openBracket=StringCount[newString,"("];
closeBracket=StringCount[newString,")"];
lines = 1;

For[i=start+1,i<=StringLength[longString],

If[(StringLength[longString]- i)<10,
newString=newString<>StringTake[longString,{i}];
Counter++;
i++;,
diffBracket = openBracket - closeBracket;
If[diffBracket <=  maxDiff,BracketTrue=True;,BracketTrue=False;];
If[(StringTake[longString,{i}]==="+"&&BracketTrue)||(StringTake[longString,{i}]==="-"&&BracketTrue) ||(StringTake[longString,{i}]===","&&BracketTrue),

newString=newString<>StringTake[longString,{i}];
If[StringTake[longString,{i}]==")",closeBracket++];
If[StringTake[longString,{i}]=="(",openBracket++];
If[lines <=20 || diffBracket =!=0,
For[i2=1,i2<=85-newLetters,newString =newString <>" ";i2++;]; 
newString=newString<>"& \n"<>"& ";
lines++;,
lines=1;
sign = StringTake[newString,-1];
newString=StringDrop[newString,-1]<>" \n"<>leftside<>" =  "<> leftside <>sign;
];

If[StringLength[longString]-i<minLength+1,
ende=StringLength[longString];,
ende=i+minLength+1;
];

newString=newString <> StringTake[longString,{i+1,ende}];
Counter=ende;
openBracket=openBracket+StringCount[StringTake[longString,{i+1,ende}],"("];
closeBracket=closeBracket+StringCount[StringTake[longString,{i+1,ende}],")"];
newLetters=ende-i-1;
i=ende+1;,
newString=newString<>StringTake[longString,{i}];
If[StringTake[longString,{i}]==")",closeBracket++];
If[StringTake[longString,{i}]=="(",openBracket++];
newLetters++;
Counter++;
i++;
];
];
];
Return[newString]; 
];


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)

(* SPhenoForm[x_String]:=StringReplace[StringReplace[x," "->""],StringReSPheno]; *)

SPhenoForm[x_re]:= "Real("<>SPhenoForm[x[[1]]]<>",dp)"; 
SPhenoForm[x_im]:= "Aimag("<>SPhenoForm[x[[1]]]<>")"; 
SPhenoForm[x_String]:=SPhenoForm[ToExpression[x]]; 
SPhenoForm[LHInput[x_]]:=SPhenoForm[x]<>"IN";
SPhenoForm[DotP[x_]]:="Dot_Product("<>SPhenoForm[x[[1]]]<>","<>SPhenoForm[x[[2]]]<>")";
SPhenoForm[x_]:= 
If[Head===Times,
Return[ToString[FortranForm[Replace[x,y_Integer->y*1.,1]]]];,
Return[ToString[FortranForm[x]]];
]; 




(* ::Input::Initialization:: *)
MakeSPhenoCoupling[x_,name_,file_]:=Block[{temp,i,iDo2},
temp = Expand[x];

While[FreeQ[temp,sum]==False,
temp = temp /. sum -> sumSPheno;
];

WriteString[file, name <>" = 0._dp \n"];

If[temp=!=0,
If[Head[temp]=!=Plus ,
openDo=0;
ifs=MakeCondition[temp];
WriteString[file,ifs[[1]]];
WriteSPhenoTerm[temp/. {Delta[a__]->1, ThetaStep[a__]->1} ,name,file];
For[iDo2=1,iDo2<=openDo,
WriteString[file,"End Do \n"];
iDo2++;];
WriteString[file,ifs[[2]]];,
For[i=1,i<=Length[temp],
openDo=0;
ifs=MakeCondition[temp[[i]]];
WriteString[file,ifs[[1]]];
WriteSPhenoTerm[temp[[i]] /. {Delta[a__]->1, ThetaStep[a__]->1} ,name,file];
For[iDo2=1,iDo2<=openDo,
WriteString[file,"End Do \n"];
iDo2++;];
WriteString[file,ifs[[2]]];
i++;];
];
];
]; 

MakeCondition[term_]:=Block[{i, deltas, thetas,string,finstring},
deltas=Cases[term,x:(Delta[a_,b_]),10];
thetas=Cases[term,x:(ThetaStep[a_,b_]),10];

If[Length[deltas]+Length[thetas]=!=0,
string="If (";
For[i=1,i<=Length[deltas],
string=string<>"("<>ToString[deltas[[i,1]]]<>".eq."<>ToString[deltas[[i,2]]] <> ").And.";
i++;];

For[i=1,i<=Length[thetas],
string=string<>"("<>ToString[thetas[[i,1]]]<>".le."<>ToString[thetas[[i,2]]] <> ").And.("<>ToString[thetas[[i,1]]]<>".ge.1).And.";
i++;];

string=StringDrop[string,-5] <>") Then \n";
finstring="End If \n";,
string="";
finstring="";
];
Return[{string,finstring}];
];


WriteSPhenoTerm[x_,name_,file_]:=Block[{},
If[Head[x]===sumSPheno,
WriteString[file,"Do " <> ToString[x[[1]]] <> " = " <> ToString[x[[2]]] <>"," <>ToString[x[[3]]] <>"\n"];
openDo++;
WriteSPhenoTerm[x[[4]],name,file];,

If[StringTake[SPhenoForm[x],1]==="-",
WriteString[file, name<> " = "<> name <>SPhenoForm[x] <>"\n"];,
WriteString[file, name<> " = "<> name <>"+" <>SPhenoForm[x] <>"\n"];
];
];
];

CheckFermionFlip[fields_,vert_]:=Block[{i,j,fermionsIn, fermionsRef,res,vector},
res=vert;
If[getVertexType[C@@fields]===FFV,
fermionsIn=Select[fields,getType[RE[#]]==F&];
fermionsRef=Select[vert[[2]],getType[RE[#]]==F&];
vector=RE[Select[vert[[2]],getType[RE[#]]==V&][[1]]];
If[fermionsIn[[1]]===(fermionsRef[[2]]/. A_[{b__}]->A) && fermionsIn[[2]]===(fermionsRef[[1]]/. A_[{b__}]->A) && conj[vector]=!=vector,
res[[1]]=-Reverse[res[[1]]];
];
Return[res];,
Return[res];
];
];

CheckFermionFlipPS[fields_,vert_,ind_]:=Block[{i,j,fermionsIn, fermionsRef,res,vector,indres},
res=vert;
indres=ind;
If[getVertexType[C@@fields]===FFV,
fermionsIn=Select[fields,getType[RE[#]]==F&];
fermionsRef=Select[vert[[2]],getType[RE[#]]==F&];
vector=RE[Select[vert[[2]],getType[RE[#]]==V&][[1]]];
If[fermionsIn[[1]]===(fermionsRef[[2]]/. A_[{b__}]->A) && fermionsIn[[2]]===(fermionsRef[[1]]/. A_[{b__}]->A) && fermionsIn[[1]]=!=fermionsIn[[2]],
res[[1]]=-Reverse[res[[1]]];
(* If[ind[[2]]\[Equal]True,indres[[2]]=False;,indres[[2]]=True;]; *)
];
Return[{res,indres}];,
Return[{res,indres}];
];
];

CheckFermionFlipDecay[fields_,vert_,ind_]:=Block[{i,j,fermionsIn, fermionsRef,res,vector,indres,refind,count},
res=vert;
indres=ind;
refind=ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]];
If[getVertexType[C@@ind[[-1]]]===FFV,
fermionsIn=Select[fields,getType[RE[#]/. A_[b_]->A]==F&];
fermionsRef={};
count=1;
For[i=1,i<=Length[ind[[-1]]],
If[getType[ind[[-1]][[i]]]===F,
If[getGen[ind[[-1]][[i]]]>1,
fermionsRef=Join[fermionsRef,{ind[[-1]][[i]][refind[[count]]]}];
count++;,
fermionsRef=Join[fermionsRef,{ind[[-1]][[i]]}];
];
];
i++;];
vector=RE[Select[vert[[2]],getType[RE[#]]==V&][[1]]];
If[fermionsIn[[1]]===(fermionsRef[[2]]/. A_[{b__}]->A) && fermionsIn[[2]]===(fermionsRef[[1]]/. A_[{b__}]->A) && fermionsIn[[1]]=!=fermionsIn[[2]],
res[[1]]=-Reverse[res[[1]]];
(* If[ind[[2]]\[Equal]True,indres[[2]]=False;,indres[[2]]=True;]; *)
];
Return[{res,indres}];,
Return[{res,indres}];
];
];





WriteVertexToFile[nr_,name_,ind_,type_,file_]:=Block[{},
(* Writes the expression for a given vertex to the Fortran file *)
(* - nr: the number of the vertex appearing in the diagram under consideration; i.e. 1,2 or 3 for penguins *)
(* - name: the SPheno name of the vertex *)
(* - ind: the indices as well as the statement if the vertex or the hermitian conjugated vertex should be used *)
(* - type: generic type of the vertex, e.g. FFS, FFV, VVV,...*)
(* - file: output file name *)

Switch[type,
FFV,
	If[ind[[2]]==False,
	WriteString[file,"coup"<>ToString[nr]<>"L = "<>ToString[name[[1,1]]]<>ind[[1]] <>"\n"];
	WriteString[file,"coup"<>ToString[nr]<>"R = "<>ToString[name[[1,2]]]<>ind[[1]] <>"\n"];
	SA`SubSPhenoTeXVertex={"coup"<>ToString[nr]<>"L"->TeXOutput[name[[1,1]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}],"coup"<>ToString[nr]<>"R"->TeXOutput[name[[1,2]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]};,
	WriteString[file,"coup"<>ToString[nr]<>"L = Conjg("<>ToString[name[[1,1]]]<>ind[[1]] <>")\n"];
	WriteString[file,"coup"<>ToString[nr]<>"R = Conjg("<>ToString[name[[1,2]]]<>ind[[1]] <>")\n"];
	SA`SubSPhenoTeXVertex={"coup"<>ToString[nr]<>"L"->"("<>TeXOutput[name[[1,1]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")^*","coup"<>ToString[nr]<>"R"->"("<>TeXOutput[name[[1,2]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")^*"};
	];,
FFS,
	If[ind[[2]]==False,
	WriteString[file,"coup"<>ToString[nr]<>"L = "<>ToString[name[[1,1]]]<>ind[[1]] <>"\n"];
	WriteString[file,"coup"<>ToString[nr]<>"R = "<>ToString[name[[1,2]]]<>ind[[1]] <>"\n"];
SA`SubSPhenoTeXVertex={"coup"<>ToString[nr]<>"L"->TeXOutput[name[[1,1]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}],"coup"<>ToString[nr]<>"R"->TeXOutput[name[[1,2]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]};,
	WriteString[file,"coup"<>ToString[nr]<>"R = Conjg("<>ToString[name[[1,1]]]<>ind[[1]] <>")\n"];
	WriteString[file,"coup"<>ToString[nr]<>"L = Conjg("<>ToString[name[[1,2]]]<>ind[[1]] <>")\n"];
SA`SubSPhenoTeXVertex={"coup"<>ToString[nr]<>"R"->"("<>TeXOutput[name[[1,1]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]] /.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")^*","coup"<>ToString[nr]<>"L"->"("<>TeXOutput[name[[1,2]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]] /.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")^*"};
	];,
_,
	If[Head[name]===List,
	If[ind[[2]]==False,
	WriteString[file,"coup"<>ToString[nr]<>" = "<>ToString[name[[1,1]]]<>ind[[1]] <>"\n"];
	If[((name[[1,1]]/Abs[name[[1,1]]])/.Abs[x_]->x)===-1,
	SA`SubSPhenoTeXVertex=
{"coup"<>ToString[nr]->"("<>TeXOutput[name[[1,1]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")"};,
	SA`SubSPhenoTeXVertex=
{"coup"<>ToString[nr]->TeXOutput[name[[1,1]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]};
	];,
	WriteString[file,"coup"<>ToString[nr]<>" = Conjg("<>ToString[name[[1,1]]]<>ind[[1]] <>")\n"];
	SA`SubSPhenoTeXVertex={"coup"<>ToString[nr]->"("<>TeXOutput[name[[1,1]]]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")^*"};
	];,
	If[ind[[2]]==False,
	WriteString[file,"coup"<>ToString[nr]<>" = "<>ToString[name]<>ind[[1]] <>"\n"];
	If[((name/Abs[name])/.Abs[x_]->x)===-1,
	SA`SubSPhenoTeXVertex=
{"coup"<>ToString[nr]->"("<>TeXOutput[name]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")"};,
	SA`SubSPhenoTeXVertex=
{"coup"<>ToString[nr]->TeXOutput[name]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]};
	];,
	WriteString[file,"coup"<>ToString[nr]<>" = Conjg("<>ToString[name]<>ind[[1]] <>")\n"];
	SA`SubSPhenoTeXVertex={"coup"<>ToString[nr]->"("<>TeXOutput[name]<>"_"<>TeXOutput[ToExpression[StringReplace[ind[[1]],{"("->"{",")"->"}"}]]/.{i1->j1,i2->j2,i3->j3,i4->j4}]<>")^*"};
	];
];

];

];

(*
WriteVertexToFKout[nr_,name_,indIN_,type_,file_]:=Block[{ind},
(* Writes the expression for a given vertex to the Fortran file *)
(* - nr: the number of the vertex appearing in the diagram under consideration; i.e. 1,2 or 3 for penguins *)
(* - name: the SPheno name of the vertex *)
(* - ind: the indices as well as the statement if the vertex or the hermitian conjugated vertex should be used *)
(* - type: generic type of the vertex, e.g. FFS, FFV, VVV,...*)
(* - file: output file name *)
ind=StringReplace[indIN[[1]],{"("\[Rule]"[",")"\[Rule]"]"}];
Switch[type,
FFV,
	If[indIN[[2]]\[Equal]False,
	WriteString[file,"coup"<>ToString[nr]<>"L -> "<>ToString[name[[1,1]]]<>ind <>","];
	WriteString[file,"coup"<>ToString[nr]<>"R -> "<>ToString[name[[1,2]]]<>ind <>""];,
	WriteString[file,"coup"<>ToString[nr]<>"L -> conj["<>ToString[name[[1,1]]]<>ind <>"],"];
	WriteString[file,"coup"<>ToString[nr]<>"R -> conj["<>ToString[name[[1,2]]]<>ind <>"]"];
	];,
FFS,
	If[indIN[[2]]\[Equal]False,
	WriteString[file,"coup"<>ToString[nr]<>"L -> "<>ToString[name[[1,1]]]<>ind <>","];
	WriteString[file,"coup"<>ToString[nr]<>"R -> "<>ToString[name[[1,2]]]<>ind <>""];,
	WriteString[file,"coup"<>ToString[nr]<>"R -> conj["<>ToString[name[[1,1]]]<>ind<>"],"];
	WriteString[file,"coup"<>ToString[nr]<>"L -> conj["<>ToString[name[[1,2]]]<>ind <>"]"];
	];,
_,
	If[indIN[[2]]\[Equal]False,
	WriteString[file,"coup"<>ToString[nr]<>" -> "<>ToString[name[[1,1]]]<>ind<>""];,
	WriteString[file,"coup"<>ToString[nr]<>" -> conj["<>ToString[name[[1,1]]]<>ind <>"]"];
	];

];

]; *)


WriteVertexToFKout[nr_,name_,indIN_,type_,file_]:=Block[{ind},
(* Writes the expression for a given vertex to the Fortran file *)
(* - nr: the number of the vertex appearing in the diagram under consideration; i.e. 1,2 or 3 for penguins *)
(* - name: the SPheno name of the vertex *)
(* - ind: the indices as well as the statement if the vertex or the hermitian conjugated vertex should be used *)
(* - type: generic type of the vertex, e.g. FFS, FFV, VVV,...*)
(* - file: output file name *)
ind=StringReplace[indIN[[1]],{"("->"[",")"->"]"}];
Switch[type,
FFV,
	If[indIN[[2]]==False,
	WriteString[file,"coup"<>ToString[nr]<>"L -> "<>ToString[(Cp@@name )[L]]<>ind <>","];
	WriteString[file,"coup"<>ToString[nr]<>"R -> "<>ToString[(Cp@@name)[R]]<>ind <>""];,
	WriteString[file,"coup"<>ToString[nr]<>"L -> conj["<>ToString[(Cp@@name)[L]]<>ind <>"],"];
	WriteString[file,"coup"<>ToString[nr]<>"R -> conj["<>ToString[(Cp@@name)[R]]<>ind <>"]"];
	];,
FFS,
	If[indIN[[2]]==False,
	WriteString[file,"coup"<>ToString[nr]<>"L -> "<>ToString[(Cp@@name)[L]]<>ind <>","];
	WriteString[file,"coup"<>ToString[nr]<>"R -> "<>ToString[(Cp@@name)[R]]<>ind <>""];,
	WriteString[file,"coup"<>ToString[nr]<>"R -> conj["<>ToString[(Cp@@name)[L]]<>ind<>"],"];
	WriteString[file,"coup"<>ToString[nr]<>"L -> conj["<>ToString[(Cp@@name)[R]]<>ind <>"]"];
	];,
_,
	If[indIN[[2]]==False,
	WriteString[file,"coup"<>ToString[nr]<>" -> "<>ToString[Cp@@name]<>ind<>""];,
	WriteString[file,"coup"<>ToString[nr]<>" -> conj["<>ToString[Cp@@name]<>ind <>"]"];
	];

];

];



AppendSourceCode[file_,output_]:=Block[{$Path=ToFileName[{$sarahSPhenoPackageDir,"IncludeSPheno"}],t,copy},

(* Function to read Fortran source code from an input file ('file') and to glue it to another file ('output') without any changes *)

copy=OpenRead[file];
t=False;
While[t =!= EndOfFile,
    t = Read[copy, String,NullRecords->True];
If[t=!= EndOfFile,
    WriteString[output, t];
    WriteString[output, "\n"];
];
    ];
Close[copy];
];





(* ::Input::Initialization:: *)
MakeMassesCouplingLists[temp_]:=MakeMassesCouplingLists[temp,True,{}];
MakeMassesCouplingLists[temp_,SM_]:=MakeMassesCouplingLists[temp,SM,{}];

MakeMassesCouplingLists[temp_,SM_,ExceptionSM_]:=Block[{i,j,NeededCouplings,NeededMasses,NeededCouplingsInsert,AllInternalParticles,AllAddedCouplings},
(* Takes a list ('temp') of interactions and returns the a list with all involved couplings and masses *)
(* SM: what should be considered as SM fields and should be skipped *)
(* ExceptionSM: These SM should be included nevertheless even if they are contained in SM *)

(* Result: *)
(* - list: list of vertices (Mathematica format) *)
(* - NeededMasses: all masses needed for the calculation *)
(* - NeededCouplings: all couplings needed for the calculation (SARAH/Mathematica format) *)
(* - NeededCouplingsInsert: all couplings needed for the calculation where the SPheno names have been inserted (SPheno/Fortran format) *)


list={};
AllInternalParticles={};
AllAddedCouplings={};

If[SM==True,
For[j=1,j<=Length[temp],
(* If[Intersection[VerticesInv[VVV],temp[[j,1]]]==={}, *)
list= Join[list,{temp[[j]] /. C[a__]->Cp[a]}];
AllInternalParticles=Join[AllInternalParticles,Cases[temp[[1,2]],Internal[_],3] /. temp[[j,2]]];
AllAddedCouplings = Join[AllAddedCouplings,temp[[j,1]]];
(* ]; *)
j++;];,

For[j=1,j<=Length[temp],
If[Cases[DeleteCases[Cases[temp[[j,2]],Internal[_],3],ExceptionSM] /. temp[[j,2]],x_?((FreeQ[SMParticles,RE[#]]==False && getGen[#]<=3)&),3]==={},
list= Join[list,{temp[[j]] /. C[a__]->Cp[a]}];
AllInternalParticles=Join[AllInternalParticles,Cases[temp[[1,2]],Internal[_],3] /. temp[[j,2]]];
AllAddedCouplings = Join[AllAddedCouplings,temp[[j,1]]];
];
j++;];
];

NeededMasses=DeleteCases[Intersection[SPhenoMass/@AllInternalParticles],0.];
NeededCouplingsInsert=Intersection[AllAddedCouplings];
NeededCouplings={};

For[i=1,i<=Length[NeededCouplingsInsert],
If[FreeQ[SPhenoCouplingsAll,NeededCouplingsInsert[[i]]]==False,
NeededCouplings=Join[NeededCouplings,getSPhenoCoupling[NeededCouplingsInsert[[i]],SPhenoCouplingsAll][[1]]];
];
i++;];

NeededCouplings = Flatten[NeededCouplings];

Return[{list,NeededMasses,NeededCouplings,NeededCouplingsInsert}];

];

WriteCopyRight[file_]:=Block[{Minutes},
WriteString[file,"! -----------------------------------------------------------------------------  \n"];
WriteString[file,"! This file was automatically created by SARAH version "<>SA`Version<>" \n"];
WriteString[file,"! SARAH References: arXiv:0806.0538, 0909.2863, 1002.0840, 1207.0906, 1309.7223  \n"];
WriteString[file,"! (c) Florian Staub, 2013  \n"];
WriteString[file,"! ------------------------------------------------------------------------------  \n"];
Minutes=If[Date[][[5]]<10,"0"<>ToString[Date[][[5]]],ToString[Date[][[5]]]];
WriteString[file,"! File created at "<>ToString[Date[][[4]]]<>":"<>Minutes<>" on "<>ToString[Date[][[3]]]<>"."<>ToString[Date[][[2]]]<>
"."<>ToString[Date[][[1]]]<>"   \n"];
WriteString[file,"! ----------------------------------------------------------------------  \n \n \n"];


];

GetCouplingsMasses[temp_]:=GetCouplingsMasses[temp,False];
GetCouplingsMasses[temp_,quartics_]:=Block[{AllExternalParticles={},AllInternalParticles={},AllAddedCouplings={},i,j,NeededMasses,NeededCouplingsInsert,NeededCouplings},
AllExternalParticles={External[1],External[2],External[3],External[4]}/. temp[[1,2]];
For[j=1,j<=Length[temp],
AllInternalParticles=Join[AllInternalParticles,{Internal[1],Internal[2],Internal[3],Internal[4]}/. temp[[j,2]]];
AllAddedCouplings = Join[AllAddedCouplings,temp[[j,1]]];
 (* ];  *)
j++;];
AllExternalParticles=DeleteCases[AllExternalParticles,External[_]];
AllInternalParticles=DeleteCases[AllInternalParticles,Internal[_]];

NeededMasses=Intersection[SPhenoMass/@Join[AllExternalParticles,AllInternalParticles]];
NeededMasses =DeleteCases[NeededMasses,0.];
NeededMasses =Join[NeededMasses, MakeSquaredMass/@NeededMasses];


NeededCouplingsInsert=Intersection[AllAddedCouplings /. C[a__]->Cp[a]];
NeededCouplings={};
For[i=1,i<=Length[NeededCouplingsInsert],
If[FreeQ[SPhenoCouplingsAllreallyAll,NeededCouplingsInsert[[i]]/. Cp->C]===False,
If[quartics===True,
If[FreeQ[SPhenoCouplingsColoredQuartics,NeededCouplingsInsert[[i]]/. Cp->C]===False,
NeededCouplings=Join[NeededCouplings,getSPhenoCoupling[NeededCouplingsInsert[[i]],SPhenoCouplingsColoredQuartics][[1]]];,
NeededCouplings=Join[NeededCouplings,getSPhenoCoupling[NeededCouplingsInsert[[i]],SPhenoCouplingsAllreallyAll][[1]]];
];,
NeededCouplings=Join[NeededCouplings,getSPhenoCoupling[NeededCouplingsInsert[[i]],SPhenoCouplingsAllreallyAll][[1]]];
];
];
i++;];
NeededCouplings = Flatten[NeededCouplings];
Return[{NeededMasses,NeededCouplings}];
];


