(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SA`Doc`ToDo="This file contrains the routine needed for the HOM4PS2 output. This was written before the Vevacious projekt as started as such. Nowadays, this output is no longer used or needed and one might think about removing it. Before that: make sure that the Vevacious output doesn't use any of the routines defined here! \n
I won't add any comments to the functions below because of obvious reasons! FS, 20/05/2019."

Options[MakeHOM4PS2]={ComplexParameters->{},OffdiagonalParameters->{},IgnoreParameters->{},OutputFile->"tadpoles.in"};

MakeHOM4PS2[potVEVsReal_,potVEVsComplex_,opt___]:=FunctionHOM4PS2[potVEVsReal,potVEVsComplex,ComplexParameters /. {opt} /. Options[MakeHOM4PS2],OffdiagonalParameters/. {opt} /. Options[MakeHOM4PS2],PutParametersToZero/. {opt} /. Options[MakeHOM4PS2],OutputFile /. {opt} /. Options[MakeHOM4PS2]];

FunctionHOM4PS2[potVEVsReal_,potVEVsComplex_,complexPar_,offdiagonalPar_,zerop_,outputfile_]:=Block[{i,temp,res,potv},
Print["Making input files for HOM4PS2"];


SA`RealSubHOM={};
SA`VEVsHOMreal={};
SA`VEVsHOMcomplex={};

(* get potential for VEVs *)
Print["   Generating potential for choosen VEVs"];
potv = ReturnVEVpotential[Pot[GaugeES],LagSV[GaugeES] /. Mom->Der,potVEVsReal,potVEVsComplex];

Print["   Simplify potential for given assumptions about parameters"];
(* Simplify parameters choices and introduces SLHA names *)
subout=GenerateParameterOutputName[potv,complexPar,offdiagonalPar];

(* Put parameters to zero *)
subzerop={};
For[i=1,i<=Length[zerop],
If[getDimParameters[zerop[[i]]]==={} || getDimParameters[zerop[[i]]]==={0}, 
subzerop = Join[subzerop,{zerop[[i]]->0}];,
subzerop = Join[subzerop,{zerop[[i]][a___]->0}];
];
i++;];

(* Expand things like Sqrt[2] to floating-point numbers *)
 potv = N[potv  //. subzerop//. subout //. conj[x_]->x]; 

MWexpression =N[Expand[MWexpression]//. subzerop//. subout //. conj[x_]->x];

SA`PotentialHOM4PS2=potv;
SA`PotentialHOM4PS21Loop=AddCounterTermsToPotential[potv];
SA`TadpoleEquationsHOM={};

Print["   Calculating tadpole equations"];
For[i=1,i<=Length[SA`VEVsHOMreal],
SA`TadpoleEquationsHOM = Join[SA`TadpoleEquationsHOM,{Expand[2 D[potv,SA`VEVsHOMreal[[i]]]]}];
i++;];
For[i=1,i<=Length[SA`VEVsHOMcomplex],
SA`TadpoleEquationsHOM = Join[SA`TadpoleEquationsHOM,{Expand[2 D[potv,SA`VEVsHOMcomplex[[i]]]]}];
i++;];


Print["   Writing tadpole equations to file"];
If[FileExistsQ[$sarahOutputDir]=!=True,CreateDirectory[$sarahOutputDir];];
If[FileExistsQ[$sarahCurrentOutputMainDir]=!=True,CreateDirectory[$sarahCurrentOutputMainDir];];
$sarahCurrentHOM4PS2Dir=ToFileName[{$sarahCurrentOutputMainDir,"HOM4PS2"}];
If[FileExistsQ[$sarahCurrentHOM4PS2Dir]=!=True,CreateDirectory[$sarahCurrentHOM4PS2Dir];];

homout = OpenWrite[ToFileName[$sarahCurrentHOM4PS2Dir,outputfile]];
WriteString[homout,"{ \n"];
For[i=1,i<=Length[SA`TadpoleEquationsHOM],
WriteString[homout,"("<>ToString[InputForm[SA`TadpoleEquationsHOM[[i,1]]]]<>") \n"];
For[j=2,j<=Length[SA`TadpoleEquationsHOM[[i]]],
WriteString[homout,"+("<>ToString[InputForm[SA`TadpoleEquationsHOM[[i,j]]]]<>") \n"];
j++;];
WriteString[homout,"; \n"];
i++;];
WriteString[homout,"- MW2  \n"];
For[j=1,j<=Length[MWexpression],
WriteString[homout,"+ ("<>ToString[InputForm[MWexpression[[j]]]] <>") \n"];
j++;];
WriteString[homout,"; \n"];
WriteString[homout,"} \n"];

Close[homout];

GenerateXLM;

Print["Finished! Output was written to file",$sarahCurrentHOM4PS2Dir];
];

AddCounterTermsToPotential[pot_]:=Block[{i,j,sub={}},
sub=Table[SA`VEVsHOMreal[[i]]->SA`VEVsHOMreal[[i]]+delta[SA`VEVsHOMreal[[i]]],{i,1,Length[SA`VEVsHOMreal]}];
sub=Join[sub,Table[(SA`VEVsHOMreal[[i]] /. A_[b_Integer]->A[c_])->((SA`VEVsHOMreal[[i]]+delta[SA`VEVsHOMreal[[i]]]) /. A_[b_Integer]->A[c]),{i,1,Length[SA`VEVsHOMreal]}]];
sub=Join[sub,Table[SA`VEVsHOMcomplex[[i]]->SA`VEVsHOMcomplex[[i]]+delta[SA`VEVsHOMcomplex[[i]]],{i,1,Length[SA`VEVsHOMcomplex]}]];
sub=Join[sub,Table[(SA`VEVsHOMcomplex[[i]] /. A_[b_Integer]->A[c_])->((SA`VEVsHOMcomplex[[i]]+delta[SA`VEVsHOMcomplex[[i]]]) /. A_[b_Integer]->A[c]),{i,1,Length[SA`VEVsHOMcomplex]}]];
SA`subHMshiftedVEVs=sub;
Return[pot /. sub /. conj[delta[a_]]->delta[a]];
];




(* ::Input::Initialization:: *)
ReturnVEVpotential[pot_,kin_,real_, complex_]:=Block[{res,pars,vev,i, nameR,nameI},
SA`CurrentStates = GaugeES;
pars=Transpose[parameters][[1]];

realVEVs=Intersection[real /. A_[b_Integer]->A];
complexVEVs=Intersection[complex /. A_[b_Integer]->A];


subPoss={};
For[i=1,i<=Length[complexVEVs],
nameR=ToExpression["VR"<>ToString[complexVEVs[[i]]]];
nameI=ToExpression["VI"<>ToString[complexVEVs[[i]]]];
If[getGen[complexVEVs[[i]]]>1,
subPoss=Join[subPoss,{complexVEVs[[i]][{a_}]->1/Sqrt[2](nameR[a]+I nameI[a])}];
SA`RealSubHOM = Join[SA`RealSubHOM,{conj[nameR[a_]]->nameR[a],conj[nameI]->nameI[a]}];,
subPoss=Join[subPoss,{complexVEVs[[i]]->1/Sqrt[2](nameR+I nameI)}];
SA`RealSubHOM = Join[SA`RealSubHOM,{conj[nameR]->nameR,conj[nameI]->nameI}];
];
i++;];

For[i=1,i<=Length[realVEVs],
nameR=ToExpression["VR"<>ToString[realVEVs[[i]]]];
If[getGen[realVEVs[[i]]]>1,
subPoss=Join[subPoss,{realVEVs[[i]][{a_}]->nameR[a]/Sqrt[2]}];
SA`RealSubHOM = Join[SA`RealSubHOM,{conj[nameR[a_]]->nameR[a]}];,
subPoss=Join[subPoss,{realVEVs[[i]]->nameR/Sqrt[2]}];
SA`RealSubHOM = Join[SA`RealSubHOM,{conj[nameR]->nameR}];
];
i++;];


(* remove non-decomposed fields and gauge fixing*)
res = pot  /. subPoss/.vacuumS /.vacuumF /. zero[_]->0 /.RXi[_]->0 ;


(* Simplify Kronecker Delta and expands sums *)
res=makeSumAll[CalcDelta[res]]//.sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}];

(* Need the kinetic terms to extract the W-mass *)
resKin= kin  /. subPoss/.vacuumS /.vacuumF /. zero[_]->0 /.RXi[_]->0 ;
resKin= makeSumAll[CalcDelta[resKin]]//.sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}];
MWexpression=Simplify[D[D[resKin,VWB[{1,lor3}]],VWB[{1,lor4}]]]+Simplify[D[D[resKin,VWB[{2,lor3}]],VWB[{2,lor4}]]] /. g[lor3,lor4]->1;

(* Remove generations without VEVs *)
subVEVzero={};

For[i=1,i<=Length[realVEVs],
nameR = ToExpression["VR"<>ToString[realVEVs[[i]]]];
If[getGen[realVEVs[[i]]]===1,
SA`VEVsHOMreal = Join[SA`VEVsHOMreal, {nameR}];,
For[j=1,j<=getGen[realVEVs[[i]]],
If[FreeQ[real,realVEVs[[i]][j]] && MemberQ[real,realVEVs[[i]]]===False,
subVEVzero = Join[subVEVzero,{nameR[j] -> 0}];,
subVEVzero = Join[subVEVzero,{nameR[j] -> ToExpression[ToString[nameR]<>ToString[j]]}];
SA`VEVsHOMreal = Join[SA`VEVsHOMreal, {ToExpression[ToString[nameR]<>ToString[j]]}];
];
j++;];
];
i++;];

For[i=1,i<=Length[complexVEVs],
nameR = ToExpression["VR"<>ToString[complexVEVs[[i]]]];
nameI = ToExpression["VI"<>ToString[complexVEVs[[i]]]];
If[getGen[complexVEVs[[i]]]===1,
SA`VEVsHOMreal = Join[SA`VEVsHOMreal, {nameR}];
SA`VEVsHOMcomplex = Join[SA`VEVsHOMcomplex, {nameI}];,
For[j=1,j<=getGen[complexVEVs[[i]]],
If[FreeQ[complex,complexVEVs[[i]][j]] && MemberQ[complex,complexVEVs[[i]]]===False,
subVEVzero = Join[subVEVzero,{nameR[j] -> 0,nameI[j]->0}];,
subVEVzero = Join[subVEVzero,{nameR[j] -> ToExpression[ToString[nameR]<>ToString[j]],nameI[j]->ToExpression[ToString[nameI]<>ToString[j]]}];
SA`VEVsHOMreal = Join[SA`VEVsHOMreal, {ToExpression[ToString[nameR]<>ToString[j]]}];
SA`VEVsHOMcomplex = Join[SA`VEVsHOMcomplex, {ToExpression[ToString[nameI]<>ToString[j]]}];
];
j++;];
];
i++;];


res = res //. subVEVzero;


Return[res];

];

GenerateParameterOutputName[pot_,complexPar_,offdiagonalPar_]:=Block[{i},
subparameters={};
For[i=1,i<=Length[parameters],
 If[(FreeQ[pot,parameters[[i,1]]]==False || FreeQ[MassMatrices[Last[NameOfStates]],parameters[[i,1]]]==False) && FreeQ[Particles[ALL],parameters[[i,1]]], 
If[conj[parameters[[i,1]]]===parameters[[i,1]] || MemberQ[complexPar,parameters[[i,1]]]==False,
Switch[Length[parameters[[i,2]]],
0,
	subparameters = Join[subparameters,{parameters[[i,1]]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][ToExpression[LHPos[parameters[[i,1]]]]]}];,
1,
	subparameters = Join[subparameters,{parameters[[i,1]][a_]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]}];,
2,
	If[FreeQ[offdiagonalPar,parameters[[i,1]]]===False,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]->Delta[a] ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]}];,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]}];
	];,
3,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]}];
];,
Switch[Length[parameters[[i,2]]],
0,
	subparameters = Join[subparameters,{parameters[[i,1]]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][ToExpression[LHPos[parameters[[i,1]]]]]+I ToExpression["SLHA::"<>"IM"<>LHBlockName[parameters[[i,1]]]][ToExpression[LHPos[parameters[[i,1]]]]]}];,
1,
	subparameters = Join[subparameters,{parameters[[i,1]][a_]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]+I  ToExpression["SLHA::"<>"IM"<>LHBlockName[parameters[[i,1]]]][a]}];,
2,
	If[FreeQ[offdiagonalPar,parameters[[i,1]]]===False,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> Delta[a](ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]+I ToExpression["SLHA::"<>"IM"<>LHBlockName[parameters[[i,1]]]][a])}];,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]+I ToExpression["SLHA::"<>"IM"<>LHBlockName[parameters[[i,1]]]][a]}];
	];,
3,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression["SLHA::"<>LHBlockName[parameters[[i,1]]]][a]+I ToExpression["SLHA::"<>"IM"<>LHBlockName[parameters[[i,1]]]][a]}];
];
];
];
i++;];

Return[subparameters];
];


GenerateParameterOutputNameALL[prefix_]:=Block[{i},
subparameters={};
For[i=1,i<=Length[parameters],
 If[(FreeQ[pot,parameters[[i,1]]]==False || FreeQ[MassMatrices[Last[NameOfStates]],parameters[[i,1]]]==False ) && FreeQ[Particles[ALL],parameters[[i,1]]], 
If[conj[parameters[[i,1]]]===parameters[[i,1]] || MemberQ[complexPar,parameters[[i,1]]]==False,
Switch[Length[parameters[[i,2]]],
0,
	subparameters = Join[subparameters,{parameters[[i,1]]-> ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][ToExpression[LHPos[parameters[[i,1]]]]]}];,
1,
	subparameters = Join[subparameters,{parameters[[i,1]][a_]-> ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][a]}];,
2,
	If[FreeQ[offdiagonalPar,parameters[[i,1]]],
	subparameters = Join[subparameters,{parameters[[i,1]][a__]->ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][a]}];,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][a]}];
	];,
3,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][a]}];
];,
Switch[Length[parameters[[i,2]]],
0,
	subparameters = Join[subparameters,{parameters[[i,1]]-> ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][ToExpression[LHPos[parameters[[i,1]]]]]+I ToExpression[prefix<>"IM"<>LHBlockName[parameters[[i,1]]]][ToExpression[LHPos[parameters[[i,1]]]]]}];,
1,
	subparameters = Join[subparameters,{parameters[[i,1]][a_]-> ToExpression[LHBlockName[parameters[[i,1]]]][a]+I  ToExpression[prefix<>"IM"<>LHBlockName[parameters[[i,1]]]][a]}];,
2,
	If[FreeQ[offdiagonalPar,parameters[[i,1]]],
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> (ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][a]+I ToExpression[prefix<>"IM"<>LHBlockName[parameters[[i,1]]]][a])}];,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][a]+I ToExpression[prefix<>"IM"<>LHBlockName[parameters[[i,1]]]][a]}];
	];,
3,
	subparameters = Join[subparameters,{parameters[[i,1]][a__]-> ToExpression[prefix<>LHBlockName[parameters[[i,1]]]][a]+I ToExpression[prefix<>"IM"<>LHBlockName[parameters[[i,1]]]][a]}];
];
];
];
i++;];

Return[subparameters];
];

GenerateXLM:=Block[{i,j,k},
Print["Writing input file for Minuit"];

outHM= OpenWrite[ToFileName[$sarahCurrentHOM4PS2Dir,"HoTTMiLC.in"]];
WriteString[outHM,"<HoTTMiLC_stuff> \n"];
WriteEffPotHM;
WriteMassMatricesHM;
WriteString[outHM,"</HoTTMiLC_stuff> \n"];
Close[outHM];
(*
WriteVerticesHM;
WriteOEquationsForDeltaViHM;
WriteExpressionsForOneLoopTadpoles;
*)

];


WriteEffPotHM:=Block[{i,j,k,term},
outHMpot=outHM;
(* outHMpot= OpenWrite[ToFileName[$sarahCurrentHOM4PS2Dir,"Potential_HoTTMiLC.in"]]; *)
Print["    Writing tree level potential"];
WriteString[outHMpot,"<tree-level_potential> \n"];
term=Expand[SA`PotentialHOM4PS2];
For[i=1,i<=Length[term],
WriteString[outHMpot,"("<>ToString[InputForm[term[[i]]]]<>") "];
If[i<Length[term],WriteString[outHMpot," + "];];
i++;];
WriteString[outHMpot,"\n</tree-level_potential>\n\n"];

WriteString[outHMpot,"<input_vev  "];
For[i=1,i<=Length[],

i++;];
WriteString[outHMpot, "\> \n"];

(*
Print["    Writing loop level potential"];
WriteString[outHMpot,"<shifted_tree-level_potential> \n"];
WriteString[outHMpot,ToString[InputForm[Expand[SA`PotentialHOM4PS21Loop]]/.delta[a_]*delta[b_]\[Rule]0/.delta[a_]^2\[Rule]0/.delta[a_]^3\[Rule]0 /. delta[a_]\[RuleDelayed]ToExpression["d"<>ToString[a]]]<>"\n"];
WriteString[outHMpot,"</shifted_tree-level_potential>\n\n"]; *)
(* Close[outHMpot]; *)
];

WriteMassMatricesHM:=Block[{i,j,k,states=Last[NameOfStates],particlename,matrixname1,matrixname2,diracf},
(* outHM= OpenWrite[ToFileName[$sarahCurrentHOM4PS2Dir,"MassMatrices_HoTTMiLC.in"]]; *)
Print["    Writing mass matrices"];
SA`HMparticleList={};
For[i=1,i<=Length[MassMatrices[states]],
diracf=False;
If[Length[DEFINITION[states][MatterSector][[i]][[2,1]]]==2,
particlename = DEFINITION[states][MatterSector][[i]][[2,1,1]]/.diracSubBack[ALL];
matrixname1 = DEFINITION[states][MatterSector][[i]][[2,1,2]]/.diracSubBack[ALL];
matrixname2= DEFINITION[states][MatterSector][[i]][[2,2,2]]/.diracSubBack[ALL];
diracf=True;,
particlename=DEFINITION[states][MatterSector][[i]][[2,1]]/.diracSubBack[ALL];
matrixname1=DEFINITION[states][MatterSector][[i]][[2,2]]/.diracSubBack[ALL];
];
WriteString[outHM,"<mass_squared_matrix \n"];
WriteString[outHM,"particle=\""<>ToString[particlename]<>"\"  "];
If[diracf==False,
WriteString[outHM,"rotationmatrix=\""<>ToString[matrixname1]<>"\"  "];,
WriteString[outHM,"rotationmatrix1=\""<>ToString[matrixname1]<>"\"  "];
WriteString[outHM,"rotationmatrix2=\""<>ToString[matrixname2]<>"\"  "];
];
WriteString[outHM,"factor=\""<>ToString[getFactorHM[DEFINITION[states][MatterSector][[i]]]]<>"\" >     \n"];
WriteMassMatrixHM[MassMatricesFull[states][[i]]];
WriteString[outHM,"</mass_squared_matrix> \n \n"];
SA`HMparticleList=Join[SA`HMparticleList,{particlename}];
i++;];

For[i=1,i<=Length[MassMatricesGauge[states]],
If[getType[DEFINITION[states][GaugeSector][[i,1,1]]]===V,
particlename=DEFINITION[states][GaugeSector][[i,2]];
matrixname1=DEFINITION[states][GaugeSector][[i,3]];
WriteString[outHM,"<mass_squared_matrix \n"];
WriteString[outHM,"particle=\""<>StringReplace[ToString[Intersection[particlename/.conj[x_]->x]],{"{"->"","}"->""}]<>"\"  "];
WriteString[outHM,"rotationmatrix=\""<>ToString[matrixname1]<>"\"  "];
If[conj[particlename[[1]]]===particlename[[1]],
WriteString[outHM,"factor=\"(1/2)\" >\n"];,
WriteString[outHM,"factor=\"1\" >\n"];
];
WriteMassMatrixHM[MassMatricesGauge[states][[i]]];
WriteString[outHM,"</mass_squared_matrix> \n \n"];
];
SA`HMparticleList=Join[SA`HMparticleList,{particlename}];
i++;];
SA`HMparticleList=Select[Intersection[Flatten[SA`HMparticleList] /. conj[x_]->x],FreeQ[Massless[Last[NameOfStates]],#]&];
(* Close[outHM]; *)
];

getSubtractionConstantHM:=5/6;

WriteMassMatrixHM[matrix_]:=Block[{i,j,res,temp},
temp=N[Expand[matrix //. sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}] //.subVEVnames //.subout//. Delta[__]->1 //. subout /. conj[x_]->x]];

For[i=1,i<=Length[temp[[1]]],
For[j=1,j<=Length[temp[[1]]],
If[i=!=j || j<Length[temp[[1]]],
WriteString[outHM,"("<>StringReplace[ToString[InputForm[temp[[i,j]]]],{" "->""}]<>"), \n"];,WriteString[outHM,"("<>StringReplace[ToString[InputForm[temp[[i,j]]]],{" "->""}]<>") \n"];
];
j++;];
i++;];

];

getFactorHM[def_]:=Block[{temp,res,particle,i,j},
If[Length[def[[2,1]]]==2,
particle=def[[2,1,1]]/.diracSubBack[ALL];,
particle=def[[2,1]]/.diracSubBack[ALL];
];
res=1;
For[i=1,i<=Length[Gauge],
If[FreeQ[BrokenSymmetries,i] && getType[particle]=!=V,
res=SA`DimensionGG[particle,i]*res ;
];
i++;];

res = res //. SA`DimensionGG->ONE /. ONE[a_,b_]->1;

If[AntiField[particle]=!=particle,res=2*res;];

HM`MultiplicityCoefficient[particle]=res;

Switch[getType[particle],
F,res= -1/2*res;,
S,res= 1/4*res;,
V,es= 3/4*res;
];

Return[res];

];


EigenvaluesTreeMassMatrices[inputValues_]:=Block[{i,j,k,def,matricesMatter,matricesGauge,matTemp,eigenvalues,particle},res={};
subSLHA=GenerateParameterOutputNameALL[""];
SA`CurrentStates=Last[NameOfStates];
If[SA`MassCalculationInitialized=!=True,ListSimplifiedMassMatrices={};
defMatter=DEFINITION[Last[NameOfStates]][MatterSector];
defGauge=DEFINITION[Last[NameOfStates]][GaugeSector];
matricesMatter=MassMatricesFull[Last[NameOfStates]];
matricesGauge=MassMatricesGauge[Last[NameOfStates]];
For[i=1,i<=Length[matricesMatter],If[Length[defMatter[[i,2,1]]]==2,particle=defMatter[[i,2,1,1]]/.diracSubBack[ALL];,particle=defMatter[[i,2,1]]/.diracSubBack[ALL];];
matTemp=matricesMatter[[i]]//.sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}]//.ThetaW->ArcCos[g2/Sqrt[g1^2+g2^2]]//.subSLHA//.Delta[a__]->1//.RXi[__]->1;
ListSimplifiedMassMatrices=Join[ListSimplifiedMassMatrices,{{particle,matTemp}}];
matTemp=matTemp//.inputValues;
If[NumericQ[Plus@@Flatten[matTemp]]==False,Print["Matrix for ",particle," is not a numerical function: "];
Print[matTemp];
Interrupt[];];
eigenvalues=Reverse[Eigenvalues[matTemp]];
If[getType[particle]===F,res=Join[res,Table[ToString[particle]<>"_"<>ToString[j]->N[eigenvalues[[j]]]^2,{j,1,Length[eigenvalues]}]];,res=Join[res,Table[ToString[particle]<>"_"<>ToString[j]->N[eigenvalues[[j]]],{j,1,Length[eigenvalues]}]];];
i++;];
For[i=1,i<=Length[matricesGauge],particle=Intersection[defGauge[[i,2]]/.conj[x_]->x];
If[getType[particle[[1]]]===V,matTemp=matricesGauge[[i]]//.sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}]//.subSLHA//.Delta[a__]->1;
ListSimplifiedMassMatrices=Join[ListSimplifiedMassMatrices,{{particle,matTemp}}];
matTemp=matTemp//.inputValues;
eigenvalues=Eigenvalues[matTemp];
If[NumericQ[Plus@@Flatten[matTemp]]==False,Print["Matrix for ",particle," is not a numerical function: "];
Print[matTemp];
Interrupt[];];
eigenvalues=Reverse[Eigenvalues[matTemp]];
res=Join[res,Table[ToString[particle[[j]]]->N[eigenvalues[[j]]],{j,1,Length[particle]}]];];
i++;];
SA`MassCalculationInitialized=True;,ListWithMatricesAndMasses={};
For[i=1,i<=Length[ListSimplifiedMassMatrices],matTemp=ListSimplifiedMassMatrices[[i,2]]/.inputValues;
If[NumericQ[Plus@@Flatten[matTemp]]==False,Print["Matrix for ",particle," is not a numerical function: "];
Print[matTemp];
Interrupt[];];
eigenvalues=Reverse[Eigenvalues[matTemp]];
particle=ListSimplifiedMassMatrices[[i,1]];
If[getType[particle]===F&&particle=!=AntiField[particle],eigensystem=SingularValueDecomposition[matTemp];,eigensystem=Eigensystem[matTemp];];
ListWithMatricesAndMasses=Join[ListWithMatricesAndMasses,{{particle,eigensystem}}];
If[Head[particle]===List,res=Join[res,Table[ToString[particle[[j]]]->N[eigenvalues[[j]]],{j,1,Length[particle]}]];,If[getType[particle]===F,res=Join[res,Table[ToString[particle]<>"_"<>ToString[j]->N[eigenvalues[[j]]]^2,{j,1,Length[eigenvalues]}]];,res=Join[res,Table[ToString[particle]<>"_"<>ToString[j]->N[eigenvalues[[j]]],{j,1,Length[eigenvalues]}]];];];
i++;];];
Return[res];];


(* ::Input::Initialization:: *)

Options[MakeHoTTMiLC]={ComplexParameters->{},OffdiagonalParameters->{},IgnoreParameters->{},ReadLists->False,CreateFortranCode->False};

MakeHoTTMiLC[opt___]:=FunctionHoTTMilC[ComplexParameters /. {opt} /. Options[MakeHoTTMiLC],OffdiagonalParameters/. {opt} /. Options[MakeHoTTMiLC],PutParametersToZero/. {opt} /. Options[MakeHoTTMiLC],ReadLists/. {opt} /. Options[ReadLists],CreateFortranCode/. {opt} /. Options[ReadLists]];

FunctionHoTTMilC[complexPar_,offdiagonalPar_,zerop_,readlists_,fortran_]:=Block[{i,temp,res,potv,pos,realYesNo},

Print["---------------------------------------"];
Print["Making input files for HoTTMilC"];
Print["---------------------------------------"];

defVEVs=DEFINITION[Last[NameOfStates]][VEVs];

subVEVnames={};
particlesComplexVEVs={};particlesRealVEVs={};

SA`HMassociatedVEVs={};

For[i=1,i<=Length[defVEVs],
pos=Position[Transpose[ParameterDefinitions][[1]],defVEVs[[i,2,1]]];
If[pos=!={},
realYesNo=Real/.ParameterDefinitions[[pos[[1,1]]]][[2]] /. Real->True;,
realYesNo = True;
];

nameR = ToExpression["VR"<>ToString[defVEVs[[i,1]]]];
nameI = ToExpression["VI"<>ToString[defVEVs[[i,1]]]];

If[realYesNo===True,
particlesRealVEVs=Join[particlesRealVEVs,{defVEVs[[i,1]]}];
SA`HMassociatedVEVs=Join[SA`HMassociatedVEVs,{{defVEVs[[i,4,1]],nameR}}];
If[getDimParameters[defVEVs[[i,2,1]]]=== {1} || getDimParameters[defVEVs[[i,2,1]]]=== {} ,
subVEVnames = Join[subVEVnames ,{defVEVs[[i,2,1]]->nameR}];,
subVEVnames=Join[subVEVnames ,{defVEVs[[i,2,1]][a_]->nameR[a]}];
];,
particlesComplexVEVs=Join[particlesComplexVEVs,{defVEVs[[i,1]]}];
SA`HMassociatedVEVs=Join[SA`HMassociatedVEVs,{{defVEVs[[i,4,1]],nameR},{defVEVs[[i,3,1]],nameI}}];
If[getDimParameters[defVEVs[[i,2,1]]]==={1} || getDimParameters[defVEVs[[i,2,1]]]=== {} ,
subVEVnames =Join[subVEVnames ,{defVEVs[[i,2,1]]->nameR+I nameI}];,
subVEVnames=Join[subVEVnames ,{defVEVs[[i,2,1]][a_]->nameR[a]+I nameI[a]}];
];
];
i++;];

FunctionHOM4PS2[particlesRealVEVs,particlesComplexVEVs,complexPar,offdiagonalPar,zerop,"Tadpoles.in"];

If[fortran===True,
SPhenoOnlyForHM=True;
ModelNameSave=ModelName;
ModelnameSave=Modelname;
ModelName = ModelName <>"HM";
Modelname = Modelname <>"HM";
TadpoleEquationsSave=TadpoleEquations[Last[NameOfStates]];
TadpoleEquationsNew=Expand[TadpoleEquationsSave /.subVEVnames //. SA`RealSubHOM /. SA`subHMshiftedVEVs  /. conj[delta[a_]]->delta[a]] /. delta[a_] delta[b_]->0 /. delta[a_]^2->0 /. delta[a_]^3->0 /. delta[a_]:>ToExpression["d"<>ToString[a]];
TadpoleEquations[Last[NameOfStates]] = TadpoleEquationsNew /. delta[a_]:>ToExpression["d"<>ToString[a]];

TadpoleEquationsSaveWF=SA`TadpoleEquationsWithField[Last[NameOfStates]];
TadpoleEquationsNewWF=Expand[TadpoleEquationsSaveWF /.subVEVnames //. SA`RealSubHOM /. SA`subHMshiftedVEVs  /. conj[delta[a_]]->delta[a]] /. delta[a_] delta[b_]->0 /. delta[a_]^2->0 /. delta[a_]^3->0 /. delta[a_]:>ToExpression["d"<>ToString[a]];
TadpoleEquationsNewWF=Table[{TadpoleEquationsNewWF[[i,1]],0},{i,1,Length[TadpoleEquationsNewWF]}];
TadpoleEquationsNew=Table[0,{Length[TadpoleEquationsNewWF]}];
SA`TadpoleEquationsWithField[Last[NameOfStates]] = TadpoleEquationsNewWF /. delta[a_]:>ToExpression["d"<>ToString[a]];


deltas=Cases[ SA`subHMshiftedVEVs,x_delta,99] /. delta[a_]:>ToExpression["d"<>ToString[a]];
deltas={NOSOLUTION};
ParametersToSolveTadpolesLowScaleInputHM = deltas;
ParametersToSolveTadpolesHM = deltas;
SA`SimplifyTadpoleSolutions = False;

MakeSPheno[ReadLists->readlists];


ModelName = ModelNameSave;
Modelname = ModelnameSave;
];
];


WriteVerticesHM:=Block[{i,j,k,neededscalars,gaugees,pos,defMatter,gen1,gen2,basisscalars={},vertTemp},
outHMvert= OpenWrite[ToFileName[$sarahCurrentHOM4PS2Dir,"Vertices_HoTTMiLC.in"]];
Print["    Calculating vertices"];
subSLHA=GenerateParameterOutputNameALL["SLHA::"];
SA`CurrentStates = Last[NameOfStates];
VerticesForHM={};
defVEVs=DEFINITION[Last[NameOfStates]][VEVs];
defMatter=DEFINITION[Last[NameOfStates]][MatterSector];
gaugees=Join[Transpose[Transpose[defVEVs][[3]]][[1]],Transpose[Transpose[defVEVs][[4]]][[1]]];
pos=Intersection[Table[Position[defMatter,gaugees[[i]]][[1,1]],{i,1,Length[gaugees]}]];
neededscalars=Table[defMatter[[pos[[i]]]][[2,1]],{i,1,Length[pos]}];

For[i=1,i<=Length[neededscalars],
pos=Position[defMatter,neededscalars[[i]]][[1,1]];
basisscalars=Join[basisscalars,{defMatter[[pos]][[1]]}];
i++;];
SA`HMneededscalars=basisscalars;
vertTemp={};
For[i=1,i<=Length[neededscalars],
For[j=1,j<=Length[SA`HMparticleList],
vertTemp=Join[vertTemp,{{{neededscalars[[i]],SA`HMparticleList[[j]],basisscalars[[i]]},Vertex[{AntiField[SA`HMparticleList[[j]]],SA`HMparticleList[[j]],neededscalars[[i]]}]}}];
j++;];
i++;];
vertTemp = vertTemp //. sum[a_,b_,c_,d_]:>Sum[d,{a,b,c}]  /. subVEVnames /.subSLHA  /. conj[x_]->x;
vertTempsave=vertTemp;
For[i=1,i<=Length[vertTemp],
For[gen1=1,gen1<=getGen[vertTemp[[i,1,1]]],
For[gen2=1,gen2<=getGen[vertTemp[[i,1,2]]],
If[getType[vertTemp[[i,1,2]]]===F,
VerticesForHM = Join[VerticesForHM,{{vertTemp[[i,1,3]][[gen1]],vertTemp[[i,1,2]][gen2],(vertTemp[[i,2,2,1]]/I+vertTemp[[i,2,3,1]]/I) //. gt1->gen2 //. gt2->gen2 //. getMixingMatrix[vertTemp[[i,1,1]]][gt3,a_]->Delta[gen1,a]}}];,
VerticesForHM = Join[VerticesForHM,{{vertTemp[[i,1,3]][[gen1]],vertTemp[[i,1,2]][gen2],(vertTemp[[i,2,2,1]]/I) //. gt1->gen2 //. gt2->gen2 //. getMixingMatrix[vertTemp[[i,1,1]]][gt3,a_]->Delta[gen1,a]}}];
];
gen2++;];
gen1++;];
i++;];

For[i=1,i<=Length[VerticesForHM],
WriteString[outHMvert,"<vertex \n"];
WriteString[outHMvert,"particle1=\""<>ToString[VerticesForHM[[i,1]]]<>"\" particle2=\""<>ToString[VerticesForHM[[i,2]]]<>"\" "];
WriteString[outHMvert,"name=\"V"<>StringReplace[ToString[VerticesForHM[[i,1]]]<>ToString[VerticesForHM[[i,2]]],{"["->"","]"->""}]<>"\" > \n"];
WriteString[outHMvert,ToString[InputForm[N[VerticesForHM[[i,3]]]]]<>"\n"];
WriteString[outHMvert,"</vertex >\n \n"];
i++;];
Close[outHMvert];
];

WriteOEquationsForDeltaViHM:=Block[{tempEqu,deltas},
tempEqu=Expand[SA`TadpoleEquationsHOM /. SA`subHMshiftedVEVs] /. delta[a_] delta[b_]->0 /. delta[a_]^2->0 /. delta[b_]^3->0;
deltas=Cases[ SA`subHMshiftedVEVs,x_delta,99];
SA`TadpoleEquationsHOM1L={};
For[i=1,i<=Length[tempEqu],
If[i<=Length[SA`VEVsHOMreal],
SA`TadpoleEquationsHOM1L = Join[SA`TadpoleEquationsHOM1L,{tempEqu[[i]] + 1/16/Pi^2dt[SA`VEVsHOMreal[[i]]]/SA`VEVsHOMreal[[i]]==0}];,
SA`TadpoleEquationsHOM1L =  Join[SA`TadpoleEquationsHOM1L,{tempEqu[[i]] +  1/16/Pi^2 dt[SA`VEVsHOMcomplex[[i-Length[SA`VEVsHOMreal]]]]/SA`VEVsHOMcomplex[[i-Length[SA`VEVsHOMreal]]]==0}];
];
i++;];

sol=Solve[SA`TadpoleEquationsHOM1L,deltas][[1]];
outHMdv= OpenWrite[ToFileName[$sarahCurrentHOM4PS2Dir,"Equations_for_dVi_HoTTMiLC.in"]];
For[i=1,i<=Length[sol],
WriteString[outHMdv,"<expression_deltaVi \n"];
WriteString[outHMdv,"name=\"d"<>ToString[sol[[i,1]]/.delta[x_]->x]<>"\"  >\n"];
WriteString[outHMdv,ToString[InputForm[sol[[i,2]]]/. dt[a_]:>ToExpression["dt"<>ToString[a]]]<>"\n"];
WriteString[outHMdv,"</expression_deltaVi >\n \n"];
i++;];
Close[outHMdv];
];

WriteExpressionsForOneLoopTadpoles:=Block[{i,j,k,gen1,gen2,part1,part2,temp},
Print["     Writing expressions for one-loop corrections to tadpoles"];
listlooptadpoles={};
For[i=1,i<=Length[SA`HMneededscalars],
For[j=1,j<=Length[SA`HMneededscalars[[i]]],
part1=SA`HMneededscalars[[i,j]];
If[FreeQ[SA`HMassociatedVEVs,part1]==False,
For[gen1=1,gen1<=getGenALL[part1],
temp=0;
If[getGenALL[part1]>1,part1name=part1[gen1];,part1name=part1;];
For[k=1,k<=Length[SA`HMparticleList],
part2=SA`HMparticleList[[k]];
For[gen2=1,gen2<=getGen[part2],
Switch[getType[part2],
F,
	coeff=HM`MultiplicityCoefficient[part2];
	temp+=coeff*Mass[part2[gen2]]*A0[MassSquared[part2[gen2]]]*HM`Vertex[part1name,part2[gen2]],
S,
	coeff=HM`MultiplicityCoefficient[part2];
	temp+=coeff*A0[MassSquared[part2[gen2]]]*HM`Vertex[part1name,part2[gen2]];,
V,
	If[conj[part2]===conj[part2],coeff=1;,coeff=2];
	temp+=coeff*A0[MassSquared[part2[gen2]]]*HM`Vertex[part1name,part2[gen2]];,
G,
	temp+=coeff*A0[MassSquared[part2[gen2]]]*HM`Vertex[part1name,part2[gen2]];
];
gen2++;];
k++;];
temp = temp //. HM`Vertex[a_,b_]:>ToExpression[StringReplace["V"<>ToString[a]<>ToString[b],{"["->"","]"->""}]] //. MassSquared[a_]:>ToExpression[StringReplace["M2"<>ToString[a],{"["->"","]"->""}]] //. Mass[a_]:>ToExpression[StringReplace["M"<>ToString[a],{"["->"","]"->""}]];
If[getGenALL[part1]>1,
listlooptadpoles=Join[listlooptadpoles,{{part1[gen1],temp}}];,
listlooptadpoles=Join[listlooptadpoles,{{part1,temp}}];
];
gen1++; ];
];
j++;];
i++;];

outHMdt= OpenWrite[ToFileName[$sarahCurrentHOM4PS2Dir,"Equations_for_dTi_HoTTMiLC.in"]];
For[i=1,i<=Length[listlooptadpoles],
WriteString[outHMdt,"<one_loop_tadpole \n"];
pos=Position[SA`HMassociatedVEVs,listlooptadpoles[[i,1]]][[1,1]];
WriteString[outHMdt,"name=\"dt"<>ToString[SA`HMassociatedVEVs[[pos,2]]]<>"\" >\n"];
WriteString[outHMdt,ToString[InputForm[listlooptadpoles[[i,2]]]]<>"\n"];
WriteString[outHMdt,"</one_loop_tadpole >\n\n"];
i++;];
Close[outHMdt];
];







