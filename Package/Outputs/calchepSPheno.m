(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SA`Doc`ToDo="The purpose of these routines is to be able to run SPheno from the interactive session of CalcHep. I have written this after some discussion with S. Belyaev, but I think the routines were never used or double checked. I'm also not sure if they are still compatible with a recent CalcHep version. Since this option was never used, it might also not missed if removed! Thus, in order to clean up the package, one could remove that file. Because of that, I also won't make any comments to the individual routines. \n
FS, 20/05/2019. ";

GetSPhenoParameters[input_]:=Block[{OnlyOne,listIn,SPhenoFile,i},
SPhenoFile=ToFileName[{$sarahCurrentModelDir},input];
Off[FileByteCount::nffil];

If[FileByteCount[SPhenoFile]===$Failed,
Print["File for SPheno-Output does not exist!"];
AbortStartSPheno=True;,
Get[SPhenoFile];
];

If[Head[MINPAR[[1,1]]]=!=List,OnlyOne=True;,OnlyOne=False;];

If[OnlyOne==True,
MinparCalcHep=MINPAR;,
MinparCalcHep=MINPAR[[1]];
];

ExtparCalcHep={};
If[Head[EXTPAR]===List,
If[Select[Transpose[EXTPAR][[2]],(FreeQ[BoundarySUSYScale,#]==False || FreeQ[BoundaryEWSBScale,#]==False || FreeQ[BoundaryHighScale,#]==False)&]=!={} || l==2,
ExtparCalcHep=EXTPAR;
];
];

listIn = Intersection[Select[Flatten[{BoundaryHighScale,BoundarySUSYScale,BoundaryEWSBScale,BoundaryConditionsUp,BoundaryConditionsDown}],(Head[#]==LHInput)&,99] /. LHInput[x_]->x];

listInCalcHep=listIn;


];


WriteCwrapper :=Block[{i,j,k,l,i1,i2,i3},

Print["Write library to run SPheno with CalcHep \n"];

SPhenoCH = OpenWrite[ToFileName[$sarahCurrentCalcHepDir,"SPhenoViaCalcHep.c"]];

WriteString[SPhenoCH,"#include<stdlib.h> \n"];
WriteString[SPhenoCH,"#include<stdio.h> \n \n"];

WriteString[SPhenoCH,"#define TO_INT(f) (int)(f+0.5) \n"];

WriteString[SPhenoCH,"double MINPARin["<>ToString[Length[MinparCalcHep]]<>"][2]; \n"];
If[ExtparCalcHep=!={},
WriteString[SPhenoCH,"double EXTPARin["<>ToString[Length[ExtparCalcHep]]<>"][2]; \n"];
];
For[i=1,i<=Length[listInCalcHep],
Switch[Length[getDimParameters[listInCalcHep[[i]]]],
1,
	WriteString[SPhenoCH,"double "<>CHForm[listInCalcHep[[i]]]<>"["<>ToString[getDimParameters[listInCalcHep[[i]]][[1]]]<>"]; \n"];,
2,
	WriteString[SPhenoCH,"double "<>CHForm[listInCalcHep[[i]]]<>"["<>ToString[getDimParameters[listInCalcHep[[i]]][[1]]]<>"]["<>ToString[getDimParameters[listInCalcHep[[i]]][[2]]]<>"]; \n"];,
3,
	WriteString[SPhenoCH,"double "<>CHForm[listInCalcHep[[i]]]<>"["<>ToString[getDimParameters[listInCalcHep[[i]]][[1]]]<>"]["<>ToString[getDimParameters[listInCalcHep[[i]]][[2]]]<>"]["<>ToString[getDimParameters[listInCalcHep[[i]]][[3]]]<>"]; \n"];
];
i++;];

WriteString[SPhenoCH,"\n\n \n"];



WriteString[SPhenoCH,"\n\n \n"];

WriteString[SPhenoCH, "double set_MINPAR(double i1, double value) \n"];
WriteString[SPhenoCH,"{   MINPARin[TO_INT(i1)][1]=value;    \n"];
WriteString[SPhenoCH," return 0.;} \n\n \n"];


If[ExtparCalcHep=!={},
WriteString[SPhenoCH, "double set_EXTPAR(double i1, double value) \n"];
WriteString[SPhenoCH,"{   EXTPARin[TO_INT(i1)][1]=value;    \n"];
WriteString[SPhenoCH," return 0.;} \n\n \n"];
];


For[i=1,i<=Length[listInCalcHep],
Switch[Length[getDimParameters[listInCalcHep[[i]]]],
1,
	WriteString[SPhenoCH,"double set_"<>CHForm[listInCalcHep[[i]]]<>"(double i1, double value)  \n"];
	WriteString[SPhenoCH,"{   "<>CHForm[listInCalcHep[[i]]]<>"[TO_INT(i1-1)]=value;    \n"];,
2,
	WriteString[SPhenoCH,"double set_"<>CHForm[listInCalcHep[[i]]]<>"(double i1, double i2, double value)  \n"];
	WriteString[SPhenoCH,"{   "<>CHForm[listInCalcHep[[i]]]<>"[TO_INT(i1-1)][TO_INT(i2-1)]=value;    \n"];,
3,
	WriteString[SPhenoCH,"double set_"<>CHForm[listInCalcHep[[i]]]<>"(double i1, double i2, double i3, double value)  \n"];
	WriteString[SPhenoCH,"{   "<>CHForm[listInCalcHep[[i]]]<>"[TO_INT(i1-1)][TO_INT(i2-1)][TO_INT(i3-1)]=value;    \n"];
];
WriteString[SPhenoCH," return 0.;} \n\n  \n"];
i++;];

WriteSPhenoInputCH;


Close[SPhenoCH];

];


WriteSPhenoInputCH:=Block[{i,j,k},
WriteString[SPhenoCH,"double RunSPheno(double alphaS) \n"];
WriteString[SPhenoCH, "{ \n"];
WriteString[SPhenoCH, "int i,j,k; \n"];

For[i=1,i<=Length[MinparCalcHep],
WriteString[SPhenoCH,"MINPARin["<>ToString[i-1]<>"][0] = "<>ToString[MinparCalcHep[[i,1]]]<>";    \n"];
i++;];
For[i=1,i<=Length[ExtparCalcHep],
WriteString[SPhenoCH,"EXTPARin["<>ToString[i-1]<>"][0] = "<>ToString[ExtparCalcHep[[i,1]]]<>";    \n"];
i++;];



WriteString[SPhenoCH, "FILE* fs=fopen(\"LesHouches.in."<>ModelName<>"\",\"w\"); \n"];

WriteString[SPhenoCH,"\n\n // MODSEL \n"];
WriteString[SPhenoCH, "fprintf(fs,\"Block MODSEL     # Select model\\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"1 \\t 1 \\t # GUT/Low Scale input \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"2 \\t 1 \\t # Boundary condition \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"6 \\t 1 \\t # Generation mixing \\n\"); \n"];

WriteString[SPhenoCH,"\n\n // SMINPUTS \n"];
WriteString[SPhenoCH,"fprintf(fs,\"Block SMINPUTS \\t # Standard Model inputs \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"2 \\t 1.166390E-05 \\t # G_F,Fermi constant \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"3 \\t %e \\t # alpha_s(MZ) SM MSbar \\n\",alphaS); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"4 \\t 9.118760E+01 \\t # Z-boson pole mass \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"5 \\t 4.214000E+00 \\t # m_b(mb) SM MSbar  \\n\"); \n"];
(* WriteString[SPhenoCH,"fprintf(fs,\"5 \\t %e \\t # m_b(mb) SM MSbar \\n\",mb); \n"]; *)
WriteString[SPhenoCH,"fprintf(fs,\"6 \\t 1.729000E+02 \\t # m_top(pole) \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"7 \\t 1.777000E+00 \\t #m_tau(pole) \\n\"); \n"];
(* WriteString[SPhenoCH,"fprintf(fs,\"7 \\t %e \\t # m_tau(pole) \\n\",mtop); \n"]; *)

WriteString[SPhenoCH,"\n\n // MINPAR \n"];
WriteString[SPhenoCH,"fprintf(fs,\"Block MINPAR \\t # Input parameters \\n\"); \n"];
WriteString[SPhenoCH,"for (i=0; i<"<>ToString[Length[MinparCalcHep]]<>"; ++i) \n"];
WriteString[SPhenoCH,"fprintf(fs,\"\\t%d  %e # \\n\",TO_INT(MINPARin[i][0]),MINPARin[i][1]); \n"];

If[ExtparCalcHep=!={},
WriteString[SPhenoCH,"\n\n // EXTPAR \n"];
WriteString[SPhenoCH,"fprintf(fs,\"Block EXTPAR \\t # Input parameters \\n\"); \n"];
WriteString[SPhenoCH,"for (i=0; i<"<>ToString[Length[ExtparCalcHep]]<>"; ++i) \n"];
WriteString[SPhenoCH,"fprintf(fs,\"\\t%d  %e # \\n\",TO_INT(EXTPARin[i][0]),EXTPARin[i][1]); \n"];
];

For[i=1,i<=Length[listInCalcHep],
WriteString[SPhenoCH,"\n\n // "<>CHForm[listInCalcHep[[i]]]<>" \n"];
WriteString[SPhenoCH, "fprintf(fs,\"Block "<>CHForm[listInCalcHep[[i]]]<>"IN     # \\n\"); \n"];
Switch[Length[getDimParameters[listInCalcHep[[i]]]],
1,
	WriteString[SPhenoCH,"for (i=0; i<"<>ToString[getDimParameters[listInCalcHep[[i]]][[1]]]<>"; ++i) \n"];
	WriteString[SPhenoCH,"fprintf(fs,\"\\t%d  %e # \\n\",i+1,"<>CHForm[listInCalcHep[[i]]]<>"[i]); \n"];,
2,
	WriteString[SPhenoCH,"for (i=0; i<"<>ToString[getDimParameters[listInCalcHep[[i]]][[1]]]<>"; ++i) \n"];
	WriteString[SPhenoCH,"   for (k=0; k<"<>ToString[getDimParameters[listInCalcHep[[i]]][[2]]]<>"; ++k) \n"];
	WriteString[SPhenoCH,"fprintf(fs,\"\\t%d %d  %e # \\n\",i+1, k+1,"<>CHForm[listInCalcHep[[i]]]<>"[i][k]); \n"];,
3,
	WriteString[SPhenoCH,"for (i=0; i<"<>ToString[getDimParameters[listInCalcHep[[i]]][[1]]]<>"; ++i) \n"];
	WriteString[SPhenoCH,"   for (k=0; k<"<>ToString[getDimParameters[listInCalcHep[[i]]][[2]]]<>"; ++k) \n"];
	WriteString[SPhenoCH,"       for (l=0; l<"<>ToString[getDimParameters[listInCalcHep[[i]]][[3]]]<>"; ++l) \n"];
	WriteString[SPhenoCH,"fprintf(fs,\"\\t%d %d %d %e # \\n\",i+1, k+1, l+1"<>CHForm[listInCalcHep[[i]]]<>"[i][k][l]); \n"];
];
i++;];
WriteString[SPhenoCH,"\n\n // SPheno specific input \n"];
WriteString[SPhenoCH,"fprintf(fs,\"Block SPhenoInput \\t  # SPheno specific input \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"1 \\t -1 \\t  # error level \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"2 \\t  1 \\t  # SPA conventions \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"7 \\t 0 \\t  # Skip 2-loop Higgs corrections \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"11 \\t 0 \\t  # calculate branching ratios \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"13 \\t 0 \\t  # include 3-Body decays \\n\"); \n"];
WriteString[SPhenoCH,"fprintf(fs,\"12 \\t 1.000E-04 \\t  # write only branching ratios larger than this value \\n\"); \n"];
WriteString[SPhenoCH, "fprintf(fs,\"31 \\t -1 \\t # fixed GUT scale (-1:dynamical GUT scale) \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"32 \\t 0 \\t # Strict unification \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"34 \\t 1.000E-04 \\t # Precision of mass calculation \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"35 \\t 40 \\t # Maximal number of iterations\\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"37 \\t 1 \\t # Set Yukawa scheme \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"38 \\t 2 \\t # 1-or 2-Loop RGEs \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"50 \\t 1 \\t # Majorana phases:use only positive masses \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"51 \\t 0 \\t # Write Output in CKM basis \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"52 \\t 0 \\t # Write spectrum in case of tachyonic states \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"55 \\t 1 \\t # Calculate one loop masses \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"57 \\t 0 \\t # Calculate low energy constraints \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"60 \\t 1 \\t # Include possible,kinetic mixing \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"72 \\t 0 \\t # Write values at GUT scale \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"75 \\t 1 \\t # Write WHIZARD files \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"76 \\t 1 \\t # Write HiggsBounds file \\n\");\n"];
WriteString[SPhenoCH, "fprintf(fs,\"86 \\t 0. \\t # Maximal width to be counted as invisible in Higgs decays;\\n\");\n"];


WriteString[SPhenoCH, "fclose(fs); \n"];
WriteString[SPhenoCH,"\n\n // Run SPheno \n"];
WriteString[SPhenoCH, "system(\"~/SPHENO/bin/SPheno"<>ModelName<>"\"); \n"];
WriteString[SPhenoCH, "return 0; \n"];
WriteString[SPhenoCH, "} \n"];

];


SetVarsSPhenoCH:=Block[{i,j,k,i1,defv,temp},
For[i=1,i<=Length[MinparCalcHep],
If[StringLength[ToString[MinparCalcHep[[i,2]]]]>7,
If[StringLength[StringReplace[ToString[MinparCalcHep[[i,2]]],{"Signum"->"Sig"}]]>7,
temp=ReplaceAll[Hold[SetDelayed[MINFORM[MinparCalcHep[[NR,2]]],StringTake[StringReplace[ToString[MinparCalcHep[[NR,2]]],{"Signum"->"Sig"}],{1,7}] ]], {NR->i}];,
temp=ReplaceAll[Hold[SetDelayed[MINFORM[MinparCalcHep[[NR,2]]],StringReplace[ToString[MinparCalcHep[[NR,2]]],{"Signum"->"Sig"}] ]], {NR->i}];
];,
temp=ReplaceAll[Hold[SetDelayed[MINFORM[MinparCalcHep[[NR,2]]],StringReplace[ToString[MinparCalcHep[[NR,2]]],{"Signum"->"Sig"}] ]], {NR->i}];
];
ReleaseHold[temp];
i++;];

For[i=1,i<=Length[ExtparCalcHep],
If[StringLength[ToString[ExtparCalcHep[[i,2]]]]>7,
If[StringLength[StringReplace[ToString[ExtparCalcHep[[i,2]]],{"Signum"->"Sig"}]]>7,
temp=ReplaceAll[Hold[SetDelayed[MINFORM[ExtparCalcHep[[NR,2]]],StringTake[StringReplace[ToString[ExtparCalcHep[[NR,2]]],{"Signum"->"Sig"}],{1,7}] ]], {NR->i}];,
temp=ReplaceAll[Hold[SetDelayed[MINFORM[ExtparCalcHep[[NR,2]]],StringReplace[ToString[ExtparCalcHep[[NR,2]]],{"Signum"->"Sig"}] ]], {NR->i}];
];,
temp=ReplaceAll[Hold[SetDelayed[MINFORM[ExtparCalcHep[[NR,2]]],StringReplace[ToString[ExtparCalcHep[[NR,2]]],{"Signum"->"Sig"}] ]], {NR->i}];
];
ReleaseHold[temp];
i++;];




If[Head[DefaultInputValues]===List,
defv=DefaultInputValues;,
If[Head[DefaultInputValues[1]]===List,
defv=DefaultInputValues[1];,
defv={};
];
];

For[i=1,i<=Length[MinparCalcHep],
WriteString[varsFile, InsString[MINFORM[MinparCalcHep[[i,2]]]<>"SP",lVN]];
WriteString[varsFile, "|"];
WriteString[varsFile, If[NumericQ[MinparCalcHep[[i,2]]/.defv]===False,InsString["0.",lVV],InsString[ToString[MinparCalcHep[[i,2]]/.defv],lVV]]];
WriteString[varsFile, "| Input for SPheno: MINPAR "<>ToString[MinparCalcHep[[i,1]]]<>" \n"];
i++;];


For[i=1,i<=Length[ExtparCalcHep],
WriteString[varsFile, InsString[MINFORM[ExtparCalcHep[[i,2]]]<>"SP",lVN]];
WriteString[varsFile, "|"];
WriteString[varsFile, If[NumericQ[ExtparCalcHep[[i,2]]/.defv]===False,InsString["0.",lVV],InsString[ToString[ExtparCalcHep[[i,2]]/.defv],lVV]]];
WriteString[varsFile, "| Input for SPheno: EXTPAR "<>ToString[ExtparCalcHep[[i,1]]]<>" \n"];
i++;];


For[i1=1,i1<=Length[listInCalcHep],
Switch[Length[getDimParameters[listInCalcHep[[i1]]]],
1,
	For[i=1,i<=getDimParameters[listInCalcHep[[i1]]][[1]],
	WriteString[varsFile, InsString[CHForm[listInCalcHep[[i1]]]<>ToString[i]<>"IN",lVN]];WriteString[varsFile, "|"];
	WriteString[varsFile, If[NumericQ[listInCalcHep[[i1]][i]/.defv]===False,InsString["0.",lVV],InsString[ToString[listInCalcHep[[i1]][i]/.defv],lVV]]];
	 WriteString[varsFile, "|  Input for SPheno \n"];
	i++;];,
	
2,
	For[i=1,i<=getDimParameters[listInCalcHep[[i1]]][[1]],
	For[j=1,j<=getDimParameters[listInCalcHep[[i1]]][[2]],
	WriteString[varsFile, InsString[CHForm[listInCalcHep[[i1]]]<>ToString[i]<>ToString[j]<>"IN",lVN]];WriteString[varsFile, "|"];
	WriteString[varsFile, If[NumericQ[listInCalcHep[[i1]][i,j]/.defv]===False,InsString["0.",lVV],InsString[ToString[listInCalcHep[[i1]][i,j]/.defv],lVV]]];
	WriteString[varsFile, "|  Input for SPheno \n"];
	j++;];
	i++;];,
3,
	For[i=1,i<=getDimParameters[listInCalcHep[[i1]]][[1]],
	For[j=1,j<=getDimParameters[listInCalcHep[[i1]]][[2]],
	For[k=1,k<=getDimParameters[listInCalcHep[[i1]]][[3]],
	WriteString[varsFile, InsString[CHForm[listInCalcHep[[i1]]]<>ToString[i]<>ToString[j]<>ToString[k]<>"IN",lVN]];WriteString[varsFile, "|"];
	WriteString[varsFile, If[NumericQ[listInCalcHep[[i1]][i,j,k]/.defv]===False,InsString["0.",lVV],InsString[ToString[listInCalcHep[[i1]][i,j,k]/.defv],lVV]]];
	WriteString[varsFile, "|  Input for SPheno \n"];
	k++;];
	j++;];
	i++;];
];
i1++;];

];

SetFuncSPhenoCH:=Block[{i,j,k,i1},
For[i=1,i<=Length[MinparCalcHep],
WriteString[funcFile,InsString["set"<>MINFORM[MinparCalcHep[[i,2]]],lFF]<>"|"];
WriteString[funcFile,"set_MINPAR("<>ToString[i-1]<>","<>MINFORM[MinparCalcHep[[i,2]]]<>"SP"<>") \n"];
i++;];


For[i=1,i<=Length[ExtparCalcHep],
WriteString[funcFile,InsString["set"<>MINFORM[ExtparCalcHep[[i,2]]],lFF]<>"|"];
WriteString[funcFile,"set_EXTPAR("<>ToString[i-1]<>","<>MINFORM[ExtparCalcHep[[i,2]]]<>"SP"<>") \n"];
i++;];


For[i1=1,i1<=Length[listInCalcHep],
Switch[Length[getDimParameters[listInCalcHep[[i1]]]],
1,
	For[i=1,i<=getDimParameters[listInCalcHep[[i1]]][[1]],
	WriteString[funcFile,InsString["sp"<>CHForm[listInCalcHep[[i1]]]<>ToString[i],lFF]<>"|"];
	WriteString[funcFile,"set_"<>CHForm[listInCalcHep[[i1]]]<>"(i,"<>CHForm[listInCalcHep[[i1]]]<>ToString[i]<>"IN) \n"];
i++;];,
	
2,
	For[i=1,i<=getDimParameters[listInCalcHep[[i1]]][[1]],
	For[j=1,j<=getDimParameters[listInCalcHep[[i1]]][[2]],
	WriteString[funcFile,InsString["sp"<>CHForm[listInCalcHep[[i1]]]<>ToString[i]<>ToString[j],lFF]<>"|"];
	WriteString[funcFile,"set_"<>CHForm[listInCalcHep[[i1]]]<>"("<>ToString[i]<>","<>ToString[j]<>","<>CHForm[listInCalcHep[[i1]]]<>ToString[i]<>ToString[j]<>"IN) \n"];
	j++;];
	i++;];,
3,
	For[i=1,i<=getDimParameters[listInCalcHep[[i1]]][[1]],
	For[j=1,j<=getDimParameters[listInCalcHep[[i1]]][[2]],
	For[k=1,k<=getDimParameters[listInCalcHep[[i1]]][[3]],
	WriteString[funcFile,InsString["sp"<>CHForm[listInCalcHep[[i1]]]<>ToString[i]<>ToString[j]<>ToString[k],lFF]<>"|"];
	WriteString[funcFile,"set_"<>CHForm[listInCalcHep[[i1]]]<>"("<>ToString[i]<>","<>ToString[j]<>","<>ToString[k]<>","<>CHForm[listInCalcHep[[i1]]]<>ToString[i]<>ToString[j]<>ToString[k]<>"IN) \n"];
	k++;];
	j++;];
	i++;];
];
i1++;];


WriteString[funcFile,InsString["run",lFF]<>"|"];
WriteString[funcFile,"RunSPheno(alfSMZ) \n"];

];

WriteEXTLib[ModelNr_]:=Block[{},
extFile = OpenWrite[ToFileName[$sarahCurrentCalcHepDir,"extlib"<>ToString[ModelNr]<>".mdl"]];

WriteString[extFile,ModelName <>"\n "];
WriteString[extFile,"Libraries \n"];
WriteString[extFile, "External libraries and citation                                       <| \n"];
WriteString[extFile,"$WORK/models/SPhenoViaCalcHep.c                                        |  \n"];
WriteString[extFile,"======================================================================== \n"];


Close[extFile];

];

