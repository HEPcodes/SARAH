(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
CheckModel:=Block[{startedtime},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckModel";
SA`Doc`Info ="This is the main function to run different checks in order to validate the implementation of the initialised model. Formal checks (e.g. missing definitions) as well as physical checks (e.g. wrong mixing, charge violation) are performed. ";
SA`Doc`Input ={};
SA`Doc`GenerateEntry[];

startedtime=TimeUsed[];



Print[StyleForm["Perform checks of particle content and (super)potential","Section",FontSize->14]];
CheckAnomalies;

Print[""];
CheckChargeConservation;

Print[""];
If[SupersymmetricModel===False,
CheckPossibleTermsPotential;,
CheckPossibleTermsSuperPotential;
];

Print[""];
Print[""];
Print[StyleForm["Perform checks of particle mixing and VEVs","Section",FontSize->14]];

CheckParticleMixingAndVEVs;

Print[""];
Print[""];
Print[StyleForm["Perform checks of mass matrices and eigenstates","Section",FontSize->14]];

CheckMassMatrices;
Print[""];
CheckMissingMixing;


Print[""];
Print[""];
Print[StyleForm["Perform checks of definitions for particles and parameters","Section",FontSize->14]];


CheckDiracSpinors;
(*Print["***********************************************************"];*)
Print[""];

CheckParameterDefinitionsFinal;
(*Print["***********************************************************"];*)
Print[""];
CheckParticleDefinitionsFinal;


Print[""];
Print[""];
Print["All checks finished in ",TimeUsed[]-startedtime,"s"];

SA`Doc`EndEntry[];
];


CheckMissingMixing:=Block[{i},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckMissingMixing";
SA`Doc`Info = "This routines checks for missing mixings for the final eigenstates. The check if a mixing is missing is performed by a separate routine, CheckParticleMixing. (This separation is somehow artifical and in principle no longer needed. The origin was a (useless!) loop over all eigenstates in an earlier version.";
SA`Doc`Input ={};
SA`Doc`GenerateEntry[];

Print["--------------- Checking, if other particles will also mix ----------------- "];
Print["Note, only the Lagrangian for the final eigenstates is checked. "];
For[i=Length[NameOfStates],i<=Length[NameOfStates],
Print["***   Considered Lagrangian for ",NameOfStates[[i]], "   ***"];
CheckParticleMixing[NameOfStates[[i]]];
i++;];

SA`Doc`EndEntry[];
];

CheckDiracSpinors:=Block[{i,list,nodirac,partF},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckDiracSpinors";
SA`Doc`Info = "This routines checks the definition of the Dirac spinors. Two checks are performed: \n
1) Do all Weyl spinors in the model show up in Dirac spinors? \n
2) Are the definition of the Dirac spinors in agreement with unbroken charges?";
SA`Doc`Input ={};
SA`Doc`GenerateEntry[];

Print["--------------- Checking presence of dirac spinors ----------------- "];
For[i=1,i<=Length[NameOfStates],
Print["Checking Dirac spinors of ",NameOfStates[[i]]];
(* nodirac = Select[Transpose[Particles[NameOfStates[[i]]]][[1]],(getTypeOld[#]===F && FreeQ[DEFINITION[NameOfStates[[i]]][DiracSpinors],#])&]; *)
partF=Flatten[Take[#,1]&/@Select[Particles[NameOfStates[[i]]],(#[[4]]===F)&]];
nodirac = Select[partF,(FreeQ[DEFINITION[NameOfStates[[i]]][DiracSpinors],#])&];
If[nodirac==={},
Print["   for all Weyl spinors are Dirac spinors defined"];,
DiracSpinor::missing="For the following Weyl spinors are no Dirac spinors defined: ``";
Message[DiracSpinor::missing, nodirac];
];
i++;];

Print["--------------- Checking Dirac Spinors for charge conservation ----------------- "];
For[i=1,i<=Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[i]]][DiracSpinors]]===List,
Print["Check dirac spinors for eigenstates ", NameOfStates[[i]]];
list=DEFINITION[NameOfStates[[i]]][DiracSpinors];

For[j=1,j<=Length[list],
Print["  ... checking ",list[[j]]];
entry = DeleteCases[list[[j,2]],0,2];
charges=getChargesAndRParity/@entry;
CheckConservationMixing[NameOfStates[[i]],charges,getRParity[list[[j,1]],NameOfStates[[i]]],list[[j,2]],list[[j,1]]];
j++;];
];
i++;];

SA`Doc`EndEntry[];
];


CheckParticleMixingAndVEVs:=Block[{i,j,k},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckParticleMixingAndVEVs";
SA`Doc`Info = "This is the main function to call the routines which perform checks for the definition of field rotations and VEVs in the model file. ";
SA`Doc`Input ={};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[NameOfStates],
Print["--------- Considered eigenstates ", NameOfStates[[i]]," --------"];
If[BrokenGaugeSymmetries[NameOfStates[[i]]]=!={} && Head[BrokenGaugeSymmetries[NameOfStates[[i]]]]===List,
Print["*** Gauge groups which get broken at this step: ***"];
Print["*** ",Table[Gauge[[BrokenGaugeSymmetries[NameOfStates[[i]]][[j]],3]],{j,1,Length[BrokenGaugeSymmetries[NameOfStates[[i]]]]}]," ***"];
];
(* If[RParityConservation\[Equal]True,Print["*** R-Parity is assumed to be conserved ***"];]; *)
Print["-----------------------------------------------------------------"];
If[Head[DEFINITION[NameOfStates[[i]]][GaugeSector]]===List,
CheckRotationsGauge[NameOfStates[[i]]];
];

If[Head[DEFINITION[NameOfStates[[i]]][GaugeSectorOld]]===List,
CheckRotationsGaugeOld[NameOfStates[[i]]];
];

If[Head[DEFINITION[NameOfStates[[i]]][Flavors]]===List,
CheckFlavorDecomp[NameOfStates[[i]]];
];


If[Head[DEFINITION[NameOfStates[[i]]][VEVs]]===List,
CheckVEVs[NameOfStates[[i]]];
];

If[Head[DEFINITION[NameOfStates[[i]]][MatterSector]]===List,
CheckRotations[NameOfStates[[i]]];
];
Print["Done"];
Print["-----------------------------------------------------------------"];
Print[""];
i++;];

SA`Doc`EndEntry[];
];

CheckFlavorDecomp[ES_]:=Block[{i,j,list,pos},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckFlavorDecomp";
SA`Doc`Info = "This routines collects the quantum numbers of the fields which are involved in the definition of a flavoru compostion (via. 'DEFINITION[ES][Flavors]' in the model file). This information is later used to check the charge conservation in Dirac spinors for instance. (I.e. the name of the routine including a 'Check' is not very well chosen and misleading! It doesn't do any checks itself!) ";
SA`Doc`Input ={"ES"->"Considered Eigenstates"};
SA`Doc`GenerateEntry[];

Print["Checking flavor decomposition of ",ES];
list = DEFINITION[ES][Flavors];
For[i=1,i<=Length[list],

For[j=1,j<=Length[list[[i,2]]],
Switch[getTypeOld[list[[i,1]]],
F,
	pos = Position[SA`QNfermion,list[[i,1]]][[1,1]];
	SA`QNfermion = Join[SA`QNfermion, {{list[[i,2,j]],SA`QNfermion[[pos]][[2]]}}];,
S,
	pos = Position[SA`QNscalar,list[[i,1]]][[1,1]];
	SA`QNscalar = Join[SA`QNscalar, {{list[[i,2,j]],SA`QNscalar[[pos]][[2]]}}];
];
j++;];
i++];

SA`Doc`EndEntry[];
];

CheckRotationsGauge[ES_]:=Block[{i,j,charges,list,entry,flist},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckRotationsGauge";
SA`Doc`Info = "This routine checks of fields which are combined via a rotation in the gauge sector have the same global and local charges. This is only a routine which performs the loop over all necessary entries. The actual check is done in the routine 'CheckConservationMixing' which gets called. ";
SA`Doc`Input ={"ES"->"Considered Eigenstates"};
SA`Doc`GenerateEntry[];

Print["--------------- Checking rotations in gauge sector ----------------- "];

flist = DEFINITION[ES][GaugeSector] ;
list = DEFINITION[ES][GaugeSector] /. A_[b_Integer]->A;

For[i=1,i<=Length[list],
If[getTypeOld[list[[i,1,1]]]===F,
charges=getChargesAndRParity/@list[[i,1]];
For[j=1,j<=Length[list[[i,2]]],
Print["Checking mixing of ",flist[[i,1]], " to ",list[[i,2,j]]];
CheckConservationMixing[ES,charges,getRParity[list[[i,2,j]],ES],flist[[i,1]],list[[i,2,j]]];
j++;];
];
i++];

SA`Doc`EndEntry[];
];


CheckRotationsGaugeOld[ES_]:=Block[{i,j,k,charges,list,entry,flist,basis},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckRotationsGaugeOld";
SA`Doc`Info = "This routine checks of fields which are combined via a rotation in the gauge sector have the same global and local charges. This is only a routine which performs the loop over all necessary entries. The actual check is done in the routine 'CheckConservationMixing' which gets called. NOTE: this version assumes the outdated definition of rotations in the gauge sector in the model file ('DEFINITION[ES][GaugeSectorOld]') and is most likely no longer needed. ";
SA`Doc`Input ={"ES"->"Considered Eigenstates"};
SA`Doc`GenerateEntry[];

Print["--------------- Checking rotations in gauge sector ----------------- "];

temp = DEFINITION[ES][GaugeSectorOld] ;
basis={};
For[i=1,i<=Length[temp],
basis=Join[basis,
{{Table[temp[[i,1]][temp[[i,j,1]]],{j,2,Length[temp[[i]]]}],Intersection[Flatten[Table[Table[temp[[i,k,j,1]],{j,2,Length[temp[[i,k]]]}],{k,2,Length[temp[[i]]]}]]]}}];
i++;];
Print[basis];
flist=basis;
list = basis/. A_[b_Integer]->A;

For[i=1,i<=Length[list],
If[getTypeOld[list[[i,1,1]]]===F,
charges=getChargesAndRParity/@list[[i,1]];
For[j=1,j<=Length[list[[i,2]]],
Print["Checking mixing of ",flist[[i,1]], " to ",list[[i,2,j]]];
CheckConservationMixing[ES,charges,getRParity[list[[i,2,j]],ES],flist[[i,1]],list[[i,2,j]]];
j++;];
];
i++];

SA`Doc`EndEntry[];
];


CheckRotations[ES_]:=Block[{i,j,k,charges, charges2,fs},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckRotations";
SA`Doc`Info = "This routine loops over all rotation in the matter sector for the different eigenstates and checks if the rotations are in agreement with all unbroken local and global charges. ";
SA`Doc`Input ={"ES"->"Considered Eigenstates"};
SA`Doc`GenerateEntry[];

Print["--------------- Checking field rotations for Eigenstates ", ES,"-------------------"];
entry=MixBasis[ES];

For[i=1,i<=Length[entry],
If[Head[MixedNames[ES][[i]]]===List,
Print["Checking mixing of ",entry[[i,1]], " to ",MixedNames[ES][[i,1,1]]];
charges=getChargesAndRParity/@entry[[i,1]];
CheckConservationMixing[ES,charges,getRParity[MixedNames[ES][[i,1,1]],ES],entry[[i,1]],MixedNames[ES][[i,1,1]]];
Print["Checking mixing of ",entry[[i,2]], " to ",MixedNames[ES][[i,2,1]]];
charges=getChargesAndRParity/@entry[[i,2]];
CheckConservationMixing[ES,charges,getRParity[MixedNames[ES][[i,2,1]],ES],entry[[i,1]],MixedNames[ES][[i,2,1]]];,
If[getType[MixedNames[ES][[i]]]=!=A,
Print["Checking mixing of ",entry[[i,1]], " to ",MixedNames[ES][[i]]];
charges=getChargesAndRParity/@entry[[i,1]];
CheckConservationMixing[ES,charges,getRParity[MixedNames[ES][[i]],ES] ,entry[[i,1]],MixedNames[ES][[i]]];
];
];
i++;];

SA`Doc`EndEntry[];
];

CheckConservationMixing[ES_,charges_,finalrpv_,ifields_,ffields_]:=Block[{j,i,temp,charges2},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckConservationMixing";
SA`Doc`Info = "This routine checks if a given rotation (in terms of initial and final fields) is in agreement with all unbroken global and local charges. Of not, a warning is printed.";
SA`Doc`Input ={"ES"->"Considered Eigenstates", "charges"->"local and global charges", "finalrpv"->"R-Parity of final particles", "ifields"->"initial fields","ffields"->"final fields"};
SA`Doc`GenerateEntry[];

charges2 = Table[charges[[i,j]],{j,1,Length[Gauge]+1},{i,1,Length[charges]}]; 
For[i=1,i<=Length[Gauge],
If[Gauge[[i,2]]=!=U[1],charges2[[i]] = charges2[[i]] /. -1 ->1 /.{ -(Gauge[[i,2,1]]^2-1)->(Gauge[[i,2,1]]^2-1),-2->2};];
i++;];


For[j=1,j<=Length[Gauge],
If[FreeQ[BrokenGaugeSymmetries[ES],j],
If[Length[Intersection[charges2[[j]]]]>1,
Mixing::DifferentQN="Fields `` have different quantum numbers with respect to \" `` \" and can't mix";
Message[Mixing::DifferentQN,ifields,Gauge[[j,3]]];,
Print["    ... mixing allowed by quantum number with respect to \"" ,Gauge[[j,3]],"\" invariance"];
];
];
j++;];


If[Head[ffields]===conj,
chargesC={Join[-Take[charges[[1]],{1,3}],{charges[[1,4]]}]};,
chargesC=charges;
]; 

Switch[getTypeOld[ffields],
F,
	SA`QNfermion = Join[SA`QNfermion,{{RE[ffields],chargesC[[1]]}}];,
S,
	SA`QNscalar = Join[SA`QNscalar,{{RE[ffields],chargesC[[1]]}}];,
A,
	SA`QNaux = Join[SA`QNaux,{{RE[ffields],chargesC[[1]]}}];
];

SA`Doc`EndEntry[];
];

getChargesAndRParity[field_]:=Block[{conjQ,temp,res,pos,type,charges},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "getChargesAndRParity";
SA`Doc`Info = "This routine return the local and global charges of a given field. Note, in older versions of SARAH, the only global charge was R-Parity. This explains the name of the routine. However, it is nowadays more general and returns all global charges.";
SA`Doc`Input ={"field"->"Considered field"};
SA`Doc`GenerateEntry[];

If[Head[field]===conj,conjQ=True; temp=field[[1]];, temp = field;];
Switch[getTypeOld[temp],
F,
	pos = Position[SA`QNfermion,temp][[1,1]];
	charges = Drop[SA`QNfermion[[pos]],1];,
S,
	pos = Position[SA`QNscalar,temp][[1,1]];
	charges = Drop[SA`QNscalar[[pos]],1];,
A,
	pos = Position[SA`QNaux,temp][[1,1]];
	charges = Drop[SA`QNaux[[pos]],1];
];
charges=charges[[1]];
If[conjQ==True,
charges = - charges;
charges[[-1]]=-charges[[-1]];
];
SA`Doc`Return[charges];

];


CheckVEVs[ES_]:=Block[{i,j,entry,charges},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckVEVs";
SA`Doc`Info = "This routine checks if a particle gets a VEV which is charged under an unbroken gauge symmetry. Unbroken gauge symmetries are those which are not contained in 'BrokenGaugeSymmetries'. 'BrokenGaugeSymmetries' includes all gauge symmetries whose vector bosons are rotated/mixed in the model file.";
SA`Doc`Input ={"ES"->"Considered Eigenstates"};
SA`Doc`GenerateEntry[];

entry=DEFINITION[ES][VEVs];

For[i=1,i<=Length[entry],
Print["Checking decomposition of",entry[[i,1]]];
pos=Position[SA`QNscalar,entry[[i,1]]][[1,1]];
charges = Drop[SA`QNscalar[[pos]],1][[1]];
For[j=1,j<=Length[Gauge],
If[entry[[i,2,1]]=!=0 &&  entry[[i,2,2]]=!=0,
If[(FreeQ[BrokenGaugeSymmetries[ES],j] && Gauge[[j,2]]===U[1] && charges[[j]]=!=0) || (FreeQ[BrokenGaugeSymmetries[ES],j] && Gauge[[j,2,0]]===SU && Abs[charges[[j]]]=!=1),
VEV::UnbrokenSymmetries="Particle `` charged under unbroken gauge group \" `` \" receives VEV";
Message[VEV::UnbrokenSymmetries,entry[[i,1]],Gauge[[j,3]]];,
If[FreeQ[BrokenGaugeSymmetries[ES],j],
Print["    ... does not break \"",Gauge[[j,3]],"\" "];
];
];
];
j++];

If[Length[entry[[i]]]===5,
If[Length[entry[[i,5]]]===2,
For[j=4,j<=5,
SA`QNscalar = Join[SA`QNscalar,{Join[{entry[[i,j,1]]},{charges}]}];
j++];,
For[j=3,j<=4,
SA`QNscalar = Join[SA`QNscalar,{Join[{entry[[i,j,1]]},{charges}]}];
j++];
];,
For[j=3,j<=4,
SA`QNscalar = Join[SA`QNscalar,{Join[{entry[[i,j,1]]},{charges}]}];
j++];
];

i++;];

SA`Doc`EndEntry[];
];

CheckParticleDefinitionsFinal:=Block[{i,ES},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckParticleDefinitionsFinal";
SA`Doc`Info = "This routine performs formal checks of the definitions in particles.m. It checks if all possible entries to define a particle are given and have the correct size. It is also checked if entries are duplicated. ";
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[NameOfStates],
Print["Checking particle definitions for ", NameOfStates[[i]]];
ES = NameOfStates[[i]];
MakeTypeListParticles[NameOfStates[[i]]];

allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]],Transpose[PART[G]][[1]]}];

Print["    checking for particles not defined in particles.m"];
missingParticle=Select[allParticleNames,(FreeQ[Transpose[ParticleDefinitions[ES]][[1]],#]&)];
If[missingParticle=!={},Message[CheckModelFiles::MissingParticle,missingParticle];];

Print["    checking for missing OutputNames"];
missingOutputNames=Select[allParticleNames,(getOutputName[#,1,1]===None)&];
If[missingOutputNames=!={},Message[CheckModelFiles::MissingOutputName,missingOutputNames];];

(* If[RParityConservation\[Equal]True, *)
If[FreeQ[Global,RParity]==False,
Print["    checking for defned R-Parity"];
CheckModelFiles::MissingRParity = "R-Parity for particles `` has not been defined";
missingRParity=Select[allParticleNames,(getRParity[#,ES]===None || getRParity[#,ES]===RParity)&];
If[missingRParity=!={},Message[CheckModelFiles::MissingRParity,missingRParity];];
];

Print["    checking PDGs"];
allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]]}];
missingPDG=Select[allParticleNames,((getFla[#]*getGen[#]=!=Length[getPDG[#]]&&getPDG[#]=!=None)&)];
missingPDG=Select[missingPDG,(FreeQ[SGauge,#]||Length[getPDG[#]]<1)&];
missingPDG=Select[missingPDG,(FreeQ[FGauge/.diracSubBack1[ES]/.diracSubBack2[ES],#]||Length[getPDG[#]]<1)&];
If[missingPDG=!={},Message[CheckModelFiles::WrongPDG,missingPDG];];

Print["    electric charge"];
allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]]}];
missingEC=Select[allParticleNames,(ElectricCharge[#]===None&)];
If[missingEC=!={},Message[CheckModelFiles::ElectricCharge,missingEC];];

Print["    checking Length of OutputNames"];
longNames=Select[allParticleNames,((StringLength[ToString[getOutputName[#,1,1]]]+(getRParity[#,ES] /. {1->0,-1->1}))>8)&];
If[longNames=!={},
ParticleNames::TooLong="The OutputNames of the following particles are too long for an valid CalcHep output: ``";
Message[ParticleNames::TooLong,longNames];
];

Print["    checking for OutputNames defined twice"];
twiceNames=Select[getOutputName[#]&/@ allParticleNames,(Count[getOutputName[#]&/@ allParticleNames,#]>1)&];
If[twiceNames=!={},
ParticleNames::DefinedTwice="The following OutputNames are used serveral times: ``";
Message[ParticleNames::DefinedTwice,Intersection[twiceNames]];
temp=Intersection[twiceNames];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[allParticleNames,(getOutputName[#]===temp[[j]])&]];
j++;];
];

Print["    checking for FeynArts numbers"];
allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]],Transpose[PART[G]][[1]]}];
noFANr=Select[allParticleNames,(getEntryField[#,FeynArtsNr]===FeynArtsNr || getEntryField[#,FeynArtsNr] ===None)&];
If[noFANr=!={},
FeynArts::NN="No FeynArts number defined for ``";
Message[FeynArts::NN,noFANr];
];

Print["    checking for FeynArts numbers used several times"];
Print["      ... Fermions"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[F]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},
Message[FeynArts::NumberDefinedTwiceF,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[F]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
 ];
Print["      ... Scalars"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[S]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},
Message[FeynArts::NumberDefinedTwiceS,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[S]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
];
Print["      ... Vector Bosons"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[V]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},Message[FeynArts::NumberDefinedTwiceV,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[V]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
];
Print["      ... Ghosts"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[G]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},Message[FeynArts::NumberDefinedTwiceG,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[G]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
 ];

If[i===Length[NameOfStates],
Print["Checking definition of electric charge for final eigenstates"]; 
Print["This information is only needed for the CalcHep, MadGraph and SPheno output"];
allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]],Transpose[PART[G]][[1]]}];
noEC=Select[allParticleNames,(getEntryField[#,ElectricCharge]===ElectricCharge || getEntryField[#,ElectricCharge] ===None)&];
If[noEC=!={},
Model::NoEC="No electric charge defined for ``";
Message[Model::NoEC,noEC];
];
i++;];

i++;];



SA`Doc`EndEntry[];
];




(* ::Input::Initialization:: *)
CheckParameterDefinitionsFinal:=Block[{i,missingParticle={},missingParameter={},missingPDG={},missingLHparameter={},allParticleNames,allParameterNames,missingOutputNames},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckParameterDefinitionsFinal";
SA`Doc`Info = "This routine checks the definition in parameters.m. It checks if all necessary definitions are provided and if the values are correct.";
SA`Doc`GenerateEntry[];

Print["Checking parameter definitions"];
allParameterNames=Transpose[parameters][[1]];

Print["    checking for parameters not defined in parameters.m"];
missingParameter=Select[allParameterNames,((FreeQ[Transpose[ParameterDefinitions][[1]],#] && Head[#]=!=Mass)&)];
If[missingParameter=!={},Message[CheckModelFiles::MissingParameter,missingParameter];];

Print["    checking LesHouches names"];
missingLHparameter=Select[allParameterNames,(Head[getLHBlockName[#]]===None)&];
If[missingLHparameter=!={},Message[CheckModelFiles::MissingLH,missingLHparameter];];

Print["    checking for missing OutputNames"];
missingOutputNameParameter=Select[allParameterNames,(getEntryParameter[#,OutputName]===None && Head[#]=!=Mass)&];
If[missingOutputNameParameter=!={},Message[CheckModelFiles::MissingOutputNameParameter,missingOutputNameParameter];];


Print["    checking Length of OutputNames"];
longNames=Select[allParameterNames,((StringLength[ToString[getEntryParameter[#,OutputName]]]+ Length[getDimParameters[#]/. {1}->{} /. {0}->{}])>8)&];
If[longNames=!={},
ParameterNames::TooLong="The OutputNames of the following parameters are too long for an valid CalcHep output: ``";
Message[ParameterNames::TooLong,longNames];
];

Print["    checking for OutputNames defined twice"];
twiceNames=Select[getEntryParameter[#,OutputName]&/@ allParameterNames,(Count[getEntryParameter[#,OutputName]&/@ allParameterNames,#]>1)&];
If[twiceNames=!={},
ParameterNames::DefinedTwice="The following OutputNames are used serveral times: ``";
Message[ParameterNames::DefinedTwice,Intersection[twiceNames]];
temp=Intersection[twiceNames];
For[i=1,i<=Length[temp],
Print["            ",temp[[i]]," :",Select[allParameterNames,(getEntryParameter[#,OutputName]===temp[[i]])&]];
i++;];
];

(*
Print["    checking for OutputNames which are already occupied"];
SPhenoInternalNames = {RHO, LAMBDA};
*)
SA`Doc`EndEntry[];
];

CheckMassMatrices:=Block[{i,mat},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckMassMatrices";
SA`Doc`Info = "This routine checks the mass matrices stemming from the definition of the rotations in the model file. Two checks are performed: \n
1) Does the matrix contain only zeros? (This points most likely towards an error in the implementation) \n
2) Is the matrix reducible (i.e. can it be brought to a block diagonal form) This means that a mixing is not there which has been assumed in the implementation. ";
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[NameOfStates],
If[Head[MassMatrices[NameOfStates[[i]]]]===List,
Print["Checking mass matrices for eigenstates ",NameOfStates[[i]]];
mat=MassMatrices[NameOfStates[[i]]];

For[j=1,j<=Length[mat],
If[getTypeOld[MixedNames[NameOfStates[[i]]][[j]]]=!=A,
Print[ "   Checking matrix for ",MixBasis[NameOfStates[[i]]][[j]]];
If[Intersection[Flatten[mat[[j]]]]==={0},
Message[MassMatrix::OnlyZero,MixBasis[NameOfStates[[i]]][[j]]];,
Print[ "   ...  contains non zero-elements"];
];

If[CheckReducibility[mat[[j]]]===False,
Print[ "   ...  seems not to be reducible"];,
MassMatrix::Reducible="Mass matrix of `` seems to be reducible";
Message[MassMatrix::Reducible,MixBasis[NameOfStates[[i]]][[j]]];
Print[ "   ...  contains non zero-elements"];
];
];
j++;];
];
i++;];
SA`Doc`EndEntry[];
];


CheckParticleMixing[ES_]:=Block[{i,j,temp,pos,partS,partF,partV,vert},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckParticleMixing";
SA`Doc`Info = "This routine checks if bilinear terms between different fields are present in the Lagrangian for given eigenstates. This would mean that a mixing has been missed. Note, it can happen that SARAH finds such a term, but this term might be zero (for instance after some relations between parameters are taken into account).";
SA`Doc`Input ={"ES"->"Considered Eigenstates"};
SA`Doc`GenerateEntry[];

Off[General::stop];
partS=Flatten[Take[#,1]&/@Select[Particles[ES],(#[[4]]===S)&]];
partF=Intersection[Flatten[Take[#,1]&/@Select[Particles[ES],(#[[4]]===F)&]]/. diracSubBack[ES] /. bar[x_]->x];
partV=Flatten[Take[#,1]&/@Select[Particles[ES],(#[[4]]===V)&]];

Lagrangian::PossibleMixing="Possible mixing between `` and `` induced by the term: ``";

For[i=1,i<=Length[partS],
For[j=i+1,j<=Length[partS],
vert=FullSimplify[Vertex[{partS[[i]],partS[[j]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partS[[i]],partS[[j]],vert];
(* Print["Possible mixing between ",partS[[i]], " and ",partS[[j]]]; 
Print["    term :",vert]; *),
vert=FullSimplify[Vertex[{partS[[i]],conj[partS[[j]]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partS[[i]],conj[partS[[j]]],vert];
(* Print["Possible mixing between ",partS[[i]], " and ",conj[partS[[j]]]]; 
Print["    term :",vert]; *)
];
];
j++;];
i++;];

For[i=1,i<=Length[partF],
For[j=i+1,j<=Length[partF],
vert = FullSimplify[(Vertex[{partF[[i]],partF[[j]]},Eigenstates->ES]//. subAlways //. subDependences)];
If[Length[vert]===3,
vert=FullSimplify[vert[[2,1]]+vert[[3,1]]];,
vert=FullSimplify[vert[[2,1]]];
];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partF[[i]],partF[[j]],vert];
(* Print["Possible mixing between ",partF[[i]], " and ",partF[[j]]]; 
Print["    term :", vert]; *),
vert = FullSimplify[(Vertex[{bar[partF[[i]]],partF[[j]]},Eigenstates->ES]//. subAlways //. subDependences)];
If[Length[vert]===3,
vert=FullSimplify[vert[[2,1]]+vert[[3,1]]];,
vert=FullSimplify[vert[[2,1]]];
];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partF[[i]],conj[partF[[j]]],vert];
(* Print["Possible mixing between ",partF[[i]], " and ",conj[partF[[j]]]]; 
Print["    term :",vert]; *)
];
];
j++;];
i++;];

For[i=1,i<=Length[partV],
For[j=i+1,j<=Length[partV],
vert=FullSimplify[Vertex[{partV[[i]],partV[[j]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partV[[i]],partV[[j]],vert];
(* Print["Possible mixing between ",partV[[i]], " and ",partV[[j]]]; 
Print["    term :",vert];*),
vert=FullSimplify[Vertex[{partV[[i]],conj[partV[[j]]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partV[[i]],conj[partV[[j]]],vert];
(* Print["Possible mixing between ",partV[[i]], " and ",conj[partV[[j]]]]; 
Print["    term :",vert]; *)
];
];
j++;];
i++;];

SA`Doc`EndEntry[];
On[General::stop];
];


CheckReducibility[mat_]:=Block[{i,j,k,l,dim1,dim2,zeroC,zeroR,NZC,NZR,k1,k2,newC, newR,irred=False,startold, startnew,count0=0},
SA`Doc`File = "Package/checkModel.nb";
SA`Doc`Name = "CheckReducibility";
SA`Doc`Info = "This routine checks if a matrix is reducible. ";
SA`Doc`Input ={"mat"->"Considered matrix"};
SA`Doc`GenerateEntry[];

(* dim=Length[mat]; *)
dim1=Dimensions[mat][[1]];
dim2=Dimensions[mat][[2]];

For[i=1,i<=dim1,
For[j=1,j<=dim2,
If[mat[[i,j]]=!=0,
NZEC[i,j] = Flatten[Position[Transpose[mat][[j]],x_?((#=!=0 && #=!=List)&)]];
NZER[i,j] = Flatten[Position[mat[[i]],x_?((#=!=0 && #=!=List)&)]];,
NZEC[i,j] = {};
NZER[i,j] = {};
count0++;
];
j++;];
i++;];

For[i=1,i<=dim1,
For[j=1,j<=dim2,
If[mat[[i,j]]=!=0,
newC = Table[{NZEC[i,j][[k]],j},{k,1,Length[NZEC[i,j]]}];
newR = Table[{i,NZER[i,j][[k]]},{k,1,Length[NZER[i,j]]}];
startnew=Intersection[Join[newC,newR]];
iter=0;
While[Length[startold]=!=Length[startnew],
iter=iter+1;
startold=startnew;
startnew={};
For[l=1,l<=Length[startold],
newC = Table[{NZEC[startold[[l,1]],startold[[l,2]]][[k]],startold[[l,2]]},{k,1,Length[NZEC[startold[[l,1]],startold[[l,2]]]]}];
newR = Table[{startold[[l,1]],NZER[startold[[l,1]],startold[[l,2]]][[k]]},{k,1,Length[NZER[startold[[l,1]],startold[[l,2]]]]}];
startnew=Join[startnew,Intersection[Join[newC,newR]]];
l++;];
startnew=Intersection[startnew];
];

If[Length[startnew]<(dim^2 - count0),
irred = True;
];

];
j++;];
i++;];

SA`Doc`Return[irred];

];
