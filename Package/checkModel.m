(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



CheckModel:=Block[{startedtime},
startedtime=TimeUsed[];
(*
Print["###########################################################"];
Print["Perform checks of particle content and (super)potential"];
Print["###########################################################"]; *)
Print[StyleForm["Perform checks of particle content and (super)potential","Section",FontSize->14]];
CheckAnomalies;
(*Print["***********************************************************"];*)
Print[""];
CheckChargeConservation;
(*Print["***********************************************************"];*)
Print[""];
If[SupersymmetricModel===False,
CheckPossibleTermsPotential;,
CheckPossibleTermsSuperPotential;
];

Print[""];
Print[""];
(*Print["###########################################################"];
Print["Perform checks of particle mixing and VEVs"];
Print["###########################################################"];*)
Print[StyleForm["Perform checks of particle mixing and VEVs","Section",FontSize->14]];

CheckParticleMixingAndVEVs;

Print[""];
Print[""];
(*Print["###########################################################"];
Print["Perform checks of mass matrices and eigenstates"];
Print["###########################################################"];*)
Print[StyleForm["Perform checks of mass matrices and eigenstates","Section",FontSize->14]];

CheckMassMatrices;
(*Print["***********************************************************"];*)
Print[""];
CheckMissingMixing;


Print[""];
Print[""];
(*Print["###########################################################"];
Print["Perform checks of definitions for particles and parameters"];
Print["###########################################################"];*)
Print[StyleForm["Perform checks of definitions for particles and parameters","Section",FontSize->14]];

CheckDiracSpinors;
(*Print["***********************************************************"];*)
Print[""];
CheckParameterDefinitionsFinal;
(*Print["***********************************************************"];*)
Print[""];
CheckParticleDefinitionsFinal;

Print[""];
Print[""];
Print["All checks finished in ",TimeUsed[]-startedtime,"s"];
];


CheckMissingMixing:=Block[{i},
Print["--------------- Checking, if other particles will also mix ----------------- "];
Print["Note, only the Lagrangian for the final eigenstates is checked. "];
For[i=Length[NameOfStates],i<=Length[NameOfStates],
Print["***   Considered Lagrangian for ",NameOfStates[[i]], "   ***"];
CheckParticleMixing[NameOfStates[[i]]];
i++;];
];

CheckDiracSpinors:=Block[{i,list,nodirac,partF},
Print["--------------- Checking presence of dirac spinors ----------------- "];
For[i=1,i<=Length[NameOfStates],
Print["Checking Dirac spinors of ",NameOfStates[[i]]];
(* nodirac = Select[Transpose[Particles[NameOfStates[[i]]]][[1]],(getTypeOld[#]===F && FreeQ[DEFINITION[NameOfStates[[i]]][DiracSpinors],#])&]; *)
partF=Flatten[Take[#,1]&/@Select[Particles[NameOfStates[[i]]],(#[[4]]===F)&]];
nodirac = Select[partF,(FreeQ[DEFINITION[NameOfStates[[i]]][DiracSpinors],#])&];
If[nodirac==={},
Print["   for all Weyl spinors are Dirac spinors defined"];,
DiracSpinor::missing="For the following Weyl spinors are no Dirac spinors defined: ``";
Message[DiracSpinor::missing, nodirac];
];
i++;];

Print["--------------- Checking Dirac Spinors for charge conservation ----------------- "];
For[i=1,i<=Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[i]]][DiracSpinors]]===List,
Print["Check dirac spinors for eigenstates ", NameOfStates[[i]]];
list=DEFINITION[NameOfStates[[i]]][DiracSpinors];

For[j=1,j<=Length[list],
Print["  ... checking ",list[[j]]];
entry = DeleteCases[list[[j,2]],0,2];
charges=getChargesAndRParity/@entry;
CheckConservationMixing[NameOfStates[[i]],charges,getRParity[list[[j,1]],NameOfStates[[i]]],list[[j,2]],list[[j,1]]];
j++;];
];
i++;];

];


CheckParticleMixingAndVEVs:=Block[{i,j,k},
For[i=1,i<=Length[NameOfStates],
Print["--------- Considered eigenstates ", NameOfStates[[i]]," --------"];
If[BrokenGaugeSymmetries[NameOfStates[[i]]]=!={} && Head[BrokenGaugeSymmetries[NameOfStates[[i]]]]===List,
Print["*** Gauge groups which get broken at this step: ***"];
Print["*** ",Table[Gauge[[BrokenGaugeSymmetries[NameOfStates[[i]]][[j]],3]],{j,1,Length[BrokenGaugeSymmetries[NameOfStates[[i]]]]}]," ***"];
];
(* If[RParityConservation\[Equal]True,Print["*** R-Parity is assumed to be conserved ***"];]; *)
Print["-----------------------------------------------------------------"];
If[Head[DEFINITION[NameOfStates[[i]]][GaugeSector]]===List,
CheckRotationsGauge[NameOfStates[[i]]];
];

If[Head[DEFINITION[NameOfStates[[i]]][GaugeSectorOld]]===List,
CheckRotationsGaugeOld[NameOfStates[[i]]];
];

If[Head[DEFINITION[NameOfStates[[i]]][Flavors]]===List,
CheckFlavorDecomp[NameOfStates[[i]]];
];


If[Head[DEFINITION[NameOfStates[[i]]][VEVs]]===List,
CheckVEVs[NameOfStates[[i]]];
];

If[Head[DEFINITION[NameOfStates[[i]]][MatterSector]]===List,
CheckRotations[NameOfStates[[i]]];
];
Print["Done"];
Print["-----------------------------------------------------------------"];
Print[""];
i++;];
];

CheckFlavorDecomp[ES_]:=Block[{i,j,list,pos},
Print["Checking flavor decomposition of ",ES];
list = DEFINITION[ES][Flavors];
For[i=1,i<=Length[list],

For[j=1,j<=Length[list[[i,2]]],
Switch[getTypeOld[list[[i,1]]],
F,
	pos = Position[SA`QNfermion,list[[i,1]]][[1,1]];
	SA`QNfermion = Join[SA`QNfermion, {{list[[i,2,j]],SA`QNfermion[[pos]][[2]]}}];,
S,
	pos = Position[SA`QNscalar,list[[i,1]]][[1,1]];
	SA`QNscalar = Join[SA`QNscalar, {{list[[i,2,j]],SA`QNscalar[[pos]][[2]]}}];
];
j++;];
i++];
];

CheckRotationsGauge[ES_]:=Block[{i,j,charges,list,entry,flist},

Print["--------------- Checking rotations in gauge sector ----------------- "];

flist = DEFINITION[ES][GaugeSector] ;
list = DEFINITION[ES][GaugeSector] /. A_[b_Integer]->A;

For[i=1,i<=Length[list],
If[getTypeOld[list[[i,1,1]]]===F,
charges=getChargesAndRParity/@list[[i,1]];
For[j=1,j<=Length[list[[i,2]]],
Print["Checking mixing of ",flist[[i,1]], " to ",list[[i,2,j]]];
CheckConservationMixing[ES,charges,getRParity[list[[i,2,j]],ES],flist[[i,1]],list[[i,2,j]]];
j++;];
];
i++];
];


CheckRotationsGaugeOld[ES_]:=Block[{i,j,k,charges,list,entry,flist,basis},

Print["--------------- Checking rotations in gauge sector ----------------- "];

temp = DEFINITION[ES][GaugeSectorOld] ;
basis={};
For[i=1,i<=Length[temp],
basis=Join[basis,
{{Table[temp[[i,1]][temp[[i,j,1]]],{j,2,Length[temp[[i]]]}],Intersection[Flatten[Table[Table[temp[[i,k,j,1]],{j,2,Length[temp[[i,k]]]}],{k,2,Length[temp[[i]]]}]]]}}];
i++;];
Print[basis];
flist=basis;
list = basis/. A_[b_Integer]->A;

For[i=1,i<=Length[list],
If[getTypeOld[list[[i,1,1]]]===F,
charges=getChargesAndRParity/@list[[i,1]];
For[j=1,j<=Length[list[[i,2]]],
Print["Checking mixing of ",flist[[i,1]], " to ",list[[i,2,j]]];
CheckConservationMixing[ES,charges,getRParity[list[[i,2,j]],ES],flist[[i,1]],list[[i,2,j]]];
j++;];
];
i++];
];


CheckRotations[ES_]:=Block[{i,j,k,charges, charges2,fs},
Print["--------------- Checking field rotations for Eigenstates ", ES,"-------------------"];
entry=MixBasis[ES];

For[i=1,i<=Length[entry],
If[Head[MixedNames[ES][[i]]]===List,
Print["Checking mixing of ",entry[[i,1]], " to ",MixedNames[ES][[i,1,1]]];
charges=getChargesAndRParity/@entry[[i,1]];
CheckConservationMixing[ES,charges,getRParity[MixedNames[ES][[i,1,1]],ES],entry[[i,1]],MixedNames[ES][[i,1,1]]];
Print["Checking mixing of ",entry[[i,2]], " to ",MixedNames[ES][[i,2,1]]];
charges=getChargesAndRParity/@entry[[i,2]];
CheckConservationMixing[ES,charges,getRParity[MixedNames[ES][[i,2,1]],ES],entry[[i,1]],MixedNames[ES][[i,2,1]]];,
If[getType[MixedNames[ES][[i]]]=!=A,
Print["Checking mixing of ",entry[[i,1]], " to ",MixedNames[ES][[i]]];
charges=getChargesAndRParity/@entry[[i,1]];
CheckConservationMixing[ES,charges,getRParity[MixedNames[ES][[i]],ES] ,entry[[i,1]],MixedNames[ES][[i]]];
];
];
i++;];
];

CheckConservationMixing[ES_,charges_,finalrpv_,ifields_,ffields_]:=Block[{j,i,temp,charges2},
charges2 = Table[charges[[i,j]],{j,1,Length[Gauge]+1},{i,1,Length[charges]}]; 
For[i=1,i<=Length[Gauge],
If[Gauge[[i,2]]=!=U[1],charges2[[i]] = charges2[[i]] /. -1 ->1 /.{ -(Gauge[[i,2,1]]^2-1)->(Gauge[[i,2,1]]^2-1),-2->2};];
i++;];


For[j=1,j<=Length[Gauge],
If[FreeQ[BrokenGaugeSymmetries[ES],j],
If[Length[Intersection[charges2[[j]]]]>1,
Mixing::DifferentQN="Fields `` have different quantum numbers with respect to \" `` \" and can't mix";
Message[Mixing::DifferentQN,ifields,Gauge[[j,3]]];,
Print["    ... mixing allowed by quantum number with respect to \"" ,Gauge[[j,3]],"\" invariance"];
];
];
j++;];

(*
If[RParityConservation\[Equal]True,
If[Length[Intersection[charges2[[-1]]]]>1,
Mixing::DifferentRParity="Particles `` have different R-Parity and can't mix as long as R-Parity is conserved.";
Message[Mixing::DifferentRParity,ifields];,
Print["    ... mixing allowed by R-Parity conservation"];
If[Intersection[charges2[[-1]]][[1]]=!=finalrpv,
Mixing::RParityDifferent="The given R-parity of the mixed state `` (``) is different than the one for the basis states `` (``)";
Message[Mixing::RParityDifferent,ffields,finalrpv,ifields,Intersection[charges2[[-1]]][[1]]];
];
];
];
*)

If[Head[ffields]===conj,
chargesC={Join[-Take[charges[[1]],{1,3}],{charges[[1,4]]}]};,
chargesC=charges;
]; 

Switch[getTypeOld[ffields],
F,
	SA`QNfermion = Join[SA`QNfermion,{{RE[ffields],chargesC[[1]]}}];,
S,
	SA`QNscalar = Join[SA`QNscalar,{{RE[ffields],chargesC[[1]]}}];,
A,
	SA`QNaux = Join[SA`QNaux,{{RE[ffields],chargesC[[1]]}}];
];

];

getChargesAndRParity[field_]:=Block[{conjQ,temp,res,pos,type,charges},
If[Head[field]===conj,conjQ=True; temp=field[[1]];, temp = field;];
Switch[getTypeOld[temp],
F,
	pos = Position[SA`QNfermion,temp][[1,1]];
	charges = Drop[SA`QNfermion[[pos]],1];,
S,
	pos = Position[SA`QNscalar,temp][[1,1]];
	charges = Drop[SA`QNscalar[[pos]],1];,
A,
	pos = Position[SA`QNaux,temp][[1,1]];
	charges = Drop[SA`QNaux[[pos]],1];
];
charges=charges[[1]];
If[conjQ==True,
charges = - charges;
charges[[-1]]=-charges[[-1]];
];
Return[charges];

];


CheckVEVs[ES_]:=Block[{i,j,entry,charges},
entry=DEFINITION[ES][VEVs];

For[i=1,i<=Length[entry],
Print["Checking decomposition of",entry[[i,1]]];
pos=Position[SA`QNscalar,entry[[i,1]]][[1,1]];
charges = Drop[SA`QNscalar[[pos]],1][[1]];
For[j=1,j<=Length[Gauge],
If[entry[[i,2,1]]=!=0 &&  entry[[i,2,2]]=!=0,
If[(FreeQ[BrokenGaugeSymmetries[ES],j] && Gauge[[j,2]]===U[1] && charges[[j]]=!=0) || (FreeQ[BrokenGaugeSymmetries[ES],j] && Gauge[[j,2,0]]===SU && Abs[charges[[j]]]=!=1),
VEV::UnbrokenSymmetries="Particle `` charged under unbroken gauge group \" `` \" receives VEV";
Message[VEV::UnbrokenSymmetries,entry[[i,1]],Gauge[[j,3]]];,
If[FreeQ[BrokenGaugeSymmetries[ES],j],
Print["    ... does not break \"",Gauge[[j,3]],"\" "];
];
];
];
j++];

(*
If[entry[[i,2,1]]=!=0 &&  entry[[i,2,2]]=!=0 &&  RParityConservation\[Equal]True,
If[charges[[-1]]===-1 && RParityConservation\[Equal]True,
VEV::BreaksRParity="Particle `` has R-parity -1 and receives VEV.";
Message[VEV::BreaksRParity,entry[[i,1]]];,
Print["    ... does not break R-Parity"];
];
];
*)
If[Length[entry[[i]]]===5,
If[Length[entry[[i,5]]]===2,
For[j=4,j<=5,
SA`QNscalar = Join[SA`QNscalar,{Join[{entry[[i,j,1]]},{charges}]}];
j++];,
For[j=3,j<=4,
SA`QNscalar = Join[SA`QNscalar,{Join[{entry[[i,j,1]]},{charges}]}];
j++];
];,
For[j=3,j<=4,
SA`QNscalar = Join[SA`QNscalar,{Join[{entry[[i,j,1]]},{charges}]}];
j++];
];

i++;];

];

CheckParticleDefinitionsFinal:=Block[{i,ES},
For[i=1,i<=Length[NameOfStates],
Print["Checking particle definitions for ", NameOfStates[[i]]];
ES = NameOfStates[[i]];
MakeTypeListParticles[NameOfStates[[i]]];

allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]],Transpose[PART[G]][[1]]}];

Print["    checking for particles not defined in particles.m"];
missingParticle=Select[allParticleNames,(FreeQ[Transpose[ParticleDefinitions[ES]][[1]],#]&)];
If[missingParticle=!={},Message[CheckModelFiles::MissingParticle,missingParticle];];

Print["    checking for missing OutputNames"];
missingOutputNames=Select[allParticleNames,(getOutputName[#,1,1]===None)&];
If[missingOutputNames=!={},Message[CheckModelFiles::MissingOutputName,missingOutputNames];];

(* If[RParityConservation\[Equal]True, *)
If[FreeQ[Global,RParity]==False,
Print["    checking for defned R-Parity"];
CheckModelFiles::MissingRParity = "R-Parity for particles `` has not been defined";
missingRParity=Select[allParticleNames,(getRParity[#,ES]===None || getRParity[#,ES]===RParity)&];
If[missingRParity=!={},Message[CheckModelFiles::MissingRParity,missingRParity];];
];

Print["    checking PDGs"];
allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]]}];
missingPDG=Select[allParticleNames,((getFla[#]*getGen[#]=!=Length[getPDG[#]]&&getPDG[#]=!=None)&)];
missingPDG=Select[missingPDG,(FreeQ[SGauge,#]||Length[getPDG[#]]<1)&];
missingPDG=Select[missingPDG,(FreeQ[FGauge/.diracSubBack1[ES]/.diracSubBack2[ES],#]||Length[getPDG[#]]<1)&];
If[missingPDG=!={},Message[CheckModelFiles::WrongPDG,missingPDG];];

Print["    checking Length of OutputNames"];
longNames=Select[allParticleNames,((StringLength[ToString[getOutputName[#,1,1]]]+(getRParity[#,ES] /. {1->0,-1->1}))>8)&];
If[longNames=!={},
ParticleNames::TooLong="The OutputNames of the following particles are too long for an valid CalcHep output: ``";
Message[ParticleNames::TooLong,longNames];
];

Print["    checking for OutputNames defined twice"];
twiceNames=Select[getOutputName[#]&/@ allParticleNames,(Count[getOutputName[#]&/@ allParticleNames,#]>1)&];
If[twiceNames=!={},
ParticleNames::DefinedTwice="The following OutputNames are used serveral times: ``";
Message[ParticleNames::DefinedTwice,Intersection[twiceNames]];
temp=Intersection[twiceNames];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[allParticleNames,(getOutputName[#]===temp[[j]])&]];
j++;];
];

Print["    checking for FeynArts numbers"];
allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]],Transpose[PART[G]][[1]]}];
noFANr=Select[allParticleNames,(getEntryField[#,FeynArtsNr]===FeynArtsNr || getEntryField[#,FeynArtsNr] ===None)&];
If[noFANr=!={},
FeynArts::NN="No FeynArts number defined for ``";
Message[FeynArts::NN,noFANr];
];

Print["    checking for FeynArts numbers used several times"];
Print["      ... Fermions"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[F]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},
Message[FeynArts::NumberDefinedTwiceF,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[F]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
 ];
Print["      ... Scalars"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[S]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},
Message[FeynArts::NumberDefinedTwiceS,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[S]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
];
Print["      ... Vector Bosons"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[V]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},Message[FeynArts::NumberDefinedTwiceV,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[V]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
];
Print["      ... Ghosts"];
temp = getEntryField[#,FeynArtsNr]&/@ Transpose[PART[G]][[1]];
twiceFR = Select[temp,(Count[temp,#]>1)&];
If[twiceFR=!={},Message[FeynArts::NumberDefinedTwiceG,Intersection[twiceFR]];
temp=Intersection[twiceFR];
For[j=1,j<=Length[temp],
Print["            ",temp[[j]]," :",Select[Transpose[PART[G]][[1]],(getEntryField[#,FeynArtsNr]===temp[[j]])&]];
j++;];
 ];

If[i===Length[NameOfStates],
Print["Checking definition of electric charge for final eigenstates"]; 
Print["This information is only needed for the CalcHep, MadGraph and SPheno output"];
allParticleNames=Flatten[{Transpose[PART[F]][[1]],Transpose[PART[V]][[1]],Transpose[PART[S]][[1]],Transpose[PART[G]][[1]]}];
noEC=Select[allParticleNames,(getEntryField[#,ElectricCharge]===ElectricCharge || getEntryField[#,ElectricCharge] ===None)&];
If[noEC=!={},
Model::NoEC="No electric charge defined for ``";
Message[Model::NoEC,noEC];
];
i++;];

i++;];




];




CheckParameterDefinitionsFinal:=Block[{i,missingParticle={},missingParameter={},missingPDG={},missingLHparameter={},allParticleNames,allParameterNames,missingOutputNames},Print["Checking parameter definitions"];
allParameterNames=Transpose[parameters][[1]];

Print["    checking for parameters not defined in parameters.m"];
missingParameter=Select[allParameterNames,((FreeQ[Transpose[ParameterDefinitions][[1]],#] && Head[#]=!=Mass)&)];
If[missingParameter=!={},Message[CheckModelFiles::MissingParameter,missingParameter];];

Print["    checking LesHouches names"];
missingLHparameter=Select[allParameterNames,(Head[getLHBlockName[#]]===None)&];
If[missingLHparameter=!={},Message[CheckModelFiles::MissingLH,missingLHparameter];];

Print["    checking for missing OutputNames"];
missingOutputNameParameter=Select[allParameterNames,(getEntryParameter[#,OutputName]===None && Head[#]=!=Mass)&];
If[missingOutputNameParameter=!={},Message[CheckModelFiles::MissingOutputNameParameter,missingOutputNameParameter];];


Print["    checking Length of OutputNames"];
longNames=Select[allParameterNames,((StringLength[ToString[getEntryParameter[#,OutputName]]]+ Length[getDimParameters[#]/. {1}->{} /. {0}->{}])>8)&];
If[longNames=!={},
ParameterNames::TooLong="The OutputNames of the following parameters are too long for an valid CalcHep output: ``";
Message[ParameterNames::TooLong,longNames];
];

Print["    checking for OutputNames defined twice"];
twiceNames=Select[getEntryParameter[#,OutputName]&/@ allParameterNames,(Count[getEntryParameter[#,OutputName]&/@ allParameterNames,#]>1)&];
If[twiceNames=!={},
ParameterNames::DefinedTwice="The following OutputNames are used serveral times: ``";
Message[ParameterNames::DefinedTwice,Intersection[twiceNames]];
temp=Intersection[twiceNames];
For[i=1,i<=Length[temp],
Print["            ",temp[[i]]," :",Select[allParameterNames,(getEntryParameter[#,OutputName]===temp[[i]])&]];
i++;];
];

(*
Print["    checking for OutputNames which are already occupied"];
SPhenoInternalNames = {RHO, LAMBDA};
*)

];

CheckMassMatrices:=Block[{i,mat},
For[i=1,i<=Length[NameOfStates],
If[Head[MassMatrices[NameOfStates[[i]]]]===List,
Print["Checking mass matrices for eigenstates ",NameOfStates[[i]]];
mat=MassMatrices[NameOfStates[[i]]];

For[j=1,j<=Length[mat],
If[getTypeOld[MixedNames[NameOfStates[[i]]][[j]]]=!=A,
Print[ "   Checking matrix for ",MixBasis[NameOfStates[[i]]][[j]]];
If[Intersection[Flatten[mat[[j]]]]==={0},
Message[MassMatrix::OnlyZero,MixBasis[NameOfStates[[i]]][[j]]];,
Print[ "   ...  contains non zero-elements"];
];

If[CheckReducibility[mat[[j]]]===False,
Print[ "   ...  seems not to be reducible"];,
MassMatrix::Reducible="Mass matrix of `` seems to be reducible";
Message[MassMatrix::Reducible,MixBasis[NameOfStates[[i]]][[j]]];
Print[ "   ...  contains non zero-elements"];
];
];
j++;];
];
i++;];
];


CheckParticleMixing[ES_]:=Block[{i,j,temp,pos,partS,partF,partV,vert},
Off[General::stop];
partS=Flatten[Take[#,1]&/@Select[Particles[ES],(#[[4]]===S)&]];
partF=Intersection[Flatten[Take[#,1]&/@Select[Particles[ES],(#[[4]]===F)&]]/. diracSubBack[ES] /. bar[x_]->x];
partV=Flatten[Take[#,1]&/@Select[Particles[ES],(#[[4]]===V)&]];

(*
partS=Transpose[Select[Particles[ES],(#[[4]]===S)&]][[1]];
partF=Intersection[Transpose[Select[Particles[ES],(#[[4]]===F)&]][[1]] /. diracSubBack[ES] /. bar[x_]\[Rule]x];
partV=Transpose[Select[Particles[ES],(#[[4]]===V)&]][[1]];
*)

Lagrangian::PossibleMixing="Possible mixing between `` and `` induced by the term: ``";

For[i=1,i<=Length[partS],
For[j=i+1,j<=Length[partS],
vert=FullSimplify[Vertex[{partS[[i]],partS[[j]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partS[[i]],partS[[j]],vert];
(* Print["Possible mixing between ",partS[[i]], " and ",partS[[j]]]; 
Print["    term :",vert]; *),
vert=FullSimplify[Vertex[{partS[[i]],conj[partS[[j]]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partS[[i]],conj[partS[[j]]],vert];
(* Print["Possible mixing between ",partS[[i]], " and ",conj[partS[[j]]]]; 
Print["    term :",vert]; *)
];
];
j++;];
i++;];

For[i=1,i<=Length[partF],
For[j=i+1,j<=Length[partF],
vert = FullSimplify[(Vertex[{partF[[i]],partF[[j]]},Eigenstates->ES]//. subAlways //. subDependences)];
If[Length[vert]===3,
vert=FullSimplify[vert[[2,1]]+vert[[3,1]]];,
vert=FullSimplify[vert[[2,1]]];
];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partF[[i]],partF[[j]],vert];
(* Print["Possible mixing between ",partF[[i]], " and ",partF[[j]]]; 
Print["    term :", vert]; *),
vert = FullSimplify[(Vertex[{bar[partF[[i]]],partF[[j]]},Eigenstates->ES]//. subAlways //. subDependences)];
If[Length[vert]===3,
vert=FullSimplify[vert[[2,1]]+vert[[3,1]]];,
vert=FullSimplify[vert[[2,1]]];
];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partF[[i]],conj[partF[[j]]],vert];
(* Print["Possible mixing between ",partF[[i]], " and ",conj[partF[[j]]]]; 
Print["    term :",vert]; *)
];
];
j++;];
i++;];

For[i=1,i<=Length[partV],
For[j=i+1,j<=Length[partV],
vert=FullSimplify[Vertex[{partV[[i]],partV[[j]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partV[[i]],partV[[j]],vert];
(* Print["Possible mixing between ",partV[[i]], " and ",partV[[j]]]; 
Print["    term :",vert];*),
vert=FullSimplify[Vertex[{partV[[i]],conj[partV[[j]]]},Eigenstates->ES][[2,1]]//. subAlways //. subDependences];
If[vert=!=0,
Message[Lagrangian::PossibleMixing,partV[[i]],conj[partV[[j]]],vert];
(* Print["Possible mixing between ",partV[[i]], " and ",conj[partV[[j]]]]; 
Print["    term :",vert]; *)
];
];
j++;];
i++;];

On[General::stop];
];


CheckReducibility[mat_]:=Block[{i,j,k,l,dim1,dim2,zeroC,zeroR,NZC,NZR,k1,k2,newC, newR,irred=False,startold, startnew,count0=0},
(* dim=Length[mat]; *)
dim1=Dimensions[mat][[1]];
dim2=Dimensions[mat][[2]];

For[i=1,i<=dim1,
For[j=1,j<=dim2,
If[mat[[i,j]]=!=0,
NZEC[i,j] = Flatten[Position[Transpose[mat][[j]],x_?((#=!=0 && #=!=List)&)]];
NZER[i,j] = Flatten[Position[mat[[i]],x_?((#=!=0 && #=!=List)&)]];,
NZEC[i,j] = {};
NZER[i,j] = {};
count0++;
];
j++;];
i++;];

For[i=1,i<=dim1,
For[j=1,j<=dim2,
If[mat[[i,j]]=!=0,
newC = Table[{NZEC[i,j][[k]],j},{k,1,Length[NZEC[i,j]]}];
newR = Table[{i,NZER[i,j][[k]]},{k,1,Length[NZER[i,j]]}];
startnew=Intersection[Join[newC,newR]];
iter=0;
While[Length[startold]=!=Length[startnew],
iter=iter+1;
startold=startnew;
startnew={};
For[l=1,l<=Length[startold],
newC = Table[{NZEC[startold[[l,1]],startold[[l,2]]][[k]],startold[[l,2]]},{k,1,Length[NZEC[startold[[l,1]],startold[[l,2]]]]}];
newR = Table[{startold[[l,1]],NZER[startold[[l,1]],startold[[l,2]]][[k]]},{k,1,Length[NZER[startold[[l,1]],startold[[l,2]]]]}];
startnew=Join[startnew,Intersection[Join[newC,newR]]];
l++;];
startnew=Intersection[startnew];
];

If[Length[startnew]<(dim^2 - count0),
irred = True;
];

];
j++;];
i++;];

Return[irred];

];
