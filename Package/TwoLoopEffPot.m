(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
getColorFactorEffPot[fields_]:=Block[{i,j,k,pos,unbroken,uc,ucname,Indices,IndexRanges,ucIndices,ucFunction,totalgfunc,toprocess,ind,tempf,namestub,nind,Res},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "getColorFactorEffPot";
SA`Doc`Info = "Calculates the colour factor of a two-loop diagram without external legs. Written by K. Nickel.";
SA`Doc`Input = {"fields"->"Involved particles in diagram"};
SA`Doc`GenerateEntry[];


pos=Position[VerticesInv[All],C@@fields]/.Cp->C;
fieldsordered=VerticesOrg[All][[pos[[1,1]]]];
vertex=VerticesVal[All][[pos[[1,1]]]];
If[Length[vertex]==0,Return[0]];
IndexRanges=getIndizesWI/@fieldsordered;
Indices=fieldsordered//.{_[b_]->b};
If[Length[fields]===4,sub4=subfourpoint,sub4={}];
totalgfunc=1;
toprocess=vertex;
ind={};
For[uc=1,uc<=Length[dataUnBrokenGaugeGroups],uc++,ucname=dataUnBrokenGaugeGroups[[uc,2]];
ucFunction=ExtractStructure[toprocess,ucname]/.Lam[a__]->1/2 Lam[a];
ucFunction=Select[ucFunction,#[[2,1]]=!=0&][[1]];
(*Keep only the first one*)
tempf=ucFunction[[1]];
If[Length[fields]==3,totalgfunc=totalgfunc*tempf*conj[tempf],totalgfunc*=tempf];
toprocess={ucFunction[[2,1]]};
ucIndices=Select[#,FreeQ[#,ucname]==False&]&/@IndexRanges/.{ucname,a_Integer}->a;
namestub=StringTake[ToString[dataUnBrokenGaugeGroups[[uc,2]]],1];
For[j=1,j<=3,j++,If[(ucIndices[[j]]=!={})&&(Length[fields]<4||j<3),AppendTo[ind,{ToExpression[namestub<>"t"<>ToString[j]],1,ucIndices[[j,1]]}]]];];
If[Length[fields]==4,totalgfunc=totalgfunc/.sub4];
nind=ind/.{{a__}->a};
Res={};
If[ind!={},AppendTo[Res,ReleaseHold[Hold[Sum[totalgfunc,IND]]/.IND->nind]],AppendTo[Res,totalgfunc]];
SA`Doc`Return[Res]];




(* ::Input::Initialization:: *)
DiracQ[p_]:=Block[{temp},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "getColorFactorEffPot";
SA`Doc`Info = "Checks if a particle is a Dirac fermion. Written by K. Nickel";
SA`Doc`Input = {"p"->"considered particle"};
SA`Doc`GenerateEntry[];

temp=Select[DiracList,#[[1]]===(p/.{conj[a_]->a,bar[a_]->a})&];
If[!temp==={},
If[temp[[1,2]]===2,Return[True]];
];
SA`Doc`Return[False];
];


(* ::Input::Initialization:: *)
ConjugateDiagramsQ[diag1_,diag2_]:=Block[{type},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "ConjugateDiagramsQ";
SA`Doc`Info = "Checks if two two-loop Diagram are related by a conjugation. Written by K. Nickel";
SA`Doc`Input = {"diag1"->"First Diagram", "diag2"->"Second Diagram"};
SA`Doc`GenerateEntry[];

(*type=3: Hemisphere topology, type=2: Balls topology*)
type=Length[diag1[[2]]];
If[type===3,
SA`Doc`Return[diag1[[1,1]]===diag2[[1,1]]||diag1[[1,2]]===diag2[[1,1]]];,
SA`Doc`Return[diag1[[1,1]]===diag2[[1,1]]];
];
];


(* ::Input::Initialization:: *)
getDiracFermionList:=Block[{i,fermionlist={},ListSubstituteBack={},AllDiracFermions,name},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "getDiracFermionList";
SA`Doc`Info = "Returns a list with all Fermions in Dirac notation. Written by K. Nickel";
SA`Doc`GenerateEntry[];

(*gives a list of Dirac spinors, neglect conjugates*)
fermionlist={#[[1]],#[[2]]}&/@DEFINITION[EWSB][DiracSpinors]//.{conj[a_]->a};
(*remove duplicates among Weyl spinors*)
fermionlist={#[[1]],Intersection[#[[2]]]}&/@fermionlist;
(*remove zeros (eg. the RH Neutrino part) *)
fermionlist={#[[1]],Select[#[[2]],!#===0&,2]}&/@fermionlist;
(*determine mutliplicity (1=Majorana/Weyl, 2=Dirac) *)
fermionlist=Intersection[Append[#,Length[#[[2]]]]&/@fermionlist];
ListSubstituteBack=Flatten[(name=#[[1]];Rule[#,name]&/@#[[2]])&/@fermionlist];
AllDiracFermions=Intersection[AllFermions/.ListSubstituteBack];
For[i=1,i<=Length[AllDiracFermions],i++;,
AllDiracFermions[[i]]=Append[AllDiracFermions[[i]],fermionlist[[i,3]]];
];
SA`Doc`Return[AllDiracFermions];
];


(* ::Input::Initialization:: *)
Generate2LoopDiagramsHemisphere:=Block[{top2LoopHemispheres,insHemispheres,reducedHemispheres},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "Generate2LoopDiagramsHemisphere";
SA`Doc`Info = "Generates all two-loop diagrams without external legs and two  cubic couplings. Written by K. Nickel ";
SA`Doc`GenerateEntry[];

(* there are two topologies, called "Hemispheres" and "Balls" *)
top2LoopHemispheres={{C[FieldToInsert[1],FieldToInsert[2],FieldToInsert[3]],C[AntiField@FieldToInsert[1],AntiField@FieldToInsert[2],AntiField@FieldToInsert[3]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2],Internal[3]->FieldToInsert[3]}};
(* Insert Fields *)
insHemispheres=InsFields[top2LoopHemispheres];
(* remove conjugate diagrams to avoid double counting *)
reducedHemispheres=Intersection[insHemispheres,SameTest->ConjugateDiagramsQ];
SA`Doc`Return[reducedHemispheres];
];
Generate2LoopDiagramsBalls:=Block[{top2LoopBalls,insBalls},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "Generate2LoopDiagramsBalls";
SA`Doc`Info = "Generates all two-loop diagrams without external legs and a single quartic coupling. Written by K. Nickel ";
SA`Doc`GenerateEntry[];

(* there are two topologies, called "Hemispheres" and "Balls" *)
top2LoopBalls={{C[FieldToInsert[1],FieldToInsert[2],AntiField[FieldToInsert[1]],AntiField[FieldToInsert[2]]]},{Internal[1]->FieldToInsert[1],Internal[2]->FieldToInsert[2]}};
(* Insert Fields *)
insBalls=InsFields[top2LoopBalls];
SA`Doc`Return[insBalls];
];


(* ::Input::Initialization:: *)
getType2LoopDiagram[diagram_]:=Block[{NrCoupParticles,p1,p2,p3,type={}},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "getType2LoopDiagram";
SA`Doc`Info = "Returns the type of a two-loop diagrams without external legs. Written by K. Nickel.";
SA`Doc`Input = {"diagram"->"Considered Diagram"};
SA`Doc`GenerateEntry[];

NrCoupParticles=Length/@diagram;
Switch[NrCoupParticles,
{2,3},
p1=Internal[1]/.diagram[[2]];
p2=Internal[2]/.diagram[[2]];
p3=Internal[3]/.diagram[[2]];
Switch[getType[p1],
S,
Switch[getType[p2],
S,
If[getType[p3]===S,
type=SSS;,
type=SSV;];,
F,
type=FFS;,
V,
If[getType[p3]===S,
type=SSV;,
type=VVS;];
];,
F,
Switch[getType[p2],
S,
type=FFS;,
F,
If[getType[p3]===S,
type=FFS;,
type=FFV;];,
V,
type=FFV;
];,
V,
Switch[getType[p2],
S,
If[getType[p3]===S,
type=SSV;,
type=VVS;];,
F,
type=FFV;,
V,
If[getType[p3]===S,
type=VVS;,
type=VVV;];,
G,
type=ggV;
];,
G,
type=ggV;
];,
{1,2},
p1=Internal[1]/.diagram[[2]];
p2=Internal[2]/.diagram[[2]];
If[getType[p1]===S,
If[getType[p2]===S,
type=SS;,
type=VS;
];,
If[getType[p2]===S,
type=VS;,
type=VV;
];
];
];
SA`Doc`Return[type];
];


(* ::Input::Initialization:: *)
Classify2LoopDiagrams[diagrams_]:=Block[{diagram,temp,bare,listSSS,listSS,listFFS,listFFSbar,listSSV,listVS,listVVS,listFFV,listFFVbar,listVV,listVVV,listggV},
SA`Doc`File = "Package/TwoLoopEffPot.nb";
SA`Doc`Name = "Classify2LoopDiagrams";
SA`Doc`Info = "Creates lists with all diagrams containing to a generic class. Written by K. Nickel.";
SA`Doc`Input = {"diagrams"->"List of all existing diagrams"};
SA`Doc`GenerateEntry[];

listSSS={SSS,Select[diagrams,getType2LoopDiagram[#]===SSS&]};
listSS={SS,Select[diagrams,getType2LoopDiagram[#]===SS&]};
listFFS={FFS,Select[diagrams,getType2LoopDiagram[#]===FFS&]};
listFFSbar={FFSbar,Select[listFFS[[2]],TwoEqualFermionsQ]};
listSSV={SSV,Select[diagrams,getType2LoopDiagram[#]===SSV&]};
listVS={VS,Select[diagrams,getType2LoopDiagram[#]===VS&]};
listVVS={VVS,Select[diagrams,getType2LoopDiagram[#]===VVS&]};
listFFV={FFV,Select[diagrams,getType2LoopDiagram[#]===FFV&]};
listFFVbar={FFVbar,Select[listFFV[[2]],TwoEqualFermionsQ]};
listVV={VV,Select[diagrams,getType2LoopDiagram[#]===VV&]};
listVVV={VVV,Select[diagrams,getType2LoopDiagram[#]===VVV&]};
listggV={ggV,Select[diagrams,getType2LoopDiagram[#]===ggV&]};
temp={listSSS,listSS,listFFS,listFFSbar,listSSV,listVS,listVVS,listFFV,listFFVbar,listVV,listVVV,listggV};
SA`Doc`Return[temp];
];
