(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* ------------------------------------*)
(* Complex Conjugation                 *)
(* ------------------------------------*)


(* ::Input::Initialization:: *)

conj[IU]:=-IU;
conj[x_Rule]:=conj/@x;
conj[x_Plus]:=conj/@x;
conj[x_Times]:=conj/@x;
conj[x_Power]:=conj/@x;
conj[x_List]:=conj/@x;
conj[x_?NumericQ]:=Conjugate[x];
conj[x_]:=x /; (MemberQ[realVar,x] ||MemberQ[realHeads,Head[x]] || MemberQ[realVar,Head[x]] || MemberQ[realHeads,Head[x]])  && (Head[x]=!=Pattern) && (Head[Head[x]]=!=Pattern);
conj[x_conj]:=Plus@@x;
(* conj[x_RXi]:=RXi[conj[x[[1]]]]; *)
conj[x_RXi]:=RXi[x[[1]]];
conj[x_Mom]:=Mom[conj[x[[1]]],x[[2]]];
conj[x_Der]:=Der[conj[x[[1]]],x[[2]]];


bar[x_Rule]:=bar/@x;
bar[x_Plus]:=bar/@x;
bar[x_Times]:=bar/@x;
bar[x_Power]:=bar/@x;
bar[x_List]:=bar/@x;
bar[x_?NumericQ]:=conj[x[[1]]];
bar[x_]:=x /; (MemberQ[MajoranaPart,x] ||MemberQ[MajoranaPart,Head[x]] || MemberQ[realHeads,x] || MemberQ[realHeads,Head[x]]) && (Head[x]=!=Pattern) && (Head[Head[x]]=!=Pattern);
bar[x_Mom]:=Mom[bar[x[[1]]],x[[2]]];
bar[x_Der]:=Der[bar[x[[1]]]];
bar[x_bar]:=Plus@@x;  

Kronecker[a_,b_]^c_ ^=Kronecker[a,b];

JustReturn[x_]:=x;


RE[x_Times]:=RE /@ x;
RE[x_Rule]:=RE /@ x;
RE[x_List]:=RE /@ x;
RE[x_Power]:=RE /@ x;
RE[x_Plus]:=RE /@ x;
RE[x_conj]:= Plus@@x;
RE[x_bar]:=Plus@@x;
RE[x_]:=x;

bar[a_][{b__}]:=bar[a[{b}]];

(*
Unprotect[InverseFunction];
InverseFunction[conj]=conj; 
 Protect[InverseFunction]; *)

InverseFunction[conj]^=conj;



(* ::Input::Initialization:: *)
(* ------------------------------------*)
(* Derivatives                 *)
(* ------------------------------------*)

genf[x_]:=ToExpression["gen"<>ToString[x]];
adjind[g_,x_]:=ToExpression["a"<>StringTake[ToString[Gauge[[g,3]]],3]<>ToString[x]];
colf[x_]:=ToExpression["col"<>ToString[x]];
intf[x_]:=ToExpression["int"<>ToString[x]];
intf[nr_,x_]:=ToExpression["i"<>ToString[nr]<>"0"<>ToString[x]];
nf[x_]:=ToExpression["n"<>ToString[x]];
lorf[x_]:=ToExpression["lor"<>ToString[x]];
cintf[x_]:=ToExpression["cint"<>ToString[x]];
tNr[x_]:=ToExpression["t" <> ToString[x]];
ctNr[x_]:=ToExpression["ct" <> ToString[x]];
ltNr[x_]:=ToExpression["lt" <> ToString[x]];

ADI[x_]:=If[Gauge[[x,5]]===True, Return[generation];,Return[getAdjointIndex[Gauge[[x,3]]]];];

intP=0;
genMax=4;

(* All kind of derivatives for the different cases *)

DP[term_,particle_]:=Sum[D[term,getFull[particle]/.subGC[i],{i,1,genMax}]];

DPF[term_,particle1_,particle2_,fnr_]:=Sum[(D[term,particle1 /.subGC[i] ]*(particle2[fnr] /. subGC[i]) /. {GetGen[getBlank[particle1]] ->GetGen[getBlank[particle2]],GetGenStart[getBlank[particle1]] ->GetGenStart[getBlank[particle2]]}),{i,1,genMax}]; 

DMM[term_,particle_,number__,name_,fnr_]:=Block[{i,j,res, temp, part,ind},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "DMM";
SA`Doc`Info = "Second deriative to get the an entry in a mass matrix for given external fields.";
SA`Doc`Input={"term"->"The part of the Lagrangian","particle"->"The considered particle","number"->"Numbering the involved states","name"->"a name for the final index","fnr"->"fermion number"};
SA`Doc`GenerateEntry[];


If[getType[particle]===F,part=getFull[particle][fnr];,part=getFull[particle];];
ind=DeleteCases[getIndizes[particle],generation];
SA`Doc`Return[Sum[D[term,part /.subGC[i]]  /.Flatten[(Table[sum[ind[[j]]/. subGC[i],a_,b_]->1,{j,1,Length[ind]}] )]/.Table[If[FreeQ[ind,AuxGauge[[j,3]]],(AuxGauge[[j,3]]/. subGC[i])->(AuxGauge[[j,3]]/. subGC[i+4]),1->1],{j,1,Length[UnbrokenSubgroups]}]/. subIndFinalX[i,number,name] /.subFinalX /.(Table[sum[ind[[j]],a_,b_]->1,{j,1,Length[ind]}] /. subGC[i]),{i,1,genMax}]];
];

DPV[term_,particle_,t_,fermpos_]:=Block[{part,i,ind},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "DPV";
SA`Doc`Info = "A derivative used to get the vertex. It's iterated for all external particles involved in the vertex.";
SA`Doc`Input={"term"->"The part of the Lagrangian","particle"->"The considered particle","t"->"Numbering the involved states","fermpos"->"fermion position"};
SA`Doc`GenerateEntry[];


ind=getIndizes[particle];
If[getType[particle]===F,part=getFull[particle][fermpos];,part=getFull[particle];];
If[Length[getIndizes[particle]]==0 && (OnesChecked==True),
SA`Doc`Return[D[term,part]];,
(* Return[Plus@@Table[D[term,part /. subGC[i]] /. subIndFinal[i,t],{i,1,genMax}]]; *)
SA`Doc`Return[Plus@@Table[D[term,part/. subGC[i]] /. Select[subIndFinal[i,t],FreeQ[ind/.subGC[i],#[[1]]]==False&] ,{i,1,genMax}]];
]; 
];

DFTerms[term_,particle_]:=Block[{i,j,res,temp, fact},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "DFTerms";
SA`Doc`Info = "A derivative function used to calculate F-Terms";
SA`Doc`Input={"term"->"The part of the Lagrangian","particle"->"The considered particle"};
SA`Doc`GenerateEntry[];


res=0;
temp=0;
For[i=1,i<=genMax,
temp+= D[term,particle /.subGC[i]] /. subGCInt[i] /.subGCRE[3,i];
auxP=D[term,particle /.subGC[i]] (getAuxScalar[particle] /.subGC[i]);
LagrangianAux -= (auxP +conj[auxP])I;
i++;];
res+=temp*(conj[temp] /.Flatten[Table[subGCRE[i,2+i],{i,1,2}]]) ;
SA`Doc`Return[res];
];

DIntOut[term_,particle_]:=Block[{i,j,res, fact, temp2},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "DIntOut";
SA`Doc`Info = "A derivative function used to effective operators by integrating out a given particle.";
SA`Doc`Input={"term"->"The part of the Lagrangian","particle"->"The considered particle"};

SA`Doc`GenerateEntry[];

temp=0;
effOp=0;
If[getType[particle]===F,
part=particle[2];,
part=particle;
];
For[i=1,i<=genMax,
temp+= D[term,part  /.subGC[i]] /. subIndFinalX[i,1,"IO"] /. subGCRE[genMax,i] /.sum[gIO1,a_,b_]->1;
i++;];
temp2=(temp /.subGCRE[1,4] /.subGCRE[2,5] /.subGCRE[3,6]);
If[getType[particle]===F,
temp2=temp2 /. {A_[1]->A[2], L1->L3, L2->L4};
If[MemberQ[MajoranaPart,getBlank[particle] /.diracSubBack1]==True ,
effOp=  temp*conj[temp2]+(conj[temp]/.{A_[1]->A[2]})(temp2/.{A_[2]->A[1]})+temp*temp2+(temp/.{A_[1]->A[2]})(temp2/.{A_[2]->A[1]});,
effOp = temp*conj[temp2]+(conj[temp]/.{A_[1]->A[2]})(temp2/.{A_[2]->A[1]}); 
];,
temp2=temp2 /. {A_[1]->A[3],A_[2]->A[4]};
If[conj[particle]===particle,
effOp= temp*conj[temp2]+(conj[temp]/.{A_[1]->A[2],A_[2]->A[1]})(temp2/.{A_[3]->A[4],A_[4]->A[3]})+ temp*temp2+(temp/.{A_[1]->A[2],A_[2]->A[1]})(temp2/.{A_[3]->A[4],A_[4]->A[3]}); ,
effOp = temp*conj[temp2]+(conj[temp]/.{A_[1]->A[2],A_[2]->A[1]})(temp2/.{A_[3]->A[4],A_[4]->A[3]}); 
];
];

SA`Doc`Return[effOp];
];


(* ::Input::Initialization:: *)

(* ------------------------------------ *) 
(* Special Functions *)
(* ------------------------------------ *)

ParameterQ[x_]:=If[FreeQ[Transpose[parameters][[1]],x]==True, Return[False];,Return[True];];

Delta[a_,a_]:=1;
Delta[a_Integer,b_Integer]:=If[a==b,1,0];
Delta[a_,0]:=0;
Delta[0,a_]:=0;  

Unprotect[Power];
Power[Delta[a_,b_],c_]:=Delta[a,b] /; (c>0);
Power[sum[a_,b_,c_],_]:=sum[a,b,c];
Protect[Power];

SetAttributes[Delta,Orderless] ;



(* ::Input::Initialization:: *)
(* -------------------------------------- *)
(* List Manipulation *)
(* -------------------------------------- *)



(* ::Input::Initialization:: *)

getList[x_,y_,z_]:=Block[{pos},
pos=Position[y,x];
Return[Extract[z,pos[[1,1]]]];
];

SimplifySARAH[x_List]:=SimplifySARAH/@x;
SimplifySARAH[x_Plus]:=SimplifySARAH/@x;
SimplifySARAH[x_]:=makeSumAll[CalcDelta[x /. subAlways]];

SimplifySARAHnd[x_List]:=SimplifySARAHnd/@x;
SimplifySARAHnd[x_Plus]:=SimplifySARAHnd/@x;
SimplifySARAHnd[x_]:=makeSumAll[CalcDelta[x /.DeleteCases[subAlways,y_?((FreeQ[#,sum]==False)&)]]];

LHBlockName[x_]:=Block[{pos,temp},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "LHBlockName";
SA`Doc`Info = "Returns the block of a parameter in a Les Houches file.";
SA`Doc`Input={"x"->"The considered parameter"};
SA`Doc`GenerateEntry[];

diesisteintest;
(* If[FreeQ[parameters,x],Return[SPhenoForm[x]]]; *)
pos=Position[Transpose[SA`LHList][[1]],x];
If[pos==={}, 
If[Head[x]===Mass,SA`Doc`Return["None"];];
If[SkipLHMessage=!=True,Message[Parameter::NoLesHouches,x];];
SA`Doc`Return["None"];
];
temp=SA`LHList[[pos[[1,1]],2]];
If[Head[temp]===List,
SA`Doc`Return[ToUpperCase[ToString[temp[[1]]]]];,
SA`Doc`Return[ToUpperCase[ToString[temp]]];
];
];

LHPos[x_]:=Block[{pos,temp},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "LHPos";
SA`Doc`Info = "Returns the position of a parameter in its block in a Les Houches file.";
SA`Doc`Input={"x"->"The considered parameter"};
SA`Doc`GenerateEntry[];


pos=Position[Transpose[SA`LHList][[1]],x];
If[pos==={},SA`Doc`Return["1"];];
temp=SA`LHList[[pos[[1,1]],2]];
If[Head[temp]===List,
SA`Doc`Return[ToString[Last[temp]]];,
SA`Doc`Return["1"];
];
];

getScalarToVEV[f_]:=Block[{i,j,temp,pos},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "getScalarToVEV";
SA`Doc`Info = "Return the VEV associated with a scalar";
SA`Doc`Input={"f"->"The considered field"};
SA`Doc`GenerateEntry[];

For[i=1,i<=Length[NameOfStates],
If[FreeQ[DEFINITION[NameOfStates[[i]]][VEVs],f]==False,
temp=DEFINITION[NameOfStates[[i]]][VEVs];
];
i++;];
pos=Position[temp,f][[1,1]];
SA`Doc`Return[temp[[pos,4,1]]];
];

getBasisToVEV[vev_]:=Block[{i,j,temp,scalar},
SA`Doc`File = "Package/mathFunctions.nb";
SA`Doc`Name = "getBasisToVEV";
SA`Doc`Info = "Returns the complex scalar associated with a VEV";
SA`Doc`Input={"vev"->"The considered VEV"};
SA`Doc`GenerateEntry[];

scalar=getScalarToVEV[vev];
For[i=1,i<=Length[NameOfStates],
If[FreeQ[DEFINITION[NameOfStates[[i]]][MatterSector],scalar]==False,
temp=DEFINITION[NameOfStates[[i]]][MatterSector];
];
i++;];
pos=Position[temp,scalar][[1,1]];
SA`Doc`Return[temp[[pos,1]]];
];

(* Transpose only lists which can be tranposed*)
TransposeChecked[x_]:=Block[{},
If[Depth[x]<3,
Return[{{}}];,
Return[Transpose[x]];
];
];



