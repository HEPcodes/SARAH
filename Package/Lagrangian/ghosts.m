(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
CalcGaugeTransformations:=Block[{i,j},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "CalcGaugeTransformations";
SA`Doc`Info = "Generates a list with the gauge transformation properties of all fields, i.e. phi -> tilde{D}_mu phi where tilde{D}_mu is the covariant deriative with ghosts instead of vector bosons. The approach to get the ghost interactions in that way is taken from hep-ph/9902340, sec. 3.6 \n
	  Some special care is needed for unbroken subgroups of larger gauge groups. ";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];


PrintDebug["Calc Gauge Transformations"];
Print["Calculate gauge transformations: ",Dynamic[DynamicGaugeTNr],"/",AnzahlChiral+Length[Gauge]," (",Dynamic[DynamicGaugeTName],")"];

GaugeTransformation={};

For[i=1,i<=Length[Gauge],
DynamicGaugeTNr=i;
DynamicGaugeTName=SGauge[[i]];
PrintDebug["   ",SGauge[[i]]];
ai=ADI[i];

(*
GaugeTransformation=Join[GaugeTransformation,{{(SGauge[[i]]/.subGC[1]),Gauge[[i,4]] getStructureConstant[i,ai /. subGC[1],ai /. subGC[2],ai /. subGC[3]] part[gGauge[[i]],2] part[SGauge[[i]],3]}}]; *)
GTnew={(SGauge[[i]]/.subGC[1]),Gauge[[i,4]] getStructureConstant[i,ai/.subGC[1],ai/.subGC[2],ai/.subGC[3]] part[gGauge[[i]],2] part[SGauge[[i]],3]};
GaugeTransformation=Join[GaugeTransformation,{GTnew}];
(*H*)(*If the gauge group has an non-abelian unbroken subroup,then the Gauge Transformations are translated using the new VB*)
If[AuxGaugesPresent===True&&GaugeListAux[[i,1]]===True,posAux=Position[UnbrokenSubgroups,Gauge[[i,3]]][[1,1]];
GaugeTransformation=Join[GaugeTransformation,Table[{RepGaugeBosons[[posAux,k,1]][GTnew[[1]][[1]]],SplitGhostsAuxFabc[(SplitGaugeBosonsAuxFabc[GTnew[[2]]])/.{gen1->gen1+Sum[RepGaugeBosons[[posAux,n,2]],{n,1,k-1}]}]},{k,1,Length[RepGaugeBosons[[posAux]]]}]];
];
i++;];

For[i=1,i<=AnzahlChiral,
DynamicGaugeTNr=i+Length[Gauge];
DynamicGaugeTName=SFields[[i]];
PrintDebug["   ",SFields[[i]]];
If[SFields[[i]]=!=0,
temp= - (I KovariantGhost[i,1,2,3])*part[SFields[[i]],2];
If[temp=!=0,
gaugeT=Flatten[SumOverIndizesGhost[SumOverExpandedIndizes[temp,{None,Fields[[i,3]]}],{Fields[[i,3]]}]] /.subFieldsOne;,
gaugeT=0;
];
(* If[Dimensions[SFieldsMultiplets[[i]]]=!={1}, *)
If[Head[SFieldsMultiplets[[i]]]===List,
(* withoutNum=Flatten[DeleteCases[SFieldsMultiplets[[i]],x_?NumberQ,4]]; *)
withoutNum=Flatten[DeleteCases[SFieldsMultiplets[[i]],x_?NumberQ,{2,4}]] /. 0->1; (* changed 16/11/16: before {3,4} *)
withNum=Flatten[SFieldsMultiplets[[i]]];
NumFac=withNum/withoutNum;
invF=Map[getFull,withoutNum] /. subGC[1];
For[j=1,j<=Length[invF],
If[NumericQ[invF[[j]]]===False,
(*H*)(*If AuxGaugesPresent, one has to rewrite e.g.gPS\[Rule]gG,gX,gY,gS*)
If[AuxGaugesPresent===True,
GaugeTransformation=Join[GaugeTransformation,{{invF[[j]],NumFac[[j]]SplitGhostsAux[gaugeT[[j]]]}}];,
GaugeTransformation=Join[GaugeTransformation,{{invF[[j]],NumFac[[j]]gaugeT[[j]]}}];
];
];
j++;];,
If[AuxGaugesPresent===True,
GaugeTransformation=Join[GaugeTransformation,{{SFieldsMultiplets[[i]],SplitGhostsAux[gaugeT]}}];,
GaugeTransformation=Join[GaugeTransformation,{{SFieldsMultiplets[[i]],gaugeT}}];
];
];
];
i++;];

GaugeTransformation=EleminateSumsOfFields[GaugeTransformation];
DynamicGaugeTName="All Done";
GaugeTransformation=DeleteCases[GaugeTransformation,{_,_,0}] /.{GetGen -> getGen,GetGenStart->getGenStart};
SA`Doc`EndEntry[];
];


EleminateSumsOfFields[list_]:=Block[{i,j,tempNoSum={},tempSum={},res,field1,field2,coeff1,coeff2,pos},

SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "EleminateSumsOfFields";
SA`Doc`Info = "For cases in which the gauge transformations are only obtained for the sum of two fields, one needs to work out how the transformation looks for a single field. I.e. we use 'delta(phi_1+phi_2) = delta phi_1 + delta_phi_2 = X' and solve it for 'delta phi_1 = X - delta phi_2' under the assumption that 'delta phi_2' is known.";
SA`Doc`Input={"list"->"A list with all gauge transformations"};
SA`Doc`GenerateEntry[];

Print["Eleminate sums"];
If[Length[list]>1,
If[FreeQ[Transpose[list][[1]],Plus]===False,
For[i=1,i<=Length[list],
If[Head[list[[i,1]]]===Plus,
tempSum=Join[tempSum,{list[[i]]}];,
tempNoSum=Join[tempNoSum,{list[[i]]}];
];
i++;];
For[i=1,i<=Length[tempSum],
field1=DeleteCases[tempSum[[i,1,1]],x_?NumberQ,{1,4}] /. 0->1/. Delta[a__]->1; 
coeff1=tempSum[[i,1,1]]/field1/. Delta[a__]->1;
field2=DeleteCases[tempSum[[i,1,2]],x_?NumberQ,{1,4}] /. 0->1/. Delta[a__]->1; 
coeff2=tempSum[[i,1,2]]/field2/. Delta[a__]->1;
If[FreeQ[Transpose[tempNoSum][[1]],field1]===False,
pos=Position[Transpose[tempNoSum][[1]],field1][[1,1]];
tempNoSum=Join[tempNoSum,{{field2,(tempSum[[i,2]]-coeff1 tempNoSum[[pos]][[2]])/coeff2}}];,
pos=Position[Transpose[tempNoSum][[1]],field2][[1,1]];
tempNoSum=Join[tempNoSum,{{field1,(tempSum[[i,2]]-coeff2 tempNoSum[[pos]][[2]])/coeff1}}];
];
i++;];
res=tempNoSum;,
res=list;];,
res=list;
];
SA`Doc`EndEntry[];
Return[res];
];



(* ::Input::Initialization:: *)

UpdateGaugeTransformations[sub_,subInv_,nameUGT_]:=Block[{i,temp},

SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "UpdateGaugeTransformations";
SA`Doc`Info = "Updates the gauge transformation properties of fields after changing the basis of the fields (i.e. via rotation to mass eigenstates, CP splitting, etc).";
SA`Doc`Input={"sub"->"The replacement rules to rotate fields", "subInv"->"the inverse rotation", "namesUGT"->"a name for the considered transformation. (Affects only the screen output)"};
SA`Doc`GenerateEntry[];

Print["   Update gauge transformations: ",Dynamic[DynamicUGT[nameUGT]],"/",Length[Particles[Current]]," (",Dynamic[DynamicUGTname[nameUGT]],")"];
PrintDebug["   Update gauge transformations"];

If[sub=!={} ,
NewGaugeTransformation={};
For[i=1,i<=Length[Particles[Current]],
DynamicUGTname[nameUGT]=Particles[Current][[i,1]];
DynamicUGT[nameUGT]=i;
PrintDebug[Particles[Current][[i,1]]];
If[Particles[Current][[i,4]]===S || Particles[Current][[i,4]]===V,
temp = DeltaGT[ReplaceAll[replaceGen[ReleaseHold[getFull[Particles[Current][[i,1]]] /.subGC[1] /. subInv /. gen1->pre1],rgNr], gen1->tem1]];
rgNr++;
NewGaugeTransformation=Join[NewGaugeTransformation,{{Particles[Current][[i,1]],(replaceGen[ReleaseHold[temp/. sub],rgNr] /.pre1->gen1 /.tem1->int10  )}}];
];
i++;];
DynamicUGTname[nameUGT]="All Done";
GaugeTransformation=DeleteCases[NewGaugeTransformation,{_,_,0}] /.{GetGen -> getGen,GetGenStart->getGenStart};
];

SA`Doc`EndEntry[];
];

UpdateGaugeTransformationsTensorToVector[sub_]:=Block[{i,j,temp},

SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "UpdateGaugeTransformationsTensorToVector";
SA`Doc`Info = "Special routine to handle fields in the adjoint representation of unbroken subgroups of a larger group which gets broken (e.g. SU(4)->SU(3)). The gauge transformations are rewritten from tensor to vector notation. ";
SA`Doc`Input={"sub"->"A substitution rule to bring the tensor representation into a vector representation. Works only for the adjoint representation so far."};
SA`Doc`GenerateEntry[];

Print["   Update gauge transformations"];
PrintDebug["   Update gauge transformations"];

For[j=1,j<=Length[sub],
NewGaugeTransformation={};
For[i=1,i<=Length[GaugeTransformation],
If[FreeQ[GaugeTransformation[[i,1]],sub[[j,1]]],
NewGaugeTransformation=Join[NewGaugeTransformation,{{GaugeTransformation[[i,1]],GaugeTransformation[[i,2]]/.sub[[j,2,3]]}}];,
NewGaugeTransformation=Join[NewGaugeTransformation,{{sub[[j,2,2]],sub[[j,2,4,1]]( GaugeTransformation[[i,2]]/. sub[[j,2,4,2]])}}];
];
i++;];
GaugeTransformation=DeleteCases[NewGaugeTransformation,{_,_,0}] /.{GetGen -> getGen,GetGenStart->getGenStart};
j++;];

SA`Doc`EndEntry[];
];

KovariantGhost[fieldNr_,p1_,p2_, LorNr_]:=Block[{i,temp, gauge, gaugeNr,gNr,gNr2},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "KovariantGhost";
SA`Doc`Info = "Writes down the 'covariant derivative' with ghost fields, i.e .the usually covariant derivative of scalars is used but the vectors are replaced by ghosts. ";
SA`Doc`Input={"fieldNr"->"The position of the considered particle in the array 'Fields'","p1"->"An index for the first particle", "p2"->"An index for the second particle","LorNr"->"A lorentz index"};
SA`Doc`GenerateEntry[];

temp=0;
For[gNr=1,gNr<=AnzahlGauge,
If[FieldDim[fieldNr,gNr]=!=0 || Gauge[[gNr,2]]===U[1] ,
temp += part[gGauge[[gNr]],LorNr] getGenerator[gNr,FieldDim[fieldNr,gNr],LorNr,p1,p2]*
Gauge[[gNr,4]] makeDelta[fieldNr,p1,p2,{Gauge[[gNr,3]]}];
If[Gauge[[gNr,2]]===U[1] && NoU1Mixing=!=True,
For[gNr2=1,gNr2<=AnzahlGauge,
If[Gauge[[gNr2,2]]===U[1] && gNr2!= gNr,
temp +=  part[gGauge[[gNr]],LorNr] getGenerator[gNr2,FieldDim[fieldNr,gNr2],LorNr,p1,p2]*
GaugesU1[gNr2,gNr] makeDelta[fieldNr,p1,p2,{Gauge[[gNr,3]]}];
];
gNr2++;
];
];
];
gNr++;];

SA`Doc`EndEntry[];
Return[temp];
];


SumOverIndizesGhost[term_,partList_]:=Block[{j,i,temp, temp1,pos,suffix,nr},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "SumOverIndizesGhost";
SA`Doc`Info = "Performs the explicit summation of the gauge indices corresponding to broken gauge groups, i.e. 'sum_i H_i' becomes 'H_1 + H_2' if 'i' s for instance an isospin index. ";
SA`Doc`Input={"term"->"The considered term","partList"->"A list with particles involved in the considered term"};
SA`Doc`GenerateEntry[];

IndexNames={};
For[i=1,i<=Length[partList],
If[partList[[i]]=!=None,
pos=Position[ListFields,partList[[i]]][[1,1]];
For[j=1,j<=Length[ListFields[[pos,2]]],
(* IndexNames = Join[IndexNames,ListFields[[pos,2,2]] /. subGC[i]]; *)
If[Head[GaugeListAux]===List,
(* For the case that there is an unbroken Subgroup, one has not to sum over 1..4 for SU(4) instance, but only for 1..2 and 2 contains then the 3 unbroken color charges; that's checked here *)
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],If[GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],1]]=!=True,ListFields[[pos,2,2,j,2]],GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],2]]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];,
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],ListFields[[pos,2,2,j,2]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];
];
(* IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],ListFields[[pos,2,2,j,2]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]]; *)
j++;];
];
i++;];
temp=term;
For[i=1, i<=Length[IndexNames],
If[AuxGaugesPresent===True,
If[GaugeListAux[[Position[Gauge,getIndexFamilyName[IndexNames[[i,1]]]][[1,1]],1]]===True,
suffix=If[StringLength[ToString[IndexNames[[i,1]]]]===4,"",StringTake[ToString[IndexNames[[i,1]]],{-1}]];
If[FreeQ[UnbrokenSubgroups,getIndexFamilyName[ IndexNames[[i,1]]]]===False,
temp=temp//.ReplacementRuleAux[ IndexNames[[i,1]]];
];
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[i]]};
(* get the numbering of the field summed over *)
nr=ToExpression[StringTake[ToString[IndexNames[[i,1]]],{4}]];
(* temp=ReleaseHold[ReleaseHold[ temp1]]/. subGeneratorAux//.  UnbrokenSubgroups[[1,2]]-> (IndexNames[[i,1]] /. subNamesAux); *)
temp=ReleaseHold[ReleaseHold[ temp1]]/. subGeneratorAux//.   subGC[nr] //. SUFFIX[a_]:>ToExpression[ToString[a]<>suffix]/. DELTAaux->Delta /. EPSaux->epsTensor/.SUMaux->sum;,
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[i]]};
temp=ReleaseHold[temp1];
];,
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[Length[IndexNames]-i+1]]};
temp=ReleaseHold[temp1];
];
i++;];

SA`Doc`EndEntry[];
Return[temp];

];






DeltaGT[x_]:=Block[{},
If[Head[x]==List,erg=List@@x;erg=DeltaGT/@erg;Return[List@@erg];];
If[Head[x]==Times,erg=List@@x;erg=DeltaGT/@erg;Return[Times@@erg];];
If[Head[x]==Plus,erg=List@@x;erg=DeltaGT/@erg;Return[Plus@@erg];];
If[Head[x]==Power,erg=List@@x;erg=DeltaGT/@erg;Return[Power@@erg];];
If[Head[x]==conj,erg=List@@x;erg=DeltaGT/@erg;Return[conj@@erg];];
If[Head[x]==Mom,Return[x];];
If[Head[x]==Der,Return[Der[DeltaGT[x[[1]]],lor3]];];

SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "DeltaGT";
SA`Doc`Info = "Generates a gauge transformation of a given term. ";
SA`Doc`Input={"x"->"The considered term which should be transformed"};
SA`Doc`GenerateEntry[];


If[MemberQ[vacuum,x] || MemberQ[vacuum,Head[x]],
If[Length[x]==0,
If[FreeQ[Transpose[GaugeTransformation][[1]],x],Print[x," not found"];];
pos=Position[Transpose[GaugeTransformation][[1]],x][[1,1]];
If[Head[GaugeTransformation[[pos]][[1]]]===conj,
SA`Doc`Return[conj[Extract[GaugeTransformation,pos][[2]]]];,
SA`Doc`Return[Extract[GaugeTransformation,pos][[2]]];
];,
If[FreeQ[Transpose[GaugeTransformation][[1]],Head[x]],Print[Head[x]," not found"];];
pos=Position[Transpose[GaugeTransformation][[1]],Head[x]][[1,1]];
If[Head[GaugeTransformation[[pos]][[1]]]===conj,
SA`Doc`Return[conj[Extract[GaugeTransformation,pos][[2]]/.gen1->x[[1,1]]]];,
SA`Doc`Return[Extract[GaugeTransformation,pos][[2]]/.gen1->x[[1,1]]];
];
];,
SA`Doc`Return[x];
];
];




(* ::Input::Initialization:: *)
CalcGhostLagrangian[GaugeFixing_]:=Block[{i,GaugeFixingTemp},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "CalcGhostLagrangian";
SA`Doc`Info = "Calculates the ghost interactions from the gauge transformation properties of scalars and the gauge fixing terms in R_xi gauge. The result is stored in the ghost Lagrangian 'LGhost'. Moreover, an list with Goldstone bososn and the corresponding vector bosons is generated (sorry, the name 'GoldstoneGhost' is misleading! It might good to rename it).";
SA`Doc`Input={"GaugeFixing"->"The gauge fixing terms"};
SA`Doc`GenerateEntry[];

GaugeFixingTemp = GaugeFixing /. Der[a_]->Der[a,lor2];

subGhostC={};
For[i=1,i<=Length[Particles[Current]],
If[(getType[Particles[Current][[i,1]]]==G) && (MemberQ[realVar,Particles[Current][[i,1]]]==False),
If[StringTake[ToString[Particles[Current][[i,1]]],-1]==="C",
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[StringDrop[ToString[Particles[Current][[i,1]]],-1]][{x}]}];,
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[ToString[Particles[Current][[i,1]]]<>"C"][{x}]}];
];
];

i++;]; 

Print["Calc Ghost Interactions"];

LGhost=0;
For[i=1,i<=Length[GaugeFixing],
GaugeFixingFactor[makeGhost[conj[GaugeFixingTemp[[i,1]]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[makeGhost[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[ExtractGaugeField[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];

LGhost +=(GaugeFixing[[i,2]] /. RXi[a__]->1)(bar[partBlank[makeGhost[conj[GaugeFixingTemp[[i,1]]]],1]]*(DeltaGT[conj[GaugeFixingTemp[[i,1]]]] /.subGhostC)+bar[partBlank[makeGhost[GaugeFixingTemp[[i,1]]],1]]*(DeltaGT[GaugeFixingTemp[[i,1]]] /.subGhostC));
i++;];

LGhost = - LGhost;


GoldstoneGhost={};

For[i=1,i<=Length[GaugeFixing],
parts=Cases[GaugeFixing[[i,1]] /. conj[y_]->y,x_?ParticleQ,2];
For[j=1,j<=Length[parts],
If[getType[parts[[j]]]===S,
If[FreeQ[GaugeFixing[[i,1]] ,conj[parts[[j]]]],
GoldstoneGhost = Join[GoldstoneGhost,{{ExtractGaugeField[GaugeFixing[[i,1]]] ,parts[[j]]}}];,
GoldstoneGhost = Join[GoldstoneGhost,{{ExtractGaugeField[GaugeFixing[[i,1]]] ,conj[parts[[j]]]}}];
];
];
j++;];
i++;
];


SA`Doc`EndEntry[];
];


(* ::Input::Initialization:: *)

makeGhost[x_]:=Block[{temp,ghostp},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "makeGhost";
SA`Doc`Info = "Returns the ghost particle assoicated with a vector boson appearing in a given term of the kinetic part of the Lagrangian. ";
SA`Doc`Input={"x"->"The considered Vector boson"};
SA`Doc`GenerateEntry[];

If[Head[x]===Plus,
temp=List@@x;,
temp={x};
];
ghostp=Select[temp,(Head[#]==Der)&,2][[1,1]];

SA`Doc`EndEntry[];
Return[getGhost[ghostp]];
];

ExtractGaugeField[x_]:=Block[{temp,ghostp},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "ExtractGaugeField";
SA`Doc`Info = "Returns the vector boson appearing in a given term of the kinetic part of the Lagrangian. ";
SA`Doc`Input={"x"->"The considered term"};
SA`Doc`GenerateEntry[];

If[Head[x]===Plus,
temp=List@@x;,
temp={x};
];
ghostp=Select[temp,(Head[#]==Der)&,2][[1,1]];

SA`Doc`EndEntry[];
Return[ghostp];
];




(* ::Input::Initialization:: *)
GenerateGaugeFixing[kinetic_,name_,nr_]:=Block[{scalars,gb,temp={}, res,i,j,nameXi,num,un},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "GenerateGaugeFixing";
SA`Doc`Info = "Generates the gauge fixing terms in R_xi gauge from the kinetic terms for scalars. The gauge fixing terms are obtained by the condition, that the mixing between vector bososn and scalars vanishes at tree-level. \n
Also here special care is needed to handle unbroken subgroups (i.e. AuxGauge). This has blown up the routine quite a bit.";
SA`Doc`Input={"kinetic"->"The kinetic terms in the scalar sector", "name"->"The name of the considered eigenstates (e.g. 'EWSB')","nr"->"Position of the current eigenstates in the list 'NameOfStates'"};
SA`Doc`GenerateEntry[];


If[Head[DEFINITION[name][GaugeFixing]]===List,
GaugeFixing::Defined="Since version 3.1.0 SARAH derives the gauge fixing terms by itself. The given input in the model file is longer necessary and it will be ingored.";
Message[GaugeFixing::Defined];
];

gb = SA`NewGaugeBosons;
gb =Select[Particles[Current],(#[[4]]===V)&];
gb=Transpose[gb][[1]];
scalars=Select[Particles[Current],(#[[4]]===S)&];
If[scalars=!={},
scalars=Transpose[scalars][[1]];
];

(*H*)(*If there are auxilary gauges,the gauge bosons of the broken gauge group stay in Particles[Currents] at this stage,hece are removed from the list gb*)
If[AuxGaugesPresent===True,
For[un=1,un<=Length[UnbrokenSubgroups],
gb=Delete[gb,Position[gb,ToExpression["V"<>ToString[Gauge[[Position[Gauge,UnbrokenSubgroups[[un,1]]][[1,1]]]][[1]]]]][[1,1]]];
un++;];
];

CalcImp=True;
Update[];

Print["  ... generate gauge fixing terms: ",Dynamic[DynamicGFnr[name]],"/",Length[gb]," (",Dynamic[DynamicGFname[name]],")"];

(*H*)(*If AuxGaugesPresent,then the all the vector bosons corresponding to the (later) broken group have to have the same RXi name if at the group is not broken yet as that stage*)(*How to find out if the group is already broken or not?Apparently "BrokenSymmetries" assigns a gauge group as broken if some of the corresponding gauge bosons are mentioned in DEFINITION[NameOfStates][GaugeSector],I will use the same approach.These gauge bosons are already singled out in subGauge,so I will use this fact.The corresponding VB will be "marked"*)
markedVB={};
If[AuxGaugesPresent===True,VBbr=Table[Head[subGauge[[i,1]]],{i,1,Length[subGauge]}];
For[unb=1,unb<=Length[UnbrokenSubgroups],
unbName=Gauge[[Position[Gauge,UnbrokenSubgroups[[unb,1]]][[1,1]]]][[1]];
VBunb=Table[RepGaugeBosons[[unb,k,1]],{k,1,Length[RepGaugeBosons[[unb]]]}];
If[Sort[Intersection[VBunb,gb]]==Sort[VBunb]&&Intersection[VBunb,VBbr]=={},
markedVB=Join[markedVB,Table[{VBunb[[k]],unbName},{k,1,Length[VBunb]}]]];
unb++;
];
];

For[i=1,i<=Length[gb],
DynamicGFnr[name]=i;
DynamicGFname[name]=gb[[i]];
PrintDebug["   ",gb[[i]]];
res=0;
If[conj[gb[[i]]]===gb[[i]],num=2;,num=1;];
(*H*)
posMarked=Position[markedVB,gb[[i]]];
If[posMarked=={},
nameXi=RXi[ToExpression[StringDrop[ToString[gb[[i]]],1]]];,
nameXi=RXi[markedVB[[posMarked[[1,1]],2]]];
num=2;(*Since these gauge fixing terms come from the bigger gauge group,they inherit the 1/2 factor.Attention! If RepGaugeBosons included conj[VX],then it is not true!!!!*)
];
If[getEntryField[gb[[i]],Mass]=!=0,
For[j=1,j<=Length[scalars],
If[MemberQ[realVar,scalars[[j]]]===MemberQ[realVar,gb[[i]]], (* new in order to prevent unncessary calculations *)
If[DeleteCases[getIndizes[scalars[[j]]],generation]===DeleteCases[DeleteCases[getIndizes[gb[[i]]],lorentz],generation],
res+=DPV[DPV[kinetic /. vacuumF /. Select[vacuumS,FreeQ[#,scalars[[j]]]&]/. Select[vacuumV,FreeQ[#,gb[[i]]]&]/. zero[_][_]->0 /. zero[_]->0,conj[gb[[i]]],1,1]/. vacuumV /. zero[_][_]->0 /. zero[_]->0,scalars[[j]],2,2] /. vacuumS /. zero[_][_]->0 /. zero[_]->0 /. Mom[a_,b_] /;(getType[a]===NoField)->0  /. Mom[a_,b_]->a /. g[a__]->1 /. gen1->gn1 /. gen2->gn2 /.gt1->gen1 /. gt2->gen2 /.Delta[__,lt1]->1;
If[conj[scalars[[j]]]=!=scalars[[j]],
res+=DPV[DPV[kinetic /. vacuumF  /. Select[vacuumS,FreeQ[#,scalars[[j]]]&] /. Select[vacuumV,FreeQ[#,gb[[i]]]&]/. zero[_][_]->0 /. zero[_]->0,conj[gb[[i]]],1,1]/. vacuumV /. zero[_][_]->0 /. zero[_]->0,conj[scalars[[j]]],2,2] /. vacuumS /. zero[_][_]->0 /. zero[_]->0 /. Mom[a_,b_] /;(getType[a]===NoField)->0  /. Mom[a_,b_]->a /. g[__]->1 /. gen1->gn1 /. gen2->gn2 /.gt1->gen1 /. gt2->gen2/.Delta[__,lt1]->1;
];
];
];
j++;];
res= CalcDelta[res /. Delta[a__]/;(FreeQ[{a},gen1] ==False || FreeQ[{a},gen2] ==False)->DELTAGEN[a] ] /. DELTAGEN->Delta ;,
res=0;
];
temp=Join[temp,{{Der[gb[[i]]]+res*nameXi,-1/(num nameXi)}}];
SA`GaugeFixingRXi = Join[SA`GaugeFixingRXi,{{nameXi,gb[[i]]}}];
i++;];
DynamicGFname[name]="All Done";
CalcImp=False;
SA`GaugeFixingRXi = Intersection[SA`GaugeFixingRXi];

temp=temp /. subAlways /.gn2->gn1;

DEFINITION[name][GeneratedGaugeFixing]=temp;

SA`Doc`EndEntry[];
Return[temp];
];


CalcGhostLagrangian2[GaugeFixing_]:=Block[{i,Rxi,vb},

SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "CalcGhostLagrangian2";
"Calculates the ghost interactions from the gauge transformation properties of scalars and the gauge fixing terms in R_xi gauge. The result is stored in the ghost Lagrangian 'LGhost'. This is a newer version of 'CalcGhostLagrangian'.";
SA`Doc`Input={"GaugeFixing"->"The gauge fixing terms"};
SA`Doc`GenerateEntry[];

GaugeFixingTemp = GaugeFixing /. Der[a_]->Der[a,lor2];

subGhostC={};
For[i=1,i<=Length[Particles[Current]],
If[(getType[Particles[Current][[i,1]]]==G) && (MemberQ[realVar,Particles[Current][[i,1]]]==False),
If[StringTake[ToString[Particles[Current][[i,1]]],-1]==="C",
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[StringDrop[ToString[Particles[Current][[i,1]]],-1]][{x}]}];,
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[ToString[Particles[Current][[i,1]]]<>"C"][{x}]}];
];
];

i++;]; 

Print["  ... calculate Ghost interactions"];

LGhosttemp=0;
LGhostSS=0;
For[i=1,i<=Length[GaugeFixing],
Rxi=Cases[GaugeFixing[[i,2]],x_?((Head[#]==RXi)&),6][[1]];
vb=Cases[{GaugeFixing[[i,1]]},x_?((Head[#]==Der)&),6][[1,1]];
GaugeFixingFactor[makeGhost[conj[GaugeFixingTemp[[i,1]]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[makeGhost[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[ExtractGaugeField[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
LGhosttemp +=(GaugeFixing[[i,2]] /. RXi[a__]->1)(bar[partBlank[makeGhost[conj[GaugeFixingTemp[[i,1]]]],1]]*(DeltaGT[conj[GaugeFixingTemp[[i,1]]]] /.subGhostC)+bar[partBlank[makeGhost[GaugeFixingTemp[[i,1]]],1]]*(DeltaGT[GaugeFixingTemp[[i,1]]] /.subGhostC));
If[vb===conj[vb],
LGhostSS+=(GaugeFixing[[i,1]] /. Der[a__]->0/.(Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]]))*conj[(GaugeFixing[[i,1]] /. Der[a__]->0 )/.Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]] /. subGCRE[1,3]/.subGCRE[2,4]]/Rxi/2;,
LGhostSS+=(GaugeFixing[[i,1]] /. Der[a__]->0/.(Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]]))*conj[(GaugeFixing[[i,1]] /. Der[a__]->0 /.Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]] /. subGCRE[1,3]/.subGCRE[2,4])]/Rxi;
];
saveGF=GaugeFixing[[i,1]];
i++;];

(* LGhost = (LGhost /. SA`RemovedGaugeBosons /. SA`RemovedGhosts)- LGhosttemp; *)

LGhost = -LGhosttemp;

SA`Doc`EndEntry[];
];

CheckGoldstoneGhosts[name_]:=Block[{i,GaugeFixing,pos,vb},
SA`Doc`File = "Package/Lagrangian/ghosts.nb";
SA`Doc`Name = "CheckGoldstoneGhosts";
SA`Doc`Info = "Generates a list with the Goldstone bosons associated with a massive vector boson. (Sorry, the name is mistleading because it doesn't involve Ghosts).";
SA`Doc`Input={"name"->"name of the considered eigenstates (e.g. 'EWSB')"};
SA`Doc`GenerateEntry[];


GoldstoneGhost={};

vb=Select[Particles[name],(#[[4]]==V)&];

For[i=1,i<=Length[vb],
If[getEntryField[vb[[i,1]],Goldstone]===Goldstone || getEntryField[vb[[i,1]],Goldstone]===None,
 If[getEntryField[vb[[i,1]],Mass]=!=0 && FreeQ[SGauge,vb[[i,1]]] && FreeQ[RepGaugeBosons,vb[[i,1]]],
(* Print["No Goldstone for massive vector boson defined ", vb[[i,1]]]; *)
Message[ModelFile::NoGoldstone,vb[[i,1]]];
];,
GoldstoneGhost=Join[GoldstoneGhost,{{vb[[i,1]],getEntryField[vb[[i,1]],Goldstone]}}];
];
i++;];

SA`Doc`EndEntry[];
];
