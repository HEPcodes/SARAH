(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
CalcGaugeTransformations:=Block[{i,j},

PrintDebug["Calc Gauge Transformations"];
Print["Calculate gauge transformations: ",Dynamic[DynamicGaugeTNr],"/",AnzahlChiral+Length[Gauge]," (",Dynamic[DynamicGaugeTName],")"];

GaugeTransformation={};

For[i=1,i<=Length[Gauge],
DynamicGaugeTNr=i;
DynamicGaugeTName=SGauge[[i]];
PrintDebug["   ",SGauge[[i]]];
ai=ADI[i];

(*
GaugeTransformation=Join[GaugeTransformation,{{(SGauge[[i]]/.subGC[1]),Gauge[[i,4]] getStructureConstant[i,ai /. subGC[1],ai /. subGC[2],ai /. subGC[3]] part[gGauge[[i]],2] part[SGauge[[i]],3]}}]; *)
GTnew={(SGauge[[i]]/.subGC[1]),Gauge[[i,4]] getStructureConstant[i,ai/.subGC[1],ai/.subGC[2],ai/.subGC[3]] part[gGauge[[i]],2] part[SGauge[[i]],3]};
GaugeTransformation=Join[GaugeTransformation,{GTnew}];
(*H*)(*If the gauge group has an non-abelian unbroken subroup,then the Gauge Transformations are translated using the new VB*)
If[AuxGaugesPresent===True&&GaugeListAux[[i,1]]===True,posAux=Position[UnbrokenSubgroups,Gauge[[i,3]]][[1,1]];
GaugeTransformation=Join[GaugeTransformation,Table[{RepGaugeBosons[[posAux,k,1]][GTnew[[1]][[1]]],SplitGhostsAuxFabc[(SplitGaugeBosonsAuxFabc[GTnew[[2]]])/.{gen1->gen1+Sum[RepGaugeBosons[[posAux,n,2]],{n,1,k-1}]}]},{k,1,Length[RepGaugeBosons[[posAux]]]}]];
];
i++;];

For[i=1,i<=AnzahlChiral,
DynamicGaugeTNr=i+Length[Gauge];
DynamicGaugeTName=SFields[[i]];
PrintDebug["   ",SFields[[i]]];
If[SFields[[i]]=!=0,
temp= - (I KovariantGhost[i,1,2,3])*part[SFields[[i]],2];
If[temp=!=0,
gaugeT=Flatten[SumOverIndizesGhost[SumOverExpandedIndizes[temp,{None,Fields[[i,3]]}],{Fields[[i,3]]}]] /.subFieldsOne;,
gaugeT=0;
];
(* If[Dimensions[SFieldsMultiplets[[i]]]=!={1}, *)
If[Head[SFieldsMultiplets[[i]]]===List,
(* withoutNum=Flatten[DeleteCases[SFieldsMultiplets[[i]],x_?NumberQ,4]]; *)
withoutNum=Flatten[DeleteCases[SFieldsMultiplets[[i]],x_?NumberQ,{2,4}]] /. 0->1; (* changed 16/11/16: before {3,4} *)
withNum=Flatten[SFieldsMultiplets[[i]]];
NumFac=withNum/withoutNum;
invF=Map[getFull,withoutNum] /. subGC[1];
For[j=1,j<=Length[invF],
If[NumericQ[invF[[j]]]===False,
(*H*)(*If AuxGaugesPresent, one has to rewrite e.g.gPS\[Rule]gG,gX,gY,gS*)
If[AuxGaugesPresent===True,
GaugeTransformation=Join[GaugeTransformation,{{invF[[j]],NumFac[[j]]SplitGhostsAux[gaugeT[[j]]]}}];,
GaugeTransformation=Join[GaugeTransformation,{{invF[[j]],NumFac[[j]]gaugeT[[j]]}}];
];
];
j++;];,
If[AuxGaugesPresent===True,
GaugeTransformation=Join[GaugeTransformation,{{SFieldsMultiplets[[i]],SplitGhostsAux[gaugeT]}}];,
GaugeTransformation=Join[GaugeTransformation,{{SFieldsMultiplets[[i]],gaugeT}}];
];
];
];
i++;];

GaugeTransformation=EleminateSumsOfFields[GaugeTransformation];
DynamicGaugeTName="All Done";
GaugeTransformation=DeleteCases[GaugeTransformation,{_,_,0}] /.{GetGen -> getGen,GetGenStart->getGenStart};
];

EleminateSumsOfFields[list_]:=Block[{i,j,tempNoSum={},tempSum={},res,field1,field2,coeff1,coeff2,pos},
Print["Eleminate sums"];
If[Length[list]>1,
If[FreeQ[Transpose[list][[1]],Plus]===False,
For[i=1,i<=Length[list],
If[Head[list[[i,1]]]===Plus,
tempSum=Join[tempSum,{list[[i]]}];,
tempNoSum=Join[tempNoSum,{list[[i]]}];
];
i++;];
For[i=1,i<=Length[tempSum],
field1=DeleteCases[tempSum[[i,1,1]],x_?NumberQ,{1,4}] /. 0->1/. Delta[a__]->1; 
coeff1=tempSum[[i,1,1]]/field1/. Delta[a__]->1;
field2=DeleteCases[tempSum[[i,1,2]],x_?NumberQ,{1,4}] /. 0->1/. Delta[a__]->1; 
coeff2=tempSum[[i,1,2]]/field2/. Delta[a__]->1;
If[FreeQ[Transpose[tempNoSum][[1]],field1]===False,
pos=Position[Transpose[tempNoSum][[1]],field1][[1,1]];
tempNoSum=Join[tempNoSum,{{field2,(tempSum[[i,2]]-coeff1 tempNoSum[[pos]][[2]])/coeff2}}];,
pos=Position[Transpose[tempNoSum][[1]],field2][[1,1]];
tempNoSum=Join[tempNoSum,{{field1,(tempSum[[i,2]]-coeff2 tempNoSum[[pos]][[2]])/coeff1}}];
];
i++;];
res=tempNoSum;,
res=list;];,
res=list;
];
Return[res];
];


(* ::Input::Initialization:: *)

UpdateGaugeTransformations[sub_,subInv_,nameUGT_]:=Block[{i,temp},

Print["   Update gauge transformations: ",Dynamic[DynamicUGT[nameUGT]],"/",Length[Particles[Current]]," (",Dynamic[DynamicUGTname[nameUGT]],")"];
PrintDebug["   Update gauge transformations"];

If[sub=!={} ,
NewGaugeTransformation={};
For[i=1,i<=Length[Particles[Current]],
DynamicUGTname[nameUGT]=Particles[Current][[i,1]];
DynamicUGT[nameUGT]=i;
PrintDebug[Particles[Current][[i,1]]];
If[Particles[Current][[i,4]]===S || Particles[Current][[i,4]]===V,
temp = DeltaGT[ReplaceAll[replaceGen[ReleaseHold[getFull[Particles[Current][[i,1]]] /.subGC[1] /. subInv /. gen1->pre1],rgNr], gen1->tem1]];
rgNr++;
NewGaugeTransformation=Join[NewGaugeTransformation,{{Particles[Current][[i,1]],(replaceGen[ReleaseHold[temp/. sub],rgNr] /.pre1->gen1 /.tem1->int10  )}}];
];
i++;];
DynamicUGTname[nameUGT]="All Done";
GaugeTransformation=DeleteCases[NewGaugeTransformation,{_,_,0}] /.{GetGen -> getGen,GetGenStart->getGenStart};
];

];

UpdateGaugeTransformationsTensorToVector[sub_]:=Block[{i,j,temp},

Print["   Update gauge transformations"];
PrintDebug["   Update gauge transformations"];

For[j=1,j<=Length[sub],
NewGaugeTransformation={};
For[i=1,i<=Length[GaugeTransformation],
If[FreeQ[GaugeTransformation[[i,1]],sub[[j,1]]],
NewGaugeTransformation=Join[NewGaugeTransformation,{{GaugeTransformation[[i,1]],GaugeTransformation[[i,2]]/.sub[[j,2,3]]}}];,
NewGaugeTransformation=Join[NewGaugeTransformation,{{sub[[j,2,2]],sub[[j,2,4,1]]( GaugeTransformation[[i,2]]/. sub[[j,2,4,2]])}}];
];
i++;];
GaugeTransformation=DeleteCases[NewGaugeTransformation,{_,_,0}] /.{GetGen -> getGen,GetGenStart->getGenStart};
j++;];

];

KovariantGhost[fieldNr_,p1_,p2_, LorNr_]:=Block[{i,temp, gauge, gaugeNr,gNr,gNr2},
temp=0;
For[gNr=1,gNr<=AnzahlGauge,
If[FieldDim[fieldNr,gNr]=!=0 || Gauge[[gNr,2]]===U[1] ,
temp += part[gGauge[[gNr]],LorNr] getGenerator[gNr,FieldDim[fieldNr,gNr],LorNr,p1,p2]*
Gauge[[gNr,4]] makeDelta[fieldNr,p1,p2,{Gauge[[gNr,3]]}];
If[Gauge[[gNr,2]]===U[1] && NoU1Mixing=!=True,
For[gNr2=1,gNr2<=AnzahlGauge,
If[Gauge[[gNr2,2]]===U[1] && gNr2!= gNr,
temp +=  part[gGauge[[gNr]],LorNr] getGenerator[gNr2,FieldDim[fieldNr,gNr2],LorNr,p1,p2]*
GaugesU1[gNr2,gNr] makeDelta[fieldNr,p1,p2,{Gauge[[gNr,3]]}];
];
gNr2++;
];
];
];
gNr++;];
Return[temp];
];


(*
SumOverIndizesGhost[term_,partList_]:=Block[{j,i,temp, temp1,pos,suffix,nr},
IndexNames={};
For[i=1,i\[LessEqual]Length[partList],
If[partList[[i]]=!=None,
pos=Position[ListFields,partList[[i]]][[1,1]];
For[j=1,j\[LessEqual]Length[ListFields[[pos,2]]],
(* IndexNames = Join[IndexNames,ListFields[[pos,2,2]] /. subGC[i]]; *)
If[Head[GaugeListAux]===List,
(* For the case that there is an unbroken Subgroup, one has not to sum over 1..4 for SU(4) instance, but only for 1..2 and 2 contains then the 3 unbroken color charges; that's checked here *)
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],If[GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],1]]=!=True,ListFields[[pos,2,2,j,2]],GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],2]]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];,
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],ListFields[[pos,2,2,j,2]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];
];
(* IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],ListFields[[pos,2,2,j,2]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]]; *)
j++;];
];
i++;];

temp=term;
For[i=1, i\[LessEqual]Length[IndexNames],
If[AuxGaugesPresent===True,
suffix=If[StringLength[ToString[IndexNames[[i,1]]]]===4,"",StringTake[ToString[IndexNames[[i,1]]],{-1}]];
If[FreeQ[UnbrokenSubgroups,getIndexFamilyName[ IndexNames[[i,1]]]]===False,
temp=temp//.ReplacementRuleAux[ IndexNames[[i,1]]];
];
temp1=Hold[Table[temp,iter]]/.{iter\[Rule] IndexNames[[Length[IndexNames]-i+1]]};
(* get the numbering of the field summed over *)
nr=ToExpression[StringTake[ToString[IndexNames[[i,1]]],{4}]];
(* temp=ReleaseHold[ReleaseHold[ temp1]]/. subGeneratorAux//.  UnbrokenSubgroups[[1,2]]-> (IndexNames[[i,1]] /. subNamesAux); *)
temp=ReleaseHold[ReleaseHold[ temp1]]/. subGeneratorAux//.   subGC[nr] //. SUFFIX[a_]\[RuleDelayed]ToExpression[ToString[a]<>suffix]/. DELTAaux\[Rule]Delta /. EPSaux\[Rule]epsTensor/.SUMaux\[Rule]sum;,
temp1=Hold[Table[temp,iter]]/.{iter\[Rule] IndexNames[[Length[IndexNames]-i+1]]};
temp=ReleaseHold[temp1];
];
i++;];

Return[temp];

];
*)

SumOverIndizesGhost[term_,partList_]:=Block[{j,i,temp, temp1,pos,suffix,nr},
IndexNames={};
For[i=1,i<=Length[partList],
If[partList[[i]]=!=None,
pos=Position[ListFields,partList[[i]]][[1,1]];
For[j=1,j<=Length[ListFields[[pos,2]]],
(* IndexNames = Join[IndexNames,ListFields[[pos,2,2]] /. subGC[i]]; *)
If[Head[GaugeListAux]===List,
(* For the case that there is an unbroken Subgroup, one has not to sum over 1..4 for SU(4) instance, but only for 1..2 and 2 contains then the 3 unbroken color charges; that's checked here *)
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],If[GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],1]]=!=True,ListFields[[pos,2,2,j,2]],GaugeListAux[[Position[Gauge,getFundamentalIndex[ListFields[[pos,2,1,j]]]][[1,1]],2]]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];,
IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],ListFields[[pos,2,2,j,2]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]];
];
(* IndexNames = Join[IndexNames,Table[{ListFields[[pos,2,1,j]],ListFields[[pos,2,2,j,2]]},{j,1,Length[ListFields[[pos,2,2]]]}] /. subGC[i]]; *)
j++;];
];
i++;];
temp=term;
For[i=1, i<=Length[IndexNames],
If[AuxGaugesPresent===True,
If[GaugeListAux[[Position[Gauge,getIndexFamilyName[IndexNames[[i,1]]]][[1,1]],1]]===True,
suffix=If[StringLength[ToString[IndexNames[[i,1]]]]===4,"",StringTake[ToString[IndexNames[[i,1]]],{-1}]];
If[FreeQ[UnbrokenSubgroups,getIndexFamilyName[ IndexNames[[i,1]]]]===False,
temp=temp//.ReplacementRuleAux[ IndexNames[[i,1]]];
];
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[i]]};
(* get the numbering of the field summed over *)
nr=ToExpression[StringTake[ToString[IndexNames[[i,1]]],{4}]];
(* temp=ReleaseHold[ReleaseHold[ temp1]]/. subGeneratorAux//.  UnbrokenSubgroups[[1,2]]-> (IndexNames[[i,1]] /. subNamesAux); *)
temp=ReleaseHold[ReleaseHold[ temp1]]/. subGeneratorAux//.   subGC[nr] //. SUFFIX[a_]:>ToExpression[ToString[a]<>suffix]/. DELTAaux->Delta /. EPSaux->epsTensor/.SUMaux->sum;,
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[i]]};
temp=ReleaseHold[temp1];
];,
temp1=Hold[Table[temp,iter]]/.{iter-> IndexNames[[Length[IndexNames]-i+1]]};
temp=ReleaseHold[temp1];
];
i++;];

Return[temp];

];






DeltaGT[x_]:=Block[{},
If[Head[x]==List,erg=List@@x;erg=DeltaGT/@erg;Return[List@@erg];];
If[Head[x]==Times,erg=List@@x;erg=DeltaGT/@erg;Return[Times@@erg];];
If[Head[x]==Plus,erg=List@@x;erg=DeltaGT/@erg;Return[Plus@@erg];];
If[Head[x]==Power,erg=List@@x;erg=DeltaGT/@erg;Return[Power@@erg];];
If[Head[x]==conj,erg=List@@x;erg=DeltaGT/@erg;Return[conj@@erg];];
If[Head[x]==Mom,Return[x];];
If[Head[x]==Der,Return[Der[DeltaGT[x[[1]]],lor3]];];


If[MemberQ[vacuum,x] || MemberQ[vacuum,Head[x]],
If[Length[x]==0,
If[FreeQ[Transpose[GaugeTransformation][[1]],x],Print[x," not found"];];
pos=Position[Transpose[GaugeTransformation][[1]],x][[1,1]];
If[Head[GaugeTransformation[[pos]][[1]]]===conj,
Return[conj[Extract[GaugeTransformation,pos][[2]]]];,
Return[Extract[GaugeTransformation,pos][[2]]];
];,
If[FreeQ[Transpose[GaugeTransformation][[1]],Head[x]],Print[Head[x]," not found"];];
pos=Position[Transpose[GaugeTransformation][[1]],Head[x]][[1,1]];
If[Head[GaugeTransformation[[pos]][[1]]]===conj,
Return[conj[Extract[GaugeTransformation,pos][[2]]/.gen1->x[[1,1]]]];,
Return[Extract[GaugeTransformation,pos][[2]]/.gen1->x[[1,1]]];
];
];,
Return[x];
];
];




(* ::Input::Initialization:: *)
CalcGhostLagrangian[GaugeFixing_]:=Block[{i,GaugeFixingTemp},

GaugeFixingTemp = GaugeFixing /. Der[a_]->Der[a,lor2];

subGhostC={};
For[i=1,i<=Length[Particles[Current]],
If[(getType[Particles[Current][[i,1]]]==G) && (MemberQ[realVar,Particles[Current][[i,1]]]==False),
If[StringTake[ToString[Particles[Current][[i,1]]],-1]==="C",
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[StringDrop[ToString[Particles[Current][[i,1]]],-1]][{x}]}];,
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[ToString[Particles[Current][[i,1]]]<>"C"][{x}]}];
];
];

i++;]; 

Print["Calc Ghost Interactions"];

LGhost=0;
For[i=1,i<=Length[GaugeFixing],
GaugeFixingFactor[makeGhost[conj[GaugeFixingTemp[[i,1]]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[makeGhost[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[ExtractGaugeField[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];

LGhost +=(GaugeFixing[[i,2]] /. RXi[a__]->1)(bar[partBlank[makeGhost[conj[GaugeFixingTemp[[i,1]]]],1]]*(DeltaGT[conj[GaugeFixingTemp[[i,1]]]] /.subGhostC)+bar[partBlank[makeGhost[GaugeFixingTemp[[i,1]]],1]]*(DeltaGT[GaugeFixingTemp[[i,1]]] /.subGhostC));
i++;];

LGhost = - LGhost;


GoldstoneGhost={};

For[i=1,i<=Length[GaugeFixing],
parts=Cases[GaugeFixing[[i,1]] /. conj[y_]->y,x_?ParticleQ,2];
For[j=1,j<=Length[parts],
If[getType[parts[[j]]]===S,
If[FreeQ[GaugeFixing[[i,1]] ,conj[parts[[j]]]],
GoldstoneGhost = Join[GoldstoneGhost,{{ExtractGaugeField[GaugeFixing[[i,1]]] ,parts[[j]]}}];,
GoldstoneGhost = Join[GoldstoneGhost,{{ExtractGaugeField[GaugeFixing[[i,1]]] ,conj[parts[[j]]]}}];
];
];
j++;];
i++;
];



];


(* ::Input::Initialization:: *)

makeGhost[x_]:=Block[{temp,ghostp},
If[Head[x]===Plus,
temp=List@@x;,
temp={x};
];
ghostp=Select[temp,(Head[#]==Der)&,2][[1,1]];
Return[getGhost[ghostp]];
];

ExtractGaugeField[x_]:=Block[{temp,ghostp},
If[Head[x]===Plus,
temp=List@@x;,
temp={x};
];
ghostp=Select[temp,(Head[#]==Der)&,2][[1,1]];
Return[ghostp];
];




(* ::Input::Initialization:: *)
GenerateGaugeFixing[kinetic_,name_,nr_]:=Block[{scalars,gb,temp={}, res,i,j,nameXi,num,un},
If[Head[DEFINITION[name][GaugeFixing]]===List,
GaugeFixing::Defined="Since version 3.1.0 SARAH derives the gauge fixing terms by itself. The given input in the model file is longer necessary and it will be ingored.";
Message[GaugeFixing::Defined];
];

gb = SA`NewGaugeBosons;
gb =Select[Particles[Current],(#[[4]]===V)&];
gb=Transpose[gb][[1]];
scalars=Select[Particles[Current],(#[[4]]===S)&];
If[scalars=!={},
scalars=Transpose[scalars][[1]];
];

(*H*)(*If there are auxilary gauges,the gauge bosons of the broken gauge group stay in Particles[Currents] at this stage,hece are removed from the list gb*)
If[AuxGaugesPresent===True,
For[un=1,un<=Length[UnbrokenSubgroups],
gb=Delete[gb,Position[gb,ToExpression["V"<>ToString[Gauge[[Position[Gauge,UnbrokenSubgroups[[un,1]]][[1,1]]]][[1]]]]][[1,1]]];
un++;];
];

CalcImp=True;
Update[];

Print["  ... generate gauge fixing terms: ",Dynamic[DynamicGFnr[name]],"/",Length[gb]," (",Dynamic[DynamicGFname[name]],")"];

(*H*)(*If AuxGaugesPresent,then the all the vector bosons corresponding to the (later) broken group have to have the same RXi name if at the group is not broken yet as that stage*)(*How to find out if the group is already broken or not?Apparently "BrokenSymmetries" assigns a gauge group as broken if some of the corresponding gauge bosons are mentioned in DEFINITION[NameOfStates][GaugeSector],I will use the same approach.These gauge bosons are already singled out in subGauge,so I will use this fact.The corresponding VB will be "marked"*)
markedVB={};
If[AuxGaugesPresent===True,VBbr=Table[Head[subGauge[[i,1]]],{i,1,Length[subGauge]}];
For[unb=1,unb<=Length[UnbrokenSubgroups],
unbName=Gauge[[Position[Gauge,UnbrokenSubgroups[[unb,1]]][[1,1]]]][[1]];
VBunb=Table[RepGaugeBosons[[unb,k,1]],{k,1,Length[RepGaugeBosons[[unb]]]}];
If[Sort[Intersection[VBunb,gb]]==Sort[VBunb]&&Intersection[VBunb,VBbr]=={},
markedVB=Join[markedVB,Table[{VBunb[[k]],unbName},{k,1,Length[VBunb]}]]];
unb++;
];
];

For[i=1,i<=Length[gb],
DynamicGFnr[name]=i;
DynamicGFname[name]=gb[[i]];
PrintDebug["   ",gb[[i]]];
res=0;
If[conj[gb[[i]]]===gb[[i]],num=2;,num=1;];
(*H*)
posMarked=Position[markedVB,gb[[i]]];
If[posMarked=={},
nameXi=RXi[ToExpression[StringDrop[ToString[gb[[i]]],1]]];,
nameXi=RXi[markedVB[[posMarked[[1,1]],2]]];
num=2;(*Since these gauge fixing terms come from the bigger gauge group,they inherit the 1/2 factor.Attention! If RepGaugeBosons included conj[VX],then it is not true!!!!*)
];
If[getEntryField[gb[[i]],Mass]=!=0,
For[j=1,j<=Length[scalars],
If[MemberQ[realVar,scalars[[j]]]===MemberQ[realVar,gb[[i]]], (* new in order to prevent unncessary calculations *)
If[DeleteCases[getIndizes[scalars[[j]]],generation]===DeleteCases[DeleteCases[getIndizes[gb[[i]]],lorentz],generation],
res+=DPV[DPV[kinetic /. vacuumF /. Select[vacuumS,FreeQ[#,scalars[[j]]]&]/. Select[vacuumV,FreeQ[#,gb[[i]]]&]/. zero[_][_]->0 /. zero[_]->0,conj[gb[[i]]],1,1]/. vacuumV /. zero[_][_]->0 /. zero[_]->0,scalars[[j]],2,2] /. vacuumS /. zero[_][_]->0 /. zero[_]->0 /. Mom[a_,b_] /;(getType[a]===NoField)->0  /. Mom[a_,b_]->a /. g[a__]->1 /. gen1->gn1 /. gen2->gn2 /.gt1->gen1 /. gt2->gen2 /.Delta[__,lt1]->1;
If[conj[scalars[[j]]]=!=scalars[[j]],
res+=DPV[DPV[kinetic /. vacuumF  /. Select[vacuumS,FreeQ[#,scalars[[j]]]&] /. Select[vacuumV,FreeQ[#,gb[[i]]]&]/. zero[_][_]->0 /. zero[_]->0,conj[gb[[i]]],1,1]/. vacuumV /. zero[_][_]->0 /. zero[_]->0,conj[scalars[[j]]],2,2] /. vacuumS /. zero[_][_]->0 /. zero[_]->0 /. Mom[a_,b_] /;(getType[a]===NoField)->0  /. Mom[a_,b_]->a /. g[__]->1 /. gen1->gn1 /. gen2->gn2 /.gt1->gen1 /. gt2->gen2/.Delta[__,lt1]->1;
];
];
];
j++;];
res= CalcDelta[res /. Delta[a__]/;(FreeQ[{a},gen1] ==False || FreeQ[{a},gen2] ==False)->DELTAGEN[a] ] /. DELTAGEN->Delta ;,
res=0;
];
temp=Join[temp,{{Der[gb[[i]]]+res*nameXi,-1/(num nameXi)}}];
SA`GaugeFixingRXi = Join[SA`GaugeFixingRXi,{{nameXi,gb[[i]]}}];
i++;];
DynamicGFname[name]="All Done";
CalcImp=False;
SA`GaugeFixingRXi = Intersection[SA`GaugeFixingRXi];

temp=temp /. subAlways /.gn2->gn1;

DEFINITION[name][GeneratedGaugeFixing]=temp;
Return[temp];
];


CalcGhostLagrangian2[GaugeFixing_]:=Block[{i,Rxi,vb},

GaugeFixingTemp = GaugeFixing /. Der[a_]->Der[a,lor2];

subGhostC={};
For[i=1,i<=Length[Particles[Current]],
If[(getType[Particles[Current][[i,1]]]==G) && (MemberQ[realVar,Particles[Current][[i,1]]]==False),
If[StringTake[ToString[Particles[Current][[i,1]]],-1]==="C",
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[StringDrop[ToString[Particles[Current][[i,1]]],-1]][{x}]}];,
subGhostC=Join[subGhostC,{conj[Particles[Current][[i,1]][{x_}]]->ToExpression[ToString[Particles[Current][[i,1]]]<>"C"][{x}]}];
];
];

i++;]; 

Print["  ... calculate Ghost interactions"];

LGhosttemp=0;
LGhostSS=0;
For[i=1,i<=Length[GaugeFixing],
Rxi=Cases[GaugeFixing[[i,2]],x_?((Head[#]==RXi)&),6][[1]];
vb=Cases[{GaugeFixing[[i,1]]},x_?((Head[#]==Der)&),6][[1,1]];
GaugeFixingFactor[makeGhost[conj[GaugeFixingTemp[[i,1]]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[makeGhost[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
GaugeFixingFactor[ExtractGaugeField[GaugeFixingTemp[[i,1]]]]=Cases[GaugeFixing[[i,2]],RXi[a__],2][[1,1]];
LGhosttemp +=(GaugeFixing[[i,2]] /. RXi[a__]->1)(bar[partBlank[makeGhost[conj[GaugeFixingTemp[[i,1]]]],1]]*(DeltaGT[conj[GaugeFixingTemp[[i,1]]]] /.subGhostC)+bar[partBlank[makeGhost[GaugeFixingTemp[[i,1]]],1]]*(DeltaGT[GaugeFixingTemp[[i,1]]] /.subGhostC));
If[vb===conj[vb],
LGhostSS+=(GaugeFixing[[i,1]] /. Der[a__]->0/.(Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]]))*conj[(GaugeFixing[[i,1]] /. Der[a__]->0 )/.Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]] /. subGCRE[1,3]/.subGCRE[2,4]]/Rxi/2;,
LGhostSS+=(GaugeFixing[[i,1]] /. Der[a__]->0/.(Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]]))*conj[(GaugeFixing[[i,1]] /. Der[a__]->0 /.Reverse/@Flatten[Table[subIndFinal[i,i],{i,1,4}]] /. subGCRE[1,3]/.subGCRE[2,4])]/Rxi;
];
saveGF=GaugeFixing[[i,1]];
i++;];

(* LGhost = (LGhost /. SA`RemovedGaugeBosons /. SA`RemovedGhosts)- LGhosttemp; *)

LGhost = -LGhosttemp;


];

CheckGoldstoneGhosts[name_]:=Block[{i,GaugeFixing,pos,vb},
GoldstoneGhost={};

vb=Select[Particles[name],(#[[4]]==V)&];

For[i=1,i<=Length[vb],
If[getEntryField[vb[[i,1]],Goldstone]===Goldstone || getEntryField[vb[[i,1]],Goldstone]===None,
 If[getEntryField[vb[[i,1]],Mass]=!=0 && FreeQ[SGauge,vb[[i,1]]] && FreeQ[RepGaugeBosons,vb[[i,1]]],
(* Print["No Goldstone for massive vector boson defined ", vb[[i,1]]]; *)
Message[ModelFile::NoGoldstone,vb[[i,1]]];
];,
GoldstoneGhost=Join[GoldstoneGhost,{{vb[[i,1]],getEntryField[vb[[i,1]],Goldstone]}}];
];
i++;];

];
