(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)

(* Begin["`Init`"]  *)



InitFields:= Block[{i,h,j,k,off,tempS1,tempF1,tempS2,tempF2,tempS1b,tempF1b,tempS2b,tempF2b,S1,F1,S2,F2,j2,diff,temp},
(* PrintAll["Generate all Superfields"]; *)

SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "InitFelds";
SA`Doc`Info = "Initialises all fields for SUSY and non-SUSY models. That means: names for component fields are generated; lists with the information about all fields are stored; group theory for the needed representation is done;";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

PrintAll[StyleForm["Initialization","Section",FontSize->12]];
PrintDebug["Initialization"];


(*Delete unneeded Array Elemtns*)

SuperFields=DeleteCases[SuperFields,0];
Fields=DeleteCases[Fields,0];
Gauge=DeleteCases[Gauge,0];
Global=DeleteCases[Global,0];
dirac=DeleteCases[dirac,0];
mixMass=DeleteCases[mixMass,0];
IntegrateOut=DeleteCases[IntegrateOut,0];
DeleteParticles=DeleteCases[DeleteParticles,0];
IntegrateOutGauge=DeleteCases[IntegrateOutGauge,0];
RemovedFields = Join[DeleteParticles,IntegrateOut];

ScalarFields=DeleteCases[ScalarFields,0];
FermionFields=DeleteCases[FermionFields,0];


If[Length[SuperFields]>0 && (Length[ScalarFields] >0 ||Length[FermionFields]>0),
Model::SUSYandNonSUSY="It is not possible to define Superfields and ScalarFields or FermionFields at the same time";
Message[Model::SUSYandNonSUSY];
Interrupt[];
];

If[Length[SuperFields]>0 || Length[Fields]>0,
SupersymmetricModel=True;,
SupersymmetricModel=False;
ScalarFields=ScalarFields/. {a_,b_Integer,c_,d___}->{c,b,a,d};
FermionFields=FermionFields/. {a_,b_Integer,c_,d___}->{c,b,a,d};
SetOptions[MakeVevacious,Scheme->MS];
DTerms=0;
FSGaugino=0;
Matter=0;
Soft=0;
];

If[Length[SuperFields]>Length[Fields],
Fields=SuperFields/. {a_,b_Integer,c_,d___}->{c,b,a,d};
];


If[SupersymmetricModel===False,
InitAuxGroups;
InitMatterFields;
];


(* Set Numbers *)

AnzahlChiral=Length[Fields];
AnzahlGauge = Length[Gauge];
AnzahlEWSB = Length[ewsb];
AnzahlDirac = Length[dirac];
MultiplicityList = Table[{},{AnzahlChiral}];


If[Head[SuperPotential]===Times  || Head[SuperPotential]===Plus,
SuperPotentialTemp=SuperPotential;
SuperPotential=MakeSuperpotentialAsList[Expand[SuperPotentialTemp]];
];


(* ------------ Dirac Spinors ------------ *)

InitalizeDiracSpinors;

CreateParameterList;
CreateParticlesList;

CheckModelFile;

(* Create All Fields *)

PrintDebug["Initialize gauge groups"];
Print["Initialize gauge groups: ",Dynamic[DynamicInitGaugeG]];
InitGaugeGroups;

DynamicInitGaugeG="All Done";

PrintDebug["Create all component Fields"];
Print["Initialize field: ",Dynamic[DynamicInitFields]];

If[SupersymmetricModel=!=False,
CreateVectorSuperfields;
CreateChiralSuperfields;
If[AddGravitino==True,CreateTensorSuperfields;];,
CreateVectorSuperfields;
CreateMatterFields;
];
DynamicInitFields="All Done";

DynamicInitMisc="";
Print["Preprocessing necessary information: ",Dynamic[DynamicInitMisc]];
CreateSubstitutions;

(*---------------- Majorana Particles ------*)
CheckForMajoranas;
(*------------- DeleteFields -------------- *)
DeleteFields;



CheckForU1mixing;
DynamicInitMisc="All Done";
SA`Doc`EndEntry[];
];

InitAuxGroups:=Block[{i,j,k,l,pos,temp,nrInd,dim,vb,name,rep,posGauge,nr,dimGroup,dimSub,nameSub,gh},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "InitAuxGroups";
SA`Doc`Info = "Initialises auxiliary gauge groups, i.e. 'AuxGauge'. These are needed if unbroken sub-groups are left after the breaking of a bigger group. For instance, SU(4)->SU(3). For instance, replacement rules for the involved gauge bosons and ghosts as well as for the generators and structure constants of the bigger gauge group are generated.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

(* check if auxiliary gauge groups are present *)
If[Head[UnbrokenSubgroups]===List &&UnbrokenSubgroups=!={},
AuxGaugesPresent=True;,
AuxGaugesPresent=False;
];

(* Generate all necessary information *)
If[AuxGaugesPresent===True,
(* Generate list for groups which contain unbroken gauge groups and check the number of terms after the expansion *)
(* For instance, for SU(4), you'll get two terms: a + b[color] *)
GaugeListAux={};
For[i=1,i<=Length[Gauge],
If[FreeQ[UnbrokenSubgroups,Gauge[[i,3]]],
GaugeListAux=Join[GaugeListAux,{{False,1}}]; (* number doesn't play a role here! *),
GaugeListAux=Join[GaugeListAux,{{True,1+Gauge[[i,2]]-AuxGauge[[Position[AuxGauge,Gauge[[i,3]]/.UnbrokenSubgroups][[1,1]],2]]} /. SU[a_]->a}]; 
];
i++;
];

(* a bit more explicit list for the vector bosons *)
(* and substitution rule *)
AuxGaugeBosons={};
subGaugeBosonsAux={};
subGaugeBosonsAuxFabc={};
subGhostsAux={};
subGhostsAuxFabc={};
For[i=1,i<=Length[RepGaugeBosons],
For[j=1,j<=Length[RepGaugeBosons[[i]]],
AuxGaugeBosons=Join[AuxGaugeBosons,{{RepGaugeBosons[[i,j,1]],{UnbrokenSubgroups[[i,2]],RepGaugeBosons[[i,j,2]]}}}];
j++;];
dim=Gauge[[Position[Gauge,UnbrokenSubgroups[[i,1]]][[1,1]],2]];
vb=ToExpression["V"<>ToString[Gauge[[Position[Gauge,UnbrokenSubgroups[[i,1]]][[1,1]],1]]]];
gh=ToExpression["g"<>ToString[Gauge[[Position[Gauge,UnbrokenSubgroups[[i,1]]][[1,1]],1]]]];
name=UnbrokenSubgroups[[i,2]];
realVar=Join[realVar,{gh,vb}];
(* now the ugly part: *)
(* generate substitutions like: sum_\alpha T^\alpha V^\alpha \[Rule] sum_x T^x V1^x + sum_y T^{y+N_x} V2^y  + sum_z T^{z+N_x + N_z} V2^z ... +  *)
(* where T are the generators and alpha the charge indices for the full group, while x,y,.. the indices for the unbroken subgroup *)
subGaugeBosonsAux=Join[subGaugeBosonsAux,{sum[a,___] conj[TA[dim,a,i1_,i2_]] vb[{a,b}]->(Sum[sum[name,1,Abs[RepGaugeBosons[[i,k,2]]]] conj[TA[dim,name+Sum[Abs[RepGaugeBosons[[i,j,2]]],{j,1,k-1}],i1,i2]] If[Abs[RepGaugeBosons[[i,k,2]]]>1,RepGaugeBosons[[i,k,1]][{a,name,b}],RepGaugeBosons[[i,k,1]][{a,b}]],{k,1,Length[RepGaugeBosons[[i]]]}])}];
subGaugeBosonsAux=Join[subGaugeBosonsAux,{sum[a,___] TA[dim,a,i1_,i2_] vb[{a,b}]->(Sum[sum[name,1,Abs[RepGaugeBosons[[i,k,2]]]] TA[dim,name+Sum[Abs[RepGaugeBosons[[i,j,2]]],{j,1,k-1}],i1,i2] If[Abs[RepGaugeBosons[[i,k,2]]]>1,RepGaugeBosons[[i,k,1]][{a,name,b}],RepGaugeBosons[[i,k,1]][{a,b}]],{k,1,Length[RepGaugeBosons[[i]]]}])}];

subGhostsAux=Join[subGhostsAux,{sum[a,___] conj[TA[dim,a,i1_,i2_]] gh[{a}]->(Sum[sum[name,1,Abs[RepGaugeBosons[[i,k,2]]]] conj[TA[dim,name+Sum[Abs[RepGaugeBosons[[i,j,2]]],{j,1,k-1}],i1,i2]] If[Abs[RepGaugeBosons[[i,k,2]]]>1,ToExpression["g"<>StringDrop[ToString[RepGaugeBosons[[i,k,1]]],1]][{name}],ToExpression["g"<>StringDrop[ToString[RepGaugeBosons[[i,k,1]]],1]]],{k,1,Length[RepGaugeBosons[[i]]]}])}];
subGhostsAux=Join[subGhostsAux,{sum[a,___] TA[dim,a,i1_,i2_] gh[{a}]->(Sum[sum[name,1,Abs[RepGaugeBosons[[i,k,2]]]] TA[dim,name+Sum[Abs[RepGaugeBosons[[i,j,2]]],{j,1,k-1}],i1,i2] If[Abs[RepGaugeBosons[[i,k,2]]]>1,ToExpression["g"<>StringDrop[ToString[RepGaugeBosons[[i,k,1]]],1]][{name}],ToExpression["g"<>StringDrop[ToString[RepGaugeBosons[[i,k,1]]],1]]],{k,1,Length[RepGaugeBosons[[i]]]}])}];


(* and now the replacement for the terms with structure constant *)
subGaugeBosonsAuxFabc=Join[subGaugeBosonsAuxFabc,{sum[a,___]FST[dim][i1___,a,i2___] vb[{a,b}]->(Sum[sum[name,1,Abs[RepGaugeBosons[[i,k,2]]]] FST[dim][i1,name+Sum[Abs[RepGaugeBosons[[i,j,2]]],{j,1,k-1}],i2] If[Abs[RepGaugeBosons[[i,k,2]]]>1,RepGaugeBosons[[i,k,1]][{a,name,b}],RepGaugeBosons[[i,k,1]][{a,b}]],{k,1,Length[RepGaugeBosons[[i]]]}])}];

(*and now the replacement for the terms with structure constant*)subGhostsAuxFabc=Join[subGhostsAuxFabc,{sum[a,___]FST[dim][ii1___,a,ii2___] gh[{a}]->(Sum[sum[name,1,Abs[RepGaugeBosons[[i,k,2]]]] FST[dim][ii1,name+Sum[Abs[RepGaugeBosons[[i,j,2]]],{j,1,k-1}],ii2] If[Abs[RepGaugeBosons[[i,k,2]]]>1,ToExpression["g"<>StringDrop[ToString[RepGaugeBosons[[i,k,1]]],1]][{name}],ToExpression["g"<>StringDrop[ToString[RepGaugeBosons[[i,k,1]]],1]]],{k,1,Length[RepGaugeBosons[[i]]]}])}];


(* for VVV we need the replacement wiht derivatives *)
subGaugeBosonsAuxFabc=Join[subGaugeBosonsAuxFabc,{Der[sum[a,___],l_]FST[dim][i1___,a,i2___] Der[vb[{a,b}],l_]->(Sum[Der[sum[name,1,Abs[RepGaugeBosons[[i,k,2]]]],l] FST[dim][i1,name+Sum[Abs[RepGaugeBosons[[i,j,2]]],{j,1,k-1}],i2] Der[If[Abs[RepGaugeBosons[[i,k,2]]]>1,RepGaugeBosons[[i,k,1]][{a,name,b}],RepGaugeBosons[[i,k,1]][{a,b}]],l],{k,1,Length[RepGaugeBosons[[i]]]}])}];
i++;];

(* Substitution for names of charges *)
subNamesAux={};
For[j=1,j<=Length[UnbrokenSubgroups],
For[i=1,i<=5,
For[k=1,k<=6,
subNamesAux=Join[subNamesAux,{ToExpression[StringTake[ToString[UnbrokenSubgroups[[j,1]]],{1,3}]<>ToString[i]<>appendIndex[[k]]]->ToExpression[StringTake[ToString[UnbrokenSubgroups[[j,2]]],{1,3}]<>ToString[i]<>appendIndex[[k]]]}];
k++;];
i++;];
j++;];

(* make a list with representations of matter fields *)
(* as well as replacement for a[color] \[Rule] sum_color a[color] *)
subSumUnbrokenCharges={};
AuxRepFields={};
AuxDimFields={};
For[i=1,i<=Length[FermionFields],
For[j=1,j<=Length[UnbrokenSubgroups],
posGauge=Position[Gauge,UnbrokenSubgroups[[j,1]]][[1,1]];
If[FreeQ[FermionFields[[i]]/. A_[b_Symbol,c_Integer]:>A[getFundamentalIndex[b],c],UnbrokenSubgroups[[j,2]]]==False,
pos=Position[FermionFields[[i]]/. A_[b_Symbol,c_Integer]:>A[getFundamentalIndex[b],c],UnbrokenSubgroups[[j,2]]];
For[k=1,k<=Length[pos],
name=Extract[FermionFields[[i]],Drop[pos[[k]],-1]][[0]];
(* rep=Extract[FermionFields[[i]],Drop[pos[[k]],-1]][[-1]]; *)
rep=Table[{Extract[FermionFields[[i]],Drop[pos[[k]],-1]][[l]],Select[AuxGauge,FreeQ[#,UnbrokenSubgroups[[j,2]]]==False&][[1,2,1]]},{l,1,Length[Extract[FermionFields[[i]],Drop[pos[[k]],-1]]]-1}];
(* AuxRepFields=Join[AuxRepFields,{{name,{UnbrokenSubgroups[[j,2]],rep}}}]; *)
AuxRepFields=Join[AuxRepFields,{{name,rep}}];
AuxDimFields=Join[AuxDimFields,{{name,{UnbrokenSubgroups[[j,2]],Extract[FermionFields[[i]],Drop[pos[[k]],-1]][[-1]]}}}];
subSumUnbrokenCharges=Join[subSumUnbrokenCharges,{name[UnbrokenSubgroups[[j,2]]]->name[UnbrokenSubgroups[[j,2]]] sum[UnbrokenSubgroups[[j,2]],1,Abs[rep]]}];
k++;];
];
j++;];
i++;];
FermionFields = FermionFields /. A_[b__Symbol,c_Integer]->A[b];

For[i=1,i<=Length[ScalarFields],
For[j=1,j<=Length[UnbrokenSubgroups],
posGauge=Position[Gauge,UnbrokenSubgroups[[j,1]]][[1,1]];
If[FreeQ[ScalarFields[[i]]/. A_[b_Symbol,c_Integer]:>A[getFundamentalIndex[b],c],UnbrokenSubgroups[[j,2]]]==False,
pos=Position[ScalarFields[[i]]/. A_[b_Symbol,c_Integer]:>A[getFundamentalIndex[b],c],UnbrokenSubgroups[[j,2]]];
For[k=1,k<=Length[pos],
name=Extract[ScalarFields[[i]],Drop[pos[[k]],-1]][[0]];
(* rep=Extract[ScalarFields[[i]],Drop[pos[[k]],-1]][[-1]];
AuxRepFields=Join[AuxRepFields,{{name,{UnbrokenSubgroups[[j,2]],rep}}}]; *)
rep=Table[{Extract[ScalarFields[[i]],Drop[pos[[k]],-1]][[l]],Select[AuxGauge,FreeQ[#,UnbrokenSubgroups[[j,2]]]==False&][[1,2,1]]},{l,1,Length[Extract[ScalarFields[[i]],Drop[pos[[k]],-1]]]-1}];
AuxRepFields=Join[AuxRepFields,{{name,rep}}];
AuxDimFields=Join[AuxDimFields,{{name,{UnbrokenSubgroups[[j,2]],Extract[ScalarFields[[i]],Drop[pos[[k]],-1]][[-1]]}}}];
subSumUnbrokenCharges=Join[subSumUnbrokenCharges,{name[UnbrokenSubgroups[[j,2]]]->name[UnbrokenSubgroups[[j,2]]] sum[UnbrokenSubgroups[[j,2]],1,Abs[rep]]}];
k++;];
];
j++;];
i++;];

ScalarFields = ScalarFields /. A_[b__Symbol,c_Integer]->A[b];

(* Replacement rules for the generators *)
(* The result should look like *)
(* subGeneratorAux={TA[SU[4],a_,b_,2]\[Rule]TA[SU[4],a,b,color+1],TA[SU[4],a_,2,b_]\[Rule]TA[SU[4],a,color+1,b]} *)
(* Actually, we need also similar replacements for the Kronecker and Levi-Civita which show up in the potentail contractions *)
(* ... and one has to take care of the sums *)
subGeneratorAux={};
For[i=1,i<=Length[Gauge],
If[FreeQ[UnbrokenSubgroups,Gauge[[i,3]]]==False,
(* dimensions of group and subgroup *)
dimGroup=Gauge[[i,2]] /. SU[a_]->a;
dimSub=AuxGauge[[Position[AuxGauge,Gauge[[i,3]]/.UnbrokenSubgroups][[1,1]]]][[2]]/. SU[a_]->a;
(* biggest number of expansion *)
nr=1+dimGroup-dimSub;

(* name of subgroup index: *)
(* SUFFIX[x] is needed for non-fundamental irreps, where also indices 'colorb', 'colorc' can show up. *)
(* Later SUFFIX[color] is replaced by 'colorX' with the correct suffix X*)
nameSub=SUFFIX[Gauge[[i,3]]/.UnbrokenSubgroups];

(* generate the replacement rules *)

subGeneratorAux=Join[subGeneratorAux,{TA[Gauge[[i,2]],a_,b_,1]->TA[Gauge[[i,2]],a,b,nameSub]}]; 
subGeneratorAux=Join[subGeneratorAux,{TA[Gauge[[i,2]],a_,1,b_]->TA[Gauge[[i,2]],a,nameSub,b]}]; 
subGeneratorAux=Join[subGeneratorAux,{TA[Gauge[[i,2]],a_,b_,nr]->TA[Gauge[[i,2]],a,b,dimGroup]}]; 
subGeneratorAux=Join[subGeneratorAux,{TA[Gauge[[i,2]],a_,nr,b_]->TA[Gauge[[i,2]],a,dimGroup,b]}]; 
subGeneratorAux=Join[subGeneratorAux,{DELTAaux[1,b_]->DELTAaux[nameSub,b],DELTAaux[b_,1]->DELTAaux[nameSub,b]}]; 
subGeneratorAux=Join[subGeneratorAux,{DELTAaux[nr,b_]->DELTAaux[dimGroup,b],DELTAaux[b_,nr]->DELTAaux[dimGroup,b]}]; 
subGeneratorAux=Join[subGeneratorAux,{EPSaux[1,b_]->EPSaux[nameSub,b],EPSaux[b_,1]->EPSaux[b,nameSub]}]; 
subGeneratorAux=Join[subGeneratorAux,{EPSaux[nr,b_]->EPSaux[dimGroup,b],EPSaux[b_,nr]->EPSaux[b,dimGroup]}]; 

subGeneratorAux=Join[subGeneratorAux,{SUMaux[1,b__]->SUMaux[nameSub,1,dimSub]}]; 
subGeneratorAux=Join[subGeneratorAux,{SUMaux[nr,b__]->1}]; 
];
i++;
];

(* Mark gauge bosons of full group for deletation *)
For[i=1,i<=Length[UnbrokenSubgroups],
name=ToString[Gauge[[Position[Gauge,UnbrokenSubgroups[[i,1]]][[1,1]]]][[1]]];
DeleteParticles=Join[DeleteParticles,{ToExpression["g"<>name],ToExpression["V"<>name]}];
i++;];

];

SA`Doc`EndEntry[];
];

InitalizeDiracSpinors:=Block[{i,h,j,k,off,tempS1,tempF1,tempS2,tempF2,tempS1b,tempF1b,tempS2b,tempF2b,S1,F1,S2,F2,j2,diff,temp},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "InitalizeDiracSpinors";
SA`Doc`Info = "Generates all information to translate Weyl in Dirac spinors and back.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

diracSub={};
diracSubBack={};
diracSubBack1={};
diracSubBack2={};
diracFermion = {};
weylFermion={};

If[AddGravitino==True,
For[i=1,i<=Length[NameOfStates],
If[Head[DEFINITION[NameOfStates[[i]]][DiracSpinors]]===List,
DEFINITION[NameOfStates[[i]]][DiracSpinors]=Join[DEFINITION[NameOfStates[[i]]][DiracSpinors],{GMU->{Gmu,conj[Gmu]}}];
DEFINITION[NameOfStates[[i]]][DiracSpinors]=Join[DEFINITION[NameOfStates[[i]]][DiracSpinors],{GOL->{Gol,conj[Gol]}}];
];
i++;];
];


For[i=1,i<=Length[dirac],
diracSub=Join[diracSub,{dirac[[i,1]]->{dirac[[i,2]],dirac[[i,3]]}}];
If[Head[dirac[[i,3]]]===conj,
diracSubBack=Join[diracSubBack,{RE[dirac[[i,3]]]->bar[dirac[[i,1]]]}];,
diracSubBack=Join[diracSubBack,{dirac[[i,3]]->dirac[[i,1]]}];
];
If[Head[dirac[[i,2]]]===conj,
diracSubBack=Join[diracSubBack,{RE[dirac[[i,2]]]->bar[dirac[[i,1]]]}];,
diracSubBack=Join[diracSubBack,{dirac[[i,2]]->dirac[[i,1]]}];
];

diracSubBack1=Join[diracSubBack1,{RE[dirac[[i,3]]]->dirac[[i,1]]}];
diracSubBack2=Join[diracSubBack2,{RE[dirac[[i,2]]]->dirac[[i,1]]}];
If[MemberQ[realVar,dirac[[i,2]]]==True,
realVar=Join[realVar,{dirac[[i,1]]}];
];
diracFermion = Join[diracFermion,{dirac[[i,1]]}];
weylFermion = Join[weylFermion,{RE[dirac[[i,2]]],RE[dirac[[i,3]]]}];
i++;];


diracSubtemp=diracSub;
diracSubBacktemp=diracSubBack;
diracSubBack1temp=diracSubBack1;
diracSubBack2temp=diracSubBack2;

Clear[diracSub,diracSubBack,diracSubBack1,diracSubBack2];

diracSub[ALL]=diracSubtemp;
diracSubBack[ALL]=diracSubBacktemp;
diracSubBack1[ALL]=diracSubBack1temp;
diracSubBack2[ALL]=diracSubBack2temp;
diracFermions[ALL]=diracFermion;
weylFermions[ALL]=weylFermion;

For[j=1,j<=Length[NameOfStates],
diracSub[NameOfStates[[j]]]={};
diracFermions[NameOfStates[[j]]]={};
weylFermions[NameOfStates[[j]]]={};
diracSubBack[NameOfStates[[j]]]={};
diracSubBack1[NameOfStates[[j]]]={};
diracSubBack2[NameOfStates[[j]]]={};
If[Head[DEFINITION[NameOfStates[[j]]][DiracSpinors]]===List,
diracSub[NameOfStates[[j]]]=DEFINITION[NameOfStates[[j]]][DiracSpinors];
temp=DEFINITION[NameOfStates[[j]]][DiracSpinors];
For[i=1,i<=Length[temp],
If[Head[temp[[i,2,2]]]===conj,
diracSubBack[NameOfStates[[j]]]=Join[diracSubBack[NameOfStates[[j]]],{RE[temp[[i,2,2]]]->bar[temp[[i,1]]]}];,
diracSubBack[NameOfStates[[j]]]=Join[diracSubBack[NameOfStates[[j]]],{temp[[i,2,2]]->temp[[i,1]]}];
];
If[Head[temp[[i,2,1]]]===conj,
diracSubBack[NameOfStates[[j]]]=Join[diracSubBack[NameOfStates[[j]]],{RE[temp[[i,2,1]]]->bar[temp[[i,1]]]}];,
diracSubBack[NameOfStates[[j]]]=Join[diracSubBack[NameOfStates[[j]]],{temp[[i,2,1]]->temp[[i,1]]}];
];
diracSubBack1[NameOfStates[[j]]]=Join[diracSubBack1[NameOfStates[[j]]],{RE[temp[[i,2,2]]]->temp[[i,1]]}];
diracSubBack2[NameOfStates[[j]]]=Join[diracSubBack2[NameOfStates[[j]]],{RE[temp[[i,2,1]]]->temp[[i,1]]}];
diracFermions[NameOfStates[[j]]] = Join[diracFermions[NameOfStates[[j]]],{temp[[i,1]]}];
weylFermions[NameOfStates[[j]]] = Join[weylFermions[NameOfStates[[j]]],{RE[temp[[i,2,1]]],RE[temp[[i,2,2]]]}];
i++;];

diracSub[ALL]=Join[diracSub[ALL],diracSub[NameOfStates[[j]]]];
diracSubBack[ALL]=Join[diracSubBack[ALL],diracSubBack[NameOfStates[[j]]]];
diracSubBack1[ALL]=Join[diracSubBack1[ALL],diracSubBack1[NameOfStates[[j]]]];
diracSubBack2[ALL]=Join[diracSubBack2[ALL],diracSubBack2[NameOfStates[[j]]]];
diracFermions[ALL]=Join[diracFermions[ALL],diracFermions[NameOfStates[[j]]]];
weylFermions[ALL]=Join[weylFermions[ALL],weylFermions[NameOfStates[[j]]]];
];

diracSub[NameOfStates[[j]]]=Join[diracSub[NameOfStates[[j]]],diracSubtemp];
diracSubBack[NameOfStates[[j]]]=Join[diracSubBack[NameOfStates[[j]]],diracSubBacktemp];
diracSubBack1[NameOfStates[[j]]]=Join[diracSubBack1[NameOfStates[[j]]],diracSubBack1temp];
diracSubBack2[NameOfStates[[j]]]=Join[diracSubBack2[NameOfStates[[j]]],diracSubBack2temp];
diracFermions[NameOfStates[[j]]] = Join[diracFermions[NameOfStates[[j]]],diracFermion];
weylFermions[NameOfStates[[j]]] = Join[weylFermions[NameOfStates[[j]]],weylFermion];

j++;];

SA`Doc`EndEntry[];
];

InitMatterFields:=Block[{i},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "InitMatterFields";
SA`Doc`Info = "Initialises lists for all fermions and scalars in the case of a non-supersymmetric model. The main purpose is to join the ScalarFields and FermionFields array used in the definition of non-supersymmetric model to get the array 'Fields' used for SUSY models. In that way, many routines originally written for SUSY models can be used.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

AnzahlChiral=Length[FermionFields]+Length[ScalarFields];
SFields = Table[{}, {AnzahlChiral}];
SFieldsNoTensor = Table[{}, {AnzahlChiral}];
SFieldsTensor = Table[{}, {AnzahlChiral}];
FFields = Table[{}, {AnzahlChiral}];
AFields = Table[{}, {AnzahlChiral}];

SFieldsMultiplets = Table[{}, {AnzahlChiral}];
FFieldsMultiplets = Table[{}, {AnzahlChiral}];
AFieldsMultiplets = Table[{}, {AnzahlChiral}];

SFieldList={};
FFieldList={};
AFieldList={};

Fields={};
For[i=1,i<=Length[ScalarFields],
Fields=Join[Fields,{Join[ScalarFields[[i]],{S}]}];
i++;];
For[i=1,i<=Length[FermionFields],
Fields=Join[Fields,{Join[FermionFields[[i]],{F}]}];
i++;];

SA`Doc`EndEntry[];
];

CreateMatterFields:=Block[{i,h,j,k,off,tempS1,tempF1,tempS2,tempF2,tempS1b,tempF1b,tempS2b,tempF2b,S1,F1,S2,F2,j2,diff,temp,namefield},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "CreateMatterFields";
SA`Doc`Info = "Creates all fermions and scalars in the case of a non-supersymmetric model: \n
1) The gauge and generations indices for the fields are generated \n
2) The gauge properties (Dynkin index, Casmimir index,..) of all fields are calculated and stored in dedicated variables \n
3) Replacement rules for multiplets under gauge groups which get broken are generated \n
4) The definition of the fiels are extended in a way that the replacement of the multiplets is automatically done, e.g.
(qL[{gen,left}] /. left->1) will automatially result in by uL[{gen}]";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

PrintDebug["   matter fields: "];
DynamicInitFields="matter fields";
RealScalarsMul={};
For[i=1, i<= AnzahlChiral,
temp= GenerateAllIndizes[i];
indizes=temp[[1]];
Expandedindizes=temp[[2]];
absIFull=temp[[3]] //. a_Integer :>Abs[a];
absEFull=temp[[4]]//. a_Integer :>Abs[a];

absI=Table[absIFull[[j,1]],{j,1,Length[absIFull]}];
absE=Table[absEFull[[j,1]],{j,1,Length[absEFull]}];

If[Dimensions[Fields[[i,1]]]=!={} &&  Head[Fields[[i,1]]]=!=conj,
FieldNames=Select[Intersection[DeleteCases[Flatten[Fields[[i,1]]/. Plus->List /. Delta[__]->1],x_?NumericQ] /.x_? NumericQ->1],(Head[#]=!=conj || MemberQ[DeleteCases[Flatten[Fields[[i,1]]],x_?NumericQ] /.x_? NumericQ->1,conj[#]]==False)&],
FieldNames ={Fields[[i,1]]};
];

subScalar={};
subFermion={};

If[Last[Fields[[i]]]===S,
scalarSF=Fields[[i,3]];
If[FreeQ[RealScalars,Fields[[i,3]]]==False,realVar=Join[realVar,{scalarSF}];];,
scalarSF=0;];
If[Last[Fields[[i]]]===F,
fermionSF=Fields[[i,3]];,
fermionSF=0;];


For[j=1,j<=Length[FieldNames],
If[Head[FieldNames[[j]]]===conj,
name= ToString[FieldNames[[j,1]]];,
name = ToString[FieldNames[[j]]];
];

If[Last[Fields[[i]]]===S,
scalar=ToExpression[name];
If[FreeQ[RealScalars,Fields[[i,3]]]==False && FreeQ[Fields[[i,1]],conj[scalar]],
realVar=Join[realVar,{scalar}];
RealScalarsMul=Join[RealScalarsMul,{Fields[[i,3]]}];
];
If[FreeQ[RealScalars,scalar]==False,
realVar=Join[realVar,{scalar}];
RealScalarsMul=Join[RealScalarsMul,{Fields[[i,3]]}];
];,
scalar=0;];
If[Last[Fields[[i]]]===F,fermion=ToExpression[name];,fermion=0;];


(* auxiliary = ToExpression["A"<>name]; *)

For[j2=1,j2<=AnzahlGauge,
If[Gauge[[j2,5]]==True,
diff=Abs[Fields[[i,j2+3]]];,
diff=1;
];
Switch[Gauge[[j2,2]],
U[1],
	valueCasimir=GUTren[j2]^2 Fields[[i,j2+3]]^2;
	valueDynkin=GUTren[j2]^2 Fields[[i,j2+3]]^2;
	valueGenerator= Fields[[i,j2+3]];
	valueDimensions=1;
	If[FreeQ[Fields[[i,1]],conj]==True,
	valueDyn=Fields[[i,j2+3]];
	valueDynSF=valueDyn;,
	valueDyn=-Fields[[i,j2+3]];
	valueDynSF=Fields[[i,j2+3]];
	];,
_,
	If[Fields[[i,j2+3]]==1,
	valueCasimir=0;
	valueDynkin=0;
	valueGenerator= 0;
	valueDyn={0};
	valueDynSF={0};
	valueDimensions=1;,
	valueCasimir= SA`Casimir[getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]],Gauge[[j2,2]]];
	valueDynkin= SA`Dynkin[getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]],Gauge[[j2,2]]];
	If[Gauge[[j2,5]]===True && Gauge[[j2,2]]=!=U[1],
	valueGenerator= GeneratorB[Gauge[[j2,2]],getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]]];,
	valueGenerator= Generator[Gauge[[j2,2]],getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]]];
	];
	If[FreeQ[Fields[[i,1]],conj]==True,
	valueDyn=getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]];
	valueDynSF=valueDyn;,
	valueDyn=ConjugatedRep[getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]],Gauge[[j2,2]]];
	valueDynSF=getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]];
	];
	];
	valueDimensions=Abs[Fields[[i,j2+3]]];
	
];

valueMulFactor=Fields[[i,2]]*Times@@(Abs/@Table[If[Gauge[[k,2]]===U[1] || k===j2,1,Fields[[i,k+3]]],{k,1,Length[Gauge]}]);

If[Last[Fields[[i]]]===S,
SetGroupConstants[scalar,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,True,False];
SetGroupConstants[scalarSF,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDynSF,If[Length[FieldNames]===1,True,False],True];
];


If[Last[Fields[[i]]]===F,
SetGroupConstants[fermion,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,True,False];
SetGroupConstants[fermionSF,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDynSF,If[Length[FieldNames]===1,True,False],True];
];

SetGroupConstants[Fields[[i,3]],Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDynSF,False,False];

If[Gauge[[j2,2]]===U[1],
If[Last[Fields[[i]]]===S,SA`ChargeGG[scalar,j2] = Fields[[i,j2+3]];];
If[Last[Fields[[i]]]===F,SA`ChargeGG[fermion,j2] = Fields[[i,j2+3]];];
];

j2++;];

For[j2=1,j2<=Length[Global],
If[Head[Fields[[i,j2+3+AnzahlGauge]]]===List,
SA`ChargeGlobal[Fields[[i,3]],Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,1]];
SA`ChargeGlobal[scalarSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];
SA`ChargeGlobal[fermionSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,3]];
SA`ChargeGlobal[auxiliarySF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];
SA`ChargeGlobal[scalar,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];
SA`ChargeGlobal[fermion,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,3]];
SA`ChargeGlobal[auxiliary,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];,
SA`ChargeGlobal[Fields[[i,3]],Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[scalar,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[fermion,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[auxiliary,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[scalarSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[fermionSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[auxiliarySF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
];
j2++;];

If[Head[Fields[[i,1]]]=!=List,
usedInd=absI;,
usedInd={}
];
absIsave=absI;

If[Head[FieldNames[[j]]]===conj,
subScalar=Join[subScalar,{FieldNames[[j]]->conj[scalar[usedInd]]}];
subFermion=Join[subFermion,{FieldNames[[j]]->conj[fermion[usedInd]]}];

If[Last[Fields[[i]]]===S,SA`QNscalar = Join[SA`QNscalar,{{scalar[absI] /. a_[{b__}]->a, Join[-Take[Fields[[i]],{4,-1}],{getRParitySF[Fields[[i,3]]]}]}}];];
If[Last[Fields[[i]]]===F,SA`QNfermion = Join[SA`QNfermion,{{fermion[absI]/. a_[{b__}]->a, Join[-Take[Fields[[i]],{4,-1}],{-getRParitySF[Fields[[i,3]]]}]}}];];
SFieldList=Join[SFieldList,{conj[scalar[absI]]}];
FFieldList=Join[FFieldList,{conj[fermion[absI]]}];,
subScalar=Join[subScalar,{FieldNames[[j]]->scalar[usedInd]}];
subFermion=Join[subFermion,{FieldNames[[j]]->fermion[usedInd]}];
SFieldList=Join[SFieldList,{scalar[absI]}];
FFieldList=Join[FFieldList,{fermion[absI]}];
If[Last[Fields[[i]]]===S,SA`QNscalar = Join[SA`QNscalar,{{scalar[absI]/. a_[{b__}]->a,Join[Take[Fields[[i]],{4,-1}],{getRParitySF[Fields[[i,3]]]}]}}];];
If[Last[Fields[[i]]]===F,SA`QNfermion = Join[SA`QNfermion,{{fermion[absI]/. a_[{b__}]->a, Join[Take[Fields[[i]],{4,-1}],{-getRParitySF[Fields[[i,3]]]}]}}];];
];

If[AuxGaugesPresent===False,
If[Last[Fields[[i]]]===S,addParticle[scalar,absIFull,Fields[[i,2]],S];];
If[Last[Fields[[i]]]===F,addParticle[fermion,absIFull,Fields[[i,2]],F];];,

If[Last[Fields[[i]]]===S,
namefield=scalar;,
namefield=fermion;
];
If[FreeQ[AuxRepFields,namefield /. A_[b__Symbol]->A]==False,
temp=Hold[Set[(namefield /. A_[b__Symbol]->A)[d__Symbol][{c__}],(namefield /. A_[b__Symbol]->A)[{c,d}]]];
ReleaseHold[temp];
(* Set the group constants *)
For[j2=1,j2<=Length[AuxGauge],
valueDimensions=AuxDimFields[[Position[AuxDimFields,namefield /. A_[b__Symbol]->A][[1,1]]]][[2,2]];
If[FreeQ[Fields[[i,1]],conj[namefield]]==True,
valueDyn=getDynkinLabels[valueDimensions,AuxGauge[[j2,2]]];,
valueDyn=ConjugatedRep[getDynkinLabels[valueDimensions,AuxGauge[[j2,2]]],AuxGauge[[j2,2]]];
];
valueDimensions=Abs[valueDimensions];
valueCasimir= SA`Casimir[valueDyn,AuxGauge[[j2,2]]];
valueDynkin= SA`Dynkin[valueDyn,AuxGauge[[j2,2]]];
valueGenerator=0; (* not needed *)
SetGroupConstants[namefield/. A_[b__Symbol]->A,AuxGauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,False,False];
j2++;
];
addParticle[namefield/. A_[b__Symbol]->A,Join[absIFull,AuxRepFields[[Position[AuxRepFields,namefield /. A_[b__Symbol]->A][[1,1]]]][[2]]],Fields[[i,2]],Last[Fields[[i]]]];,
For[j2=1,j2<=Length[AuxGauge],
SetGroupConstants[namefield,AuxGauge[[j2,3]],0,0,0,0,1,{0},False,False];
j2++;];
addParticle[namefield,absIFull,Fields[[i,2]],Last[Fields[[i]]]];
];

];
j++;];


If[Last[Fields[[i]]]===S,SFieldsMultiplets [[i]]=Fields[[i,1]] /. subScalar /. A_[{}]->A;,SFieldsMultiplets [[i]]=0;];
If[Last[Fields[[i]]]===F,FFieldsMultiplets [[i]]=Fields[[i,1]] /. subFermion /. A_[{}]->A;,FFieldsMultiplets [[i]]=0;];

If[Head[Fields[[i,1]]]=!=List && False==True,
If[Last[Fields[[i]]]===S,SFields[[i]]=Fields[[i,1]] /. subScalar;,SFields[[i]]=0;];
If[Last[Fields[[i]]]===F,FFields[[i]]=Fields[[i,1]] /. subFermion;,FFields[[i]]=0;];

If[Last[Fields[[i]]]===S,typeList=Join[typeList,{{SFields[[i]],S}}];];
If[Last[Fields[[i]]]===F,typeList=Join[typeList,{{FFields[[i]],F}}];];,

If[Last[Fields[[i]]]===S,
SFields[[i]]=ToExpression[ToString[Fields[[i,3]]]][absE][absIsave] /. A_[{}]->A;,
SFields[[i]]=0;];
If[Last[Fields[[i]]]===F,
FFields[[i]]=ToExpression[ToString[Fields[[i,3]]]][absE][absIsave] /. A_[{}]->A;,
FFields[[i]]=0;];


If[Head[Fields[[i,1]]]=!=List,
If[Last[Fields[[i]]]===S,
subFieldsOne=Join[subFieldsOne,{Fields[[i,3]][{c__}]->(SFieldsMultiplets [[i]] /. A_[{x__}]->A)[{c}] }];
];
If[Last[Fields[[i]]]===F,
subFieldsOne=Join[subFieldsOne,{Fields[[i,3]][{c__}][d_]->(FFieldsMultiplets [[i]]/. A_[{x__}]->A)[{c}][d]}];
];,
If[Last[Fields[[i]]]===S,
Set[ToExpression[ToString[Fields[[i,3]]]][{x__Integer}][{c__}],
Hold[If[Head[Extract[SFieldsMultiplets [[NR]],{x}]]=!=Plus,
(Extract[SFieldsMultiplets [[NR]],{x}]/(DeleteCases[Extract[SFieldsMultiplets [[NR]],{x}],y_?NumberQ,4]/.{0:>1})) DeleteCases[Extract[SFieldsMultiplets [[NR]],{x}],y_?NumberQ,4][{c}],
Sum[(Extract[SFieldsMultiplets [[NR]],{x,jj}]/(DeleteCases[Extract[SFieldsMultiplets [[NR]],{x,jj}],(y_?NumberQ|y_Delta),4]/.{0:>1})) DeleteCases[Extract[SFieldsMultiplets [[NR]],{x,jj}],(y_?NumberQ|y_Delta),4][{c}],{jj,1,Length[Extract[SFieldsMultiplets [[NR]],{x}]]}]
]] /. NR->i];
];
If[Last[Fields[[i]]]===F,
Set[ToExpression[ToString[Fields[[i,3]]]][{x__Integer}][{c__}][d_],Hold[(Extract[FFieldsMultiplets [[NR]],{x}]/DeleteCases[Extract[FFieldsMultiplets [[NR]],{x}],y_?NumberQ,4]) DeleteCases[Extract[FFieldsMultiplets [[NR]],{x}],y_?NumberQ,4][{c}][d]] /. NR->i];
];

];

If[Last[Fields[[i]]]===S,typeList=Join[typeList,{{ToExpression[ToString[Fields[[i,3]]]],S}}];];
If[Last[Fields[[i]]]===F,typeList=Join[typeList,{{ToExpression[ToString[Fields[[i,3]]]],F}}];];

];

ListFields = Join[ListFields,{{Fields[[i,3]],{absE,Expandedindizes},{absI,indizes}}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{SFields[[i]],absEFull,absIFull}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{FFields[[i]],absEFull,absIFull}}];

If[ChangedAbsI===True,
ChangedAbsI=False;
absI=absIsave;
];

i++;
];

For[i=1,i<=Length[Fields],
sumstates=1;
ind={};
For[j=1,j<=Length[Gauge],
If[Gauge[[j,2]]=!=U[1] && Fields[[i,3+j]]=!=1,
sumstates*=sum[Gauge[[j,3]],1,Abs[Fields[[i,3+j]]]];
ind = Join[ind,{Gauge[[j,3]]}];
];
j++;];
SFieldsNoTensor[[i]] = {SFields[[i]],sumstates,ind};

i++;];

ind={};
For[i=1,i<=Length[Gauge],If[Gauge[[i,2]]=!=U[1],temp=Intersection[Abs/@Select[Transpose[Fields][[3+i]],((#!=1)&)]];
ind=Join[ind,Table[{Gauge[[i,2]],temp[[j]]},{j,1,Length[temp]}]];];
i++;];

SA`Doc`EndEntry[];
];

CreateChiralSuperfields:=Block[{i,h,j,k,off,tempS1,tempF1,tempS2,tempF2,tempS1b,tempF1b,tempS2b,tempF2b,S1,F1,S2,F2,j2,diff,temp},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "CreateChiralSuperfields";
SA`Doc`Info = "Creates all chiral superfields in the case of a supersymmetric model: \n
1) The gauge and generation indices for all fields are obtained\n
2) The names of the component fields (femrion,scalar,aux) are generated\n
3) The gauge properties of all fields are calculated and stored \n
4) Replacement rules for multiplets under gauge groups which get broken are generated \n
5) The definition of the fiels are extended in a way that the replacement of the multiplets is automatically done, e.g.
(FqL[{gen,left}] /. left->1) will automatially result in by FuL[{gen}]";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

PrintDebug["   chiral superfields"];
DynamicInitFields="chiral superfields";
SFields = Table[{}, {AnzahlChiral}];
SFieldsNoTensor = Table[{}, {AnzahlChiral}];
SFieldsTensor = Table[{}, {AnzahlChiral}];
FFields = Table[{}, {AnzahlChiral}];
AFields = Table[{}, {AnzahlChiral}];

SFieldsMultiplets = Table[{}, {AnzahlChiral}];
FFieldsMultiplets = Table[{}, {AnzahlChiral}];
AFieldsMultiplets = Table[{}, {AnzahlChiral}];

SFieldList={};
FFieldList={};
AFieldList={};



For[i=1, i<= AnzahlChiral,
temp= GenerateAllIndizes[i];
indizes=temp[[1]];
Expandedindizes=temp[[2]];
absIFull=temp[[3]] //. a_Integer :>Abs[a];
absEFull=temp[[4]]//. a_Integer :>Abs[a];

absI=Table[absIFull[[j,1]],{j,1,Length[absIFull]}];
absE=Table[absEFull[[j,1]],{j,1,Length[absEFull]}];

If[Dimensions[Fields[[i,1]]]=!={} &&  Head[Fields[[i,1]]]=!=conj,
FieldNames=Intersection[DeleteCases[Flatten[Fields[[i,1]] /. Plus->List],x_?NumericQ] /.x_? NumericQ->1];,
FieldNames ={Fields[[i,1]]};
];

subScalar={};
subFermion={};
subAux={};

scalarSF = ToExpression["S"<>ToString[Fields[[i,3]]]];
fermionSF = ToExpression["F"<>ToString[Fields[[i,3]]]];
auxiliarySF = ToExpression["A"<>ToString[Fields[[i,3]]]];

For[j=1,j<=Length[FieldNames],
If[Head[FieldNames[[j]]]===conj,
name= ToString[FieldNames[[j,1]]];,
name = ToString[FieldNames[[j]]];
];

scalar = ToExpression["S"<>name];
fermion = ToExpression["F"<>name];
auxiliary = ToExpression["A"<>name];

For[j2=1,j2<=AnzahlGauge,
If[Gauge[[j2,5]]==True,
diff=Abs[Fields[[i,j2+3]]];,
diff=1;
];


Switch[Gauge[[j2,2]],
U[1],
	valueCasimir=GUTren[j2]^2 Fields[[i,j2+3]]^2;
	valueDynkin=GUTren[j2]^2 Fields[[i,j2+3]]^2;
	valueGenerator= Fields[[i,j2+3]];
	valueDyn=Fields[[i,j2+3]];
	valueDimensions=1;,
_,
	If[Fields[[i,j2+3]]==1,
	valueCasimir=0;
	valueDynkin=0;
	valueGenerator= 0;
	valueDyn={0};
	valueDimensions=1;,
	valueCasimir= SA`Casimir[getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]],Gauge[[j2,2]]];
	valueDynkin= SA`Dynkin[getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]],Gauge[[j2,2]]];
	valueDyn=getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]];
	If[Gauge[[j2,5]]===True && Gauge[[j2,2]]=!=U[1],
	valueGenerator= GeneratorB[Gauge[[j2,2]],getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]]];,
	valueGenerator= Generator[Gauge[[j2,2]],getDynkinLabels[Fields[[i,j2+3]],Gauge[[j2,2]]]];
	];
	valueDimensions=Abs[Fields[[i,j2+3]]];
	];
];

valueMulFactor=Fields[[i,2]]*Times@@(Abs/@Table[If[Gauge[[k,2]]===U[1] || k===j2,1,Fields[[i,k+3]]],{k,1,Length[Gauge]}]);

SetGroupConstants[scalar,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,True,False];
SetGroupConstants[fermion,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,True,False];
SetGroupConstants[auxiliary,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,True,False];
SetGroupConstants[Fields[[i,3]],Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,False,False];
SetGroupConstants[scalarSF,Gauge[[j2,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDynSF,If[Length[FieldNames]===1,True,False],True];

If[Gauge[[j2,2]]===U[1],
SA`ChargeGG[scalar,j2] = Fields[[i,j2+3]];
SA`ChargeGG[fermion,j2] = Fields[[i,j2+3]];
SA`ChargeGG[auxiliary,j2] = Fields[[i,j2+3]];

(*
SA`DynL[scalarSF,j2]=Fields[[i,j2+3]];
SA`DynL[Fields[[i,3]],j2]=Fields[[i,j2+3]];
*)
];

j2++;];

For[j2=1,j2<=Length[Global],
If[Head[Fields[[i,j2+3+AnzahlGauge]]]===List,
SA`ChargeGlobal[Fields[[i,3]],Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,1]];
SA`ChargeGlobal[scalarSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];
SA`ChargeGlobal[fermionSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,3]];
SA`ChargeGlobal[auxiliarySF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];
SA`ChargeGlobal[scalar,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];
SA`ChargeGlobal[fermion,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,3]];
SA`ChargeGlobal[auxiliary,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge,2]];,
SA`ChargeGlobal[Fields[[i,3]],Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[scalar,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[fermion,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[auxiliary,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[scalarSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[fermionSF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
SA`ChargeGlobal[auxiliarySF,Global[[j2,2]]] = Fields[[i,j2+3+AnzahlGauge]];
];
j2++;];

If[Head[Fields[[i,1]]]=!=List,
usedInd=absI;,
usedInd={}
];

If[Head[FieldNames[[j]]]===conj,
subScalar=Join[subScalar,{FieldNames[[j]]->conj[scalar[usedInd]]}];
subFermion=Join[subFermion,{FieldNames[[j]]->conj[fermion[usedInd]]}];
subAux=Join[subAux,{FieldNames[[j]]->conj[auxiliary[usedInd]]}];
(*
subScalar=Join[subScalar,{FieldNames[[j]]->conj[scalar]}];
subFermion=Join[subFermion,{FieldNames[[j]]->conj[fermion]}];
subAux=Join[subAux,{FieldNames[[j]]->conj[auxiliary]}]; *)
SA`QNscalar = Join[SA`QNscalar,{{scalar[absI] /. a_[{b__}]->a, Join[-Take[Fields[[i]],{4,-1}],{getRParitySF[Fields[[i,3]]]}]}}];
SA`QNfermion = Join[SA`QNfermion,{{fermion[absI]/. a_[{b__}]->a, Join[-Take[Fields[[i]],{4,-1}],{-getRParitySF[Fields[[i,3]]]}]}}];
SA`QNaux = Join[SA`QNaux,{{auxiliary[absI]/. a_[{b__}]->a,Join[-Take[Fields[[i]],{4,-1}],{getRParitySF[Fields[[i,3]]]}]}}];
SFieldList=Join[SFieldList,{conj[scalar[absI]]}];
FFieldList=Join[FFieldList,{conj[fermion[absI]]}];
AFieldList=Join[AFieldList,{conj[auxiliary[absI]]}];,

subScalar=Join[subScalar,{FieldNames[[j]]->scalar[usedInd]}];
subFermion=Join[subFermion,{FieldNames[[j]]->fermion[usedInd]}];
subAux=Join[subAux,{FieldNames[[j]]->auxiliary[usedInd]}];

(* subScalar=Join[subScalar,{FieldNames[[j]]->scalar}];
subFermion=Join[subFermion,{FieldNames[[j]]->fermion}];
subAux=Join[subAux,{FieldNames[[j]]->auxiliary}]; *)
SFieldList=Join[SFieldList,{scalar[absI]}];
FFieldList=Join[FFieldList,{fermion[absI]}];
AFieldList=Join[AFieldList,{auxiliary[absI]}];
SA`QNscalar = Join[SA`QNscalar,{{scalar[absI]/. a_[{b__}]->a,Join[Take[Fields[[i]],{4,-1}],{getRParitySF[Fields[[i,3]]]}]}}];
SA`QNfermion = Join[SA`QNfermion,{{fermion[absI]/. a_[{b__}]->a, Join[Take[Fields[[i]],{4,-1}],{-getRParitySF[Fields[[i,3]]]}]}}];
SA`QNaux = Join[SA`QNaux,{{auxiliary[absI]/. a_[{b__}]->a,Join[Take[Fields[[i]],{4,-1}],{getRParitySF[Fields[[i,3]]]}]}}];
];


addParticle[scalar,absIFull,Fields[[i,2]],S];
addParticle[fermion,absIFull,Fields[[i,2]],F];
addParticle[auxiliary,absIFull,Fields[[i,2]],A];
getElectricCharge[auxiliary]=Hold[getElectricCharge[FIELD]] /. FIELD->scalar;

j++;];


SFieldsMultiplets [[i]]=Fields[[i,1]] /. subScalar /. A_[{}]->A;
FFieldsMultiplets [[i]]=Fields[[i,1]] /. subFermion /. A_[{}]->A;
AFieldsMultiplets [[i]]=Fields[[i,1]] /. subAux /. A_[{}]->A;

(*
If[Head[Fields[[i,1]]]===List,
GenerateSubMultiplets[i,ToExpression["S"<>ToString[Fields[[i,3]]]],ToExpression["F"<>ToString[Fields[[i,3]]]],ToExpression["A"<>ToString[Fields[[i,3]]]],subScalar /. {A_[{}][b__]\[Rule]A[b],A_[{}]\[Rule]A},subFermion/. {A_[{}][b__]\[Rule]A[b],A_[{}]\[Rule]A},subAux/. {A_[{}][b__]\[Rule]A[b],A_[{}]\[Rule]A}];
];
*)
If[Head[Fields[[i,1]]]=!=List,
SFields[[i]]=Fields[[i,1]] /. subScalar;
FFields[[i]]=Fields[[i,1]] /. subFermion;
AFields[[i]]=Fields[[i,1]] /. subAux;
typeList=Join[typeList,{{SFields[[i]],S}}];
typeList=Join[typeList,{{FFields[[i]],F}}];
typeList=Join[typeList,{{AFields[[i]],A}}];,

SFields[[i]]=ToExpression["S"<>ToString[Fields[[i,3]]]][absE][absI];
FFields[[i]]=ToExpression["F"<>ToString[Fields[[i,3]]]][absE][absI];
AFields[[i]]=ToExpression["A"<>ToString[Fields[[i,3]]]][absE][absI];

Set[ToExpression["S"<>ToString[Fields[[i,3]]]][{x__Integer}][{c__}],Hold[(Extract[SFieldsMultiplets [[NR]],{x}]) /.SFieldListRep]/. NR->i /. SFieldListRep->((SFieldList /. conj[y_]->y) /. A_[{b___}]:>(A->A[{c}])) ];

Set[ToExpression["F"<>ToString[Fields[[i,3]]]][{x__Integer}][{c__}][d_],Hold[(Extract[FFieldsMultiplets [[NR]],{x}]) /.FFieldListRep]/. NR->i/. FFieldListRep->((FFieldList /. conj[y_]->y) /. A_[{b___}]:>(A->A[{c}][d])) ];

Set[ToExpression["A"<>ToString[Fields[[i,3]]]][{x__Integer}][{c__}],Hold[(Extract[AFieldsMultiplets [[NR]],{x}]) /.AFieldListRep ]/. NR->i/. ((AFieldList /. conj[y_]->y) /. A_[{b___}]:>(A->A[{c}])) ];


typeList=Join[typeList,{{ToExpression["S"<>ToString[Fields[[i,3]]]],S}}];
typeList=Join[typeList,{{ToExpression["F"<>ToString[Fields[[i,3]]]],F}}];
typeList=Join[typeList,{{ToExpression["A"<>ToString[Fields[[i,3]]]],A}}];


];

ListFields = Join[ListFields,{{Fields[[i,3]],{absE,Expandedindizes},{absI,indizes}}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{SFields[[i]],absEFull,absIFull}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{FFields[[i]],absEFull,absIFull}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{AFields[[i]],absEFull,absIFull}}]; 
(* SFieldsTensor[[i]] = {SFields[[i]],Product[sum[absEFull[[j,1]],1,absEFull[[j,2]]],{j,1,Length[absEFull]}]*Product[If[FreeQ[Gauge,absIFull[[j,1]]]\[Equal]False,sum[absIFull[[j,1]],1,absIFull[[j,2]]],1],{j,1,Length[absIFull]}],ind}; *)
i++;
];

For[i=1,i<=Length[Fields],
sumstates=1;
ind={};
For[j=1,j<=Length[Gauge],
If[Gauge[[j,2]]=!=U[1] && Fields[[i,3+j]]=!=1,
sumstates*=sum[Gauge[[j,3]],1,Abs[Fields[[i,3+j]]]];
ind = Join[ind,{Gauge[[j,3]]}];
];
j++;];
SFieldsNoTensor[[i]] = {SFields[[i]],sumstates,ind};
i++;];

ind={};
For[i=1,i<=Length[Gauge],If[Gauge[[i,2]]=!=U[1],temp=Intersection[Abs/@Select[Transpose[Fields][[3+i]],((#!=1)&)]];
ind=Join[ind,Table[{Gauge[[i,2]],temp[[j]]},{j,1,Length[temp]}]];];
i++;];

SA`Doc`EndEntry[];
];


CheckForU1mixing:=Block[{i,j},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "CheckForU1mixing";
SA`Doc`Info = "Checks if two (non-orthogonal) Abelian gauge groups are present. Also the GUT normalization as defined in parameters.m is added here to the corresponding gauge couplings (via the parameter 'GUTren')";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

DynamicInitMisc="Check for gauge kinetic mixing";
For[i=1,i<=AnzahlGauge,
If[Gauge[[i,2]]=!=U[1],
Gauge[[i]] = Join[Gauge[[i]],{1}];
SA`ListGaugeMixedAll = Join[SA`ListGaugeMixedAll,{{{i,i},{1,Gauge[[i,4]]}}}];
If[FreeQ[SA`ListGaugeMixed,Gauge[[i,4]]],
SA`ListGaugeMixed = Join[SA`ListGaugeMixed,{{{i,i},{1,Gauge[[i,4]]}}}];
];,
SA`ListGaugeMixedAll = Join[SA`ListGaugeMixedAll,{{{i,i},{1,Gauge[[i,4]]}}}];
If[FreeQ[ParameterDefinitions,Gauge[[i,4]]]==False,
pos=Position[Transpose[ParameterDefinitions][[1]],Gauge[[i,4]]];
If[FreeQ[SA`ListGaugeMixed,Gauge[[i,4]]],
SA`ListGaugeMixed = Join[SA`ListGaugeMixed,{{{i,i},{1,Gauge[[i,4]]}}}];
];
If[pos=!={},
gutRen=GUTnormalization/.Extract[ParameterDefinitions,pos[[1,1]]][[2]];
If[NumericQ[gutRen],
GUTren[i]=gutRen,
GUTren[i]= 1;
];,
GUTren[i]= 1;
];,
GUTren[i]= 1;
];
If[NoU1Mixing=!=True,
For[j=1,j<=AnzahlGauge,
If[Gauge[[j,2]]===U[1] && i!= j,
newGC = ToExpression[ToString[Gauge[[i,4]]]<>StringDrop[ToString[Gauge[[j,4]]],1]];
GaugesU1[i,j]=newGC;
GUTren[i,j]=GUTren[i];
If[FreeQ[SA`ListGaugeMixed2,newGC],
SA`ListGaugeMixed2 = Join[SA`ListGaugeMixed2,{{{i,j},{1,newGC}}}];
SA`KineticMixingParameters=Join[SA`KineticMixingParameters,{newGC}];
];
parameters=Join[parameters,{{newGC,{},{}}}];
U1MixingParameters=Join[U1MixingParameters,{newGC}];
realVar=Join[realVar,{newGC}];
];
j++;];
];
];
i++;];

SA`ListGaugeMixed = Join[SA`ListGaugeMixed,SA`ListGaugeMixed2];
SA`ListGaugeMixedAll = Join[SA`ListGaugeMixedAll,SA`ListGaugeMixed2];

(* TODO: Initialize unfixed charges *)

SA`Doc`EndEntry[];
];

CreateTensorSuperfields:=Block[{i},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "CreateTensorSuperfields";
SA`Doc`Info = "Creates gravitino fields. BE CAREFUL: implementation in a very early stage and never tested!!";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

PrintDebug["  gravitino superfields"];
DynamicInitFields="gravitino superfields";
TFields={Gmu[{lorentz}],Gol};
addParticle[Gmu,{{lorentz,4}},1,F];
addParticle[Gol,{},1,F];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{Gmu[{lorentz}],{{}},{}}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{Gol,{{}},{}}}];
typeList=Join[typeList,{{Gmu[{lorentz}],F}}];
typeList=Join[typeList,{{Gol,F}}];
diracFermions[ALL]=Join[diracFermions[ALL],{GMU}];
diracFermions[ALL]=Join[diracFermions[ALL],{GOL}];
(* diracSub[ALL]=Join[diracSub[ALL],{GMU\[Rule]{Gmu,conj[Gmu]}}]; *)
For[i=1,i<=Length[NameOfStates],
(* diracSub[NameOfStates[[i]]]=Join[diracSub[NameOfStates[[i]]],{GMU\[Rule]{Gmu,conj[Gmu]}}]; *)
diracFermions[NameOfStates[[i]]]=Join[diracFermions[NameOfStates[[i]]],{GMU}];
diracFermions[NameOfStates[[i]]]=Join[diracFermions[NameOfStates[[i]]],{GOL}];
i++;];
parameters=Join[parameters,{{MP,{},{}},{m32,{},{}}}];
realVar=Join[realVar,{MP,m32}];


SA`Doc`EndEntry[];
];


CreateVectorSuperfields:=Block[{i,h,j,k,off,tempS1,tempF1,tempS2,tempF2,tempS1b,tempF1b,tempS2b,tempF2b,S1,F1,S2,F2,j2,diff,temp,nameBasis},
SA`Doc`Name = "CreateVectorSuperfields";
SA`Doc`Info = "Creates the gauge sector for a given field. Note, even if this routine was orignally written for vector superfields in the case of a SUSY theory, it is also used for non-SUSY models (see the occurence of the Boolean variable 'SupersymmetricModel')! \n
The following steps are performed: \n
1) The names of the vectors, ghosts, gauginos and aux fields are generated \n
2) The indices are attached
3) The Casimir and Dynkin as well as global charges for each field stored ";
SA`Doc`GenerateEntry[];

PrintDebug["   vector superfields"];
DynamicInitFields="vector superfields";

SGauge=Table[{},{AnzahlGauge}]; 
FGauge=Table[{},{AnzahlGauge}]; 
gGauge=Table[{},{AnzahlGauge}]; 
aGauge=Table[{},{AnzahlGauge}];
listIndizes=Table[{},{AnzahlGauge}];

For[i=1, i<=AnzahlGauge,
If[FreeQ[parameters,Gauge[[i,4]]],
parameters=Join[parameters,{{Gauge[[i,4]],{},{}}}];
];

If[Gauge[[i,2]]=!=U[1] && Gauge[[i,5]]=!=True,
indizes={{generation,1},{getAdjointIndex[Gauge[[i,3]]],getNumberStatesAdjoint[Gauge[[i,2]]]}};,
indizes = {{generation,getNumberStatesAdjoint[Gauge[[i,2]]]}};
];

indizesVB = Join[indizes,{{lorentz,4}}];
SGauge[[i]]=ToExpression["V"<>ToString[Gauge[[i,1]]]][Flatten[DeleteCases[indizesVB,x_Integer,3]]];
FGauge[[i]]=ToExpression["f"<>ToString[Gauge[[i,1]]]][Flatten[DeleteCases[indizes,x_Integer,3]]];
gGauge[[i]]=ToExpression["g"<>ToString[Gauge[[i,1]]]][Flatten[DeleteCases[indizes,x_Integer,3]]];
aGauge[[i]]=ToExpression["a"<>ToString[Gauge[[i,1]]]][Flatten[DeleteCases[indizes,x_Integer,3]]];

typeList=Join[typeList,{{SGauge[[i]],V}}];
typeList=Join[typeList,{{FGauge[[i]],F}}];
typeList=Join[typeList,{{aGauge[[i]],A}}];
typeList=Join[typeList,{{gGauge[[i]],G}}]; 

SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{SGauge[[i]],indizes,{}}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{FGauge[[i]],indizes,{}}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{gGauge[[i]],indizes,{}}}];
SA`ListAllFieldsInit=Join[SA`ListAllFieldsInit,{{aGauge[[i]],indizes,{}}}];


SA`QNfermion = Join[SA`QNfermion,{{FGauge[[i]] /. A_[{b__}]->A, Join[Table[If[i==j,If[Gauge[[j,2]]===U[1],0,Gauge[[j,2,1]]^2-1],If[Gauge[[j,2]]===U[1],0,1]],{j,1,Length[Gauge]}],{-1}]}}];

listIndizes[[i]]=Join[listIndizes[[i]],{getAdjointIndex[Gauge[[i,3]]]}];

If[Gauge[[i,5]]===True,
nGen=getNumberStatesAdjoint[Gauge[[i,2]]];,
nGen=1;
];


addParticle[ToExpression["V"<>ToString[Gauge[[i,1]]]],indizesVB,nGen,V];
addParticle[ToExpression["g"<>ToString[Gauge[[i,1]]]],indizes,nGen,G];
If[AuxGaugesPresent===True && FreeQ[UnbrokenSubgroups,Gauge[[i,3]]]==False,
(* add the vectors and ghosts after breaking the group to the particle list *)
For[j=1,j<=Length[AuxGaugeBosons],
nameBasis=StringDrop[ToString[AuxGaugeBosons[[j,1]]],{1}];
If[AuxGaugeBosons[[j,2,2]]==1,
indizesT={};
nGen=1;,
indizesT={AuxGaugeBosons[[j,2]]};
nGen=1(* AuxGaugeBosons[[j,2,2]] *);
]; 
If[nGen==1,
indizesVBT=Join[Join[{{generation,1}},indizesT],{{lorentz,4}}];,
indizesVBT=Join[indizesT,{{lorentz,4}}];
];
addParticle[ToExpression["V"<>nameBasis],indizesVBT,nGen,V];
addParticle[ToExpression["g"<>nameBasis],indizesT,nGen,G];

(*
(*H*)(*If e.g.VX=!=conj[VX],one has to add both gX and gXC.Attention! Variables gG and VG are added to realVar by hand in the model file.*)
If[MemberQ[realVar,ToExpression["g"<>nameBasis]]\[Equal]False,
addParticle[ToExpression["g"<>nameBasis<>"C"],indizesT,nGen,G];
];
*)
realVar=Join[realVar,{ToExpression["V"<>nameBasis],ToExpression["g"<>nameBasis]}];
(* Set Group constants *)
valueDimensions=AuxGaugeBosons[[j,2,2]];
valueDyn=getDynkinLabels[valueDimensions,AuxGauge[[1,2]]];
valueDimensions=Abs[valueDimensions];
valueCasimir=If[AuxGaugeBosons[[j,2,2]]==1,0, SA`Casimir[valueDyn,AuxGauge[[1,2]]]];
valueDynkin= If[AuxGaugeBosons[[j,2,2]]==1,0,SA`Dynkin[valueDyn,AuxGauge[[1,2]]]];
valueGenerator=0; (* not needed *)
SetGroupConstants[ToExpression["V"<>nameBasis],AuxGauge[[1,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,False,False];
SetGroupConstants[ToExpression["g"<>nameBasis],AuxGauge[[1,3]],valueCasimir,valueDynkin,valueGenerator,valueMulFactor,valueDimensions,valueDyn,False,False];

j++;];
];


If[SupersymmetricModel=!=False,
addParticle[ToExpression["f"<>ToString[Gauge[[i,1]]]],indizes,nGen,F];
addParticle[ToExpression["a"<>ToString[Gauge[[i,1]]]],indizes,nGen,A];
SetGroupConstants[ToExpression["f"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]],If[Gauge[[i,2]]===U[1],0,Gauge[[i,2,1]]],If[Gauge[[i,2]]===U[1],0,Gauge[[i,2,1]]],0,1,Gauge[[i,2,1]]^2-1,If[Gauge[[i,2]]===U[1],{0},getDynkinLabels[Gauge[[i,2,1]]^2-1,Gauge[[i,2]]]],False,False];
];

Gauginos = Join[Gauginos,{FGauge[[i]]}];
Gauginos = Join[Gauginos,{FGauge[[i]] /. diracSubBack1[ALL]}];
bosons=Join[bosons,{SGauge[[i]]}];
OnlyOneGen=Join[OnlyOneGen,{FGauge[[i]],FGauge[[i]] /. diracSubBack1[ALL],SGauge[[i]],gGauge[[i]]}];
If[Gauge[[i,3]]===color,
ColoredGaugeParticles=Join[ColoredGaugeParticles,{aGauge[[i]],FGauge[[i]],FGauge[[i]] /. diracSubBack1[ALL],SGauge[[i]],gGauge[[i]]}];
OnlyOneGen=Join[OnlyOneGen,{aGauge[[i]]}];
];
realVar=Join[realVar,{Head[SGauge[[i]]],Head[gGauge[[i]]],Head[aGauge[[i]]],Gauge[[i,4]]}];



SA`NewGaugeBosons =bosons;

For[j2=1,j2<=Length[Global],
If[Head[Gauge[[i,j2+5]]]===List,
SA`ChargeGlobal[ToExpression["V"<>ToString[Gauge[[i,1]]]],Global[[j2,2]]] =Gauge[[i,j2+5,3]];
SA`ChargeGlobal[ToExpression["f"<>ToString[Gauge[[i,1]]]],Global[[j2,2]]] = Gauge[[i,j2+5,2]];
SA`ChargeGlobal[ToExpression["g"<>ToString[Gauge[[i,1]]]],Global[[j2,2]]] = Gauge[[i,j2+5,3]];,
SA`ChargeGlobal[ToExpression["V"<>ToString[Gauge[[i,1]]]],Global[[j2,2]]] =Gauge[[i,j2+5]];
SA`ChargeGlobal[ToExpression["f"<>ToString[Gauge[[i,1]]]],Global[[j2,2]]] =Gauge[[i,j2+5]];
SA`ChargeGlobal[ToExpression["g"<>ToString[Gauge[[i,1]]]],Global[[j2,2]]] =Gauge[[i,j2+5]];
];
j2++;];

If[Gauge[[i,2]]=!=U[1],
SA`Casimir[ToExpression["V"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Casimir[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
SA`Casimir[ToExpression["g"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Casimir[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
If[SupersymmetricModel=!=False,
SA`Casimir[ToExpression["f"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Casimir[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
SA`Casimir[ToExpression["a"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Casimir[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
];


SA`Dynkin[ToExpression["V"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Dynkin[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
SA`Dynkin[ToExpression["g"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Dynkin[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
If[SupersymmetricModel=!=False,
SA`Dynkin[ToExpression["f"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Dynkin[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
SA`Dynkin[ToExpression["a"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=SA`Dynkin[getDynkinLabelsAdjoint[Gauge[[i,2]]],Gauge[[i,2]]];
];

SA`DynL[ToExpression["V"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`DynL[ToExpression["g"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
If[SupersymmetricModel=!=False,
SA`DynL[ToExpression["f"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=getDynkinLabelsAdjoint[Gauge[[i,2]]];SA`DynL[ToExpression["a"<>ToString[Gauge[[i,1]]]],Gauge[[i,3]]]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
];
];
For[j2=1,j2<=Length[Gauge],
If[i=!=j2,
SA`DynL[ToExpression["V"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]={0};
SA`DynL[ToExpression["g"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]={0};
SA`Dynkin[ToExpression["V"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
SA`Dynkin[ToExpression["g"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
SA`Casimir[ToExpression["V"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
SA`Casimir[ToExpression["g"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
If[SupersymmetricModel=!=False,
SA`DynL[ToExpression["f"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]={0};
SA`DynL[ToExpression["a"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]={0};
SA`Dynkin[ToExpression["f"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
SA`Dynkin[ToExpression["a"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
SA`Casimir[ToExpression["f"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
SA`Casimir[ToExpression["a"<>ToString[Gauge[[i,1]]]],Gauge[[j2,3]]]=0;
];
(*,
SA`DynL[ToExpression["V"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`DynL[ToExpression["g"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Dynkin[ToExpression["V"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Dynkin[ToExpression["g"<>ToString[Gauge[[i,1]]]],j2]getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Casimir[ToExpression["V"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Casimir[ToExpression["g"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
If[SupersymmetricModel=!=False,
SA`DynL[ToExpression["f"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`DynL[ToExpression["a"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Dynkin[ToExpression["f"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Dynkin[ToExpression["a"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Casimir[ToExpression["f"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
SA`Casimir[ToExpression["a"<>ToString[Gauge[[i,1]]]],j2]=getDynkinLabelsAdjoint[Gauge[[i,2]]];
];*)
];
j2++;];
i++;
];

(*
For[i=1,i\[LessEqual]Length[SA`CasimirList],
SA`Casimir[getBlank[ToExpression["S"<>ToString[Fields[[SA`CasimirList[[i,1]],3]]]]],SA`CasimirList[[i,2]]]=SA`CasimirList[[i,3]];
SA`Casimir[getBlank[getBlank[SFields[[SA`CasimirList[[i,1]]]]]],SA`CasimirList[[i,2]]]=SA`CasimirList[[i,3]];
SA`Dynkin[getBlank[getBlank[SFields[[SA`CasimirList[[i,1]]]]]],SA`CasimirList[[i,2]]]=SA`CasimirList[[i,4]];
SA`Casimir[Fields[[SA`CasimirList[[i,1]],3]],SA`CasimirList[[i,2]]]=SA`CasimirList[[i,3]];
SA`Dynkin[Fields[[SA`CasimirList[[i,1]],3]],SA`CasimirList[[i,2]]]=SA`CasimirList[[i,4]];
SA`Dynkin[ToExpression["S"<>ToString[Fields[[SA`CasimirList[[i,1]],3]]]],SA`CasimirList[[i,2]]]=SA`CasimirList[[i,4]];
i++;];
*)

SA`Doc`EndEntry[];
];

CreateSubstitutions:= Block[{i,h,j,k,off,tempS1,tempF1,tempS2,tempF2,tempS1b,tempF1b,tempS2b,tempF2b,S1,F1,S2,F2,j2,diff,temp},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "CreateSubstitutions";
SA`Doc`Info = "Creates many different lists containing substitutions for the indices carried by particles/parameters and the necessary functions to use them. For instance \n
generation/. subGC[1] reutrns gen1 \n
The main important lists are \n:
- subIndizes / subGC: used to replace a generic index (e.g. generation, color) by a numbered one (e.g. gen1,col2) \n
- subIndizesRE / subGCRE: re-defines an index, e.g. (gen1,col1) -> (gen2,col2) \n
- subIndizesFinal / subIndFinal: replaces 'Lagrangian indices' (e.g. gen1,col2) by 'Final indices' used in vertices (e.g. gt1,ct2) \n
- subIndixesFinalX / subIndFinalX: replaces 'Lagrangian indices' (e.g. gen1,col2) by 'Final indices' with a self-chosen letter (e.g. gX1, cX2)
- subIndizesRule / subGCRule: replaces a generic index by a pattern, e.g. (generations, color) -> (gen1_, col2_) \n
- subGCInt / subGCInt: replaces a Lagrangian index my an internal index, e.g. (gen1, col2) -> (aaIgen1,aaIcol2)
- subIndizesValue / subValue: replaces a Lagrangian index by a number, e.g. (col1, col2) -> (1,2) \n ";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];


PrintDebug["    Create Substitution rules"];
DynamicInitMisc="Create substitution rules";
subIndizes={};
subIndizesRE={};
subIndizesRE2={};
subIndizesREFinal={};
subIndizesFinal={};
subIndizesFinalX={};
subIndizesInt={};
subIndizesMixStart={};
subIndizesMixEnde={};
subIndizesValue={};
subIndizesRule={};



GaugeTemp=Gauge;
(*Make sure to get all replacement rules for the remaining charges *)
If[AuxGaugesPresent===True,Gauge=Join[Gauge,AuxGauge];]

For[i=1,i<=Length[Gauge],
For[j=1,j<=7,
subIndizes=Join[subIndizes,{ToExpression[ToString[Gauge[[i,3]]]<>appendIndex[[j]]]->(Hold[ToExpression[basis<>ToString[number]<>app]]/.{basis->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]})}];
subIndizesRule=Join[subIndizesRule,{ToExpression[ToString[Gauge[[i,3]]]<>appendIndex[[j]]]->(Hold[ToExpression[basis<>ToString[number]<>app<>"_"]]/.{basis->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]})}];
subIndizesRE=Join[subIndizesRE,{(Hold[ToExpression[basis<>ToString[number1]<>app]]->Hold[ToExpression[basis<>ToString[number2]<>app]])/.{basis->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]}}];
If[Head[Gauge[[i,2]]]===SU,subIndizesRE2=Join[subIndizesRE2,{(Hold[ToExpression[basis<>ToString[number1]<>app]]->Hold[ToExpression[basis<>ToString[number2]<>app]])/.{basis->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]}}];];
subIndizesREFinal=Join[subIndizesREFinal,{(Hold[ToExpression[basis<>ToString[number1]<>app]]->Hold[ToExpression[basis<>ToString[number2]<>app]])/.{basis->(StringTake[ToString[Gauge[[i,3]]],1]<>"t"),app->appendIndex[[j]]}}];
subIndizesFinal=Join[subIndizesFinal,{(Hold[ToExpression[basis1<>ToString[number1]<>app]]->Hold[ToExpression[basis2<>ToString[number2]<>app]])/.{basis1->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]],basis2->(StringTake[ToString[Gauge[[i,3]]],1]<>"t")}}];
subIndizesFinalX=Join[subIndizesFinalX,{(Hold[ToExpression[basis1<>ToString[number1]<>app]]->Hold[ToExpression[basis2<>xname<>ToString[number2]<>app]])/.{basis1->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]}/.basis2->(StringTake[ToString[Gauge[[i,3]]],1])}];
subIndizesValue=Join[subIndizesValue,{(Hold[ToExpression[basis1<>ToString[number1]<>app]]->Hold[number2])/.{basis1->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]}}];
subIndizesInt=Join[subIndizesInt,{(Hold[ToExpression[basis<>ToString[number]<>app]]/.{basis->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]})->(Hold[ToExpression["aaI"<>basis<>ToString[1]<>app]]/.{basis->StringTake[ToString[Gauge[[i,3]]],3],app->appendIndex[[j]]})}];
subIndizesMixStart=Join[subIndizesMixStart,{ToExpression[ToString[Gauge[[i,3]]]<>appendIndex[[j]]]->ToExpression[StringTake[ToString[Gauge[[i,3]]],3]<>appendIndex[[j]]<>ToString[_]]}];
subIndizesMixEnde=Join[subIndizesMixEnde,{ToExpression[ToString[Gauge[[i,3]]]<>appendIndex[[j]]]->ToExpression[StringTake[ToString[Gauge[[i,3]]]<>appendIndex[[j]],3]]}];
j++;];
i++;];


subIndizes = Join[subIndizes,{generation ->Hold[ToExpression["gen"<>ToString[number]]],flavor ->Hold[ToExpression["fla"<>ToString[number]]],lorentz ->Hold[ToExpression["lor"<>ToString[number]]]}];
subIndizesRule = Join[subIndizesRule,{generation ->Hold[ToExpression["gen"<>ToString[number]<>"_"]],flavor ->Hold[ToExpression["fla"<>ToString[number]<>"_"]],lorentz ->Hold[ToExpression["lor"<>ToString[number]<>"_"]]}];
subIndizesInt = Join[subIndizesInt,{Hold[ToExpression["gen"<>ToString[number]]]->Hold[ToExpression["aaIgen"<>ToString[1]]],Hold[ToExpression["fla"<>ToString[number]]]->Hold[ToExpression["aaIfla"<>ToString[1]]],Hold[ToExpression["lor"<>ToString[number]]]->Hold[ToExpression["aaIlor"<>ToString[1]]]}];
subIndizesRE = Join[subIndizesRE,{Hold[ToExpression["gen"<>ToString[number1]]]->Hold[ToExpression["gen"<>ToString[number2]]],Hold[ToExpression["fla"<>ToString[number1]]]->Hold[ToExpression["fla"<>ToString[number2]]],Hold[ToExpression["lor"<>ToString[number1]]] ->Hold[ToExpression["lor"<>ToString[number2]]]}];
subIndizesRE2 = Join[subIndizesRE2,{Hold[ToExpression["gen"<>ToString[number1]]]->Hold[ToExpression["gen"<>ToString[number2]]],Hold[ToExpression["fla"<>ToString[number1]]]->Hold[ToExpression["fla"<>ToString[number2]]],Hold[ToExpression["lor"<>ToString[number1]]] ->Hold[ToExpression["lor"<>ToString[number2]]]}];
subIndizesREFinal = Join[subIndizesRE,{Hold[ToExpression["gt"<>ToString[number1]]]->Hold[ToExpression["gt"<>ToString[number2]]],Hold[ToExpression["ft"<>ToString[number1]]]->Hold[ToExpression["ft"<>ToString[number2]]],Hold[ToExpression["lt"<>ToString[number1]]] ->Hold[ToExpression["lt"<>ToString[number2]]]}];
subIndizesFinal = Join[subIndizesFinal,{Hold[ToExpression["gen"<>ToString[number1]]]->Hold[ToExpression["gt"<>ToString[number2]]],Hold[ToExpression["fla"<>ToString[number1]]]->Hold[ToExpression["ft"<>ToString[number2]]],Hold[ToExpression["lor"<>ToString[number1]]] ->Hold[ToExpression["lt"<>ToString[number2]]]}];
subIndizesFinalX = Join[subIndizesFinalX,{Hold[ToExpression["gen"<>ToString[number1]]]->Hold[ToExpression["g"<>xname<>ToString[number2]]],Hold[ToExpression["fla"<>ToString[number1]]]->Hold[ToExpression["f"<>xname<>ToString[number2]]],Hold[ToExpression["lor"<>ToString[number1]]] ->Hold[ToExpression["l"<>xname<>ToString[number2]]]}];
subIndizesMixStart=Join[subIndizesMixStart,{generation->xgen_,flavor->fla_,lorentz->lor_}];
subIndizesMixEndeNoFV=Join[subIndizesMixEnde,{generation->xgen, lorentz->lor, flavor ->Hold[ToExpression["fla"<>StringDrop[ToString[xgen],3]]]}]; 
subIndizesMixEnde=Join[subIndizesMixEnde,{generation->Hold[ToExpression["n"<>StringDrop[ToString[xgen],3]]], lorentz->lor, flavor ->fla}]; 


subGC[nr_]:=Return[ReleaseHold[subIndizes /. number ->nr]];
subGCRule[nr_]:=Return[ReleaseHold[subIndizesRule /. number ->nr]];
subGCInt[nr_]:=Return[ReleaseHold[subIndizesInt/. {number ->nr}]];
subGCRE[nr1_,nr2_]:=Return[ReleaseHold[subIndizesRE /. {number1 ->nr1, number2->nr2}]];
subREfinal[nr1_,nr2_]:=Return[ReleaseHold[subIndizesREFinal /. {number1 ->nr1, number2->nr2}]];
subIndFinal[nr1_,nr2_]:=Return[ReleaseHold[subIndizesFinal /. {number1 ->nr1, number2->nr2}]];
subIndFinalX[nr1_,nr2_,x_]:=Return[ReleaseHold[subIndizesFinalX /. {number1 ->nr1, number2->nr2,xname->x}]];
subValue[nr1_,nr2_]:=Return[ReleaseHold[subIndizesValue /. {number1 ->nr1, number2->nr2}]];



makeSubFinalIndizes;
Gauge=GaugeTemp;

SA`Doc`EndEntry[];
];



CheckForMajoranas:=Block[{i},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "CheckForMajoranas";
SA`Doc`Info = "Checks which fermions are Majorana and stores that information in the list 'MajoranaPart'";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

MajoranaPart={};

For[i=1,i<=Length[diracSub[ALL]],
If[{conj[diracSub[ALL][[i,2,2]]],conj[diracSub[ALL][[i,2,1]]]}==={diracSub[ALL][[i,2,1]],diracSub[ALL][[i,2,2]]},
MajoranaPart = Join[MajoranaPart,{diracSub[ALL][[i,1]]}];
];
i++;];

SA`Doc`EndEntry[];
];

DeleteFields:=Block[{i},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "DeleteFields";
SA`Doc`Info = "Deletes fields, i.e. fields declared to be deleted in the model file are removed from the (low-energy) Lagrangian.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

deleteTemp= DeleteParticles;
DeleteParticles={};

For[i=1,i<=Length[deleteTemp],
If[FreeQ[Fields,deleteTemp[[i]]]==True,
DeleteParticles=Join[DeleteParticles,{deleteTemp[[i]]}];,
pos=Position[Fields,deleteTemp[[i]]][[1,1]];
If[Length[Intersection[DeleteCases[Flatten[SFieldsMultiplets[[pos]]],x_?NumberQ,4]]]==1,
DeleteParticles=Join[DeleteParticles,{getBlank[Intersection[DeleteCases[Flatten[SFieldsMultiplets[[pos]]],x_?NumberQ,4]]]}];
DeleteParticles=Join[DeleteParticles,{getBlank[Intersection[DeleteCases[Flatten[FFieldsMultiplets[[pos]]],x_?NumberQ,4]]]}];DeleteParticles=Join[DeleteParticles,{getBlank[Intersection[DeleteCases[Flatten[AFieldsMultiplets[[pos]]],x_?NumberQ,4]]]}];,
DeleteParticles=Join[DeleteParticles,Intersection[DeleteCases[Flatten[SFieldsMultiplets[[pos]]],x_?NumberQ,4]]];
DeleteParticles=Join[DeleteParticles,Intersection[DeleteCases[Flatten[FFieldsMultiplets[[pos]]],x_?NumberQ,4]]];
DeleteParticles=Join[DeleteParticles,Intersection[DeleteCases[Flatten[AFieldsMultiplets[[pos]]],x_?NumberQ,4]]];
];
];
i++;];

For[i=1,i<=Length[NameOfStates],
InitSMParameters[NameOfStates[[i]]];
i++;];

SA`Doc`EndEntry[];
];


 InitParameters := Block[{i,k,max},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "InitParameters";
SA`Doc`Info = "Initialises the parameters in the model and stores dependences among them.";
SA`Doc`Input={};
SA`Doc`GenerateEntry[];

PrintDebug["Generate Parameter Dependences"];
DynamicInitMisc="Generate parameter dependences";

MayBeParameters={};

For[i=1,i<=Length[ParameterDefinitions],
If[((Dependence /. ParameterDefinitions[[i,2]])=!= Dependence) &&
((Dependence /. ParameterDefinitions[[i,2]])=!= None),
dep=Dependence /. ParameterDefinitions[[i,2]];
If[Head[dep]=!= List,
max=0;
If[FreeQ[dep,index1]==False, max=1;];
If[FreeQ[dep,index2]==False, max=2;];
If[FreeQ[dep,index3]==False, max=3;];

temp =RE[dep /. sum[a_,b_,c_]->1 /. Delta[a_,b_]->1];



Switch[max,
0,subAlways = Join[subAlways,{ParameterDefinitions[[i,1]]->dep}];
NewParameters=Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],x_?AtomQ];,
1,subAlways = Join[subAlways,{ParameterDefinitions[[i,1]][index1_]->dep}];
NewParameters=Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],x_[a_]] /. x_[a_]->x;,
2,subAlways = Join[subAlways,{ParameterDefinitions[[i,1]][index1_,index2_]->dep}];
NewParameters=Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],x_[a_,b_]]/. x_[a_,b_]->x;,
3,subAlways = Join[subAlways,{ParameterDefinitions[[i,1]][index1_,index2_,index3_]->dep}];
NewParameters=Cases[DeleteCases[Cases[temp,SymbolQ_,3],x_?NumericQ,2],x_[a_,b_,c_]]/. x_[a_,b_,c_]->x;
];

For[k=1,k<=Length[NewParameters],
If[FreeQ[MayBeParameters,NewParameters[[k]]],
MayBeParameters=Join[MayBeParameters,{{NewParameters[[k]],Table[generation,{max}],GetDimParameters[ParameterDefinitions[[i,1]]]}}];
];
k++;];


];
];
i++;];


PrintDebug["Set Information for Rotations"];
DynamicInitMisc="Set information for rotations";

For[i=1,i<=Length[FieldRotations],
If[FreeQ[parameters,FieldRotations[[i,2]]]==True,
parameters = Join[parameters,{{FieldRotations[[i,2]],{generation,generation},{getGen[getScalar[FieldRotations[[i,1,1]]]],getGen[getScalar[FieldRotations[[i,1,1]]]]}}}];
];
i++;];

DynamicInitMisc="All Done";

SA`Doc`EndEntry[];
];

(*-------------------------------------------*)
(* VEVs *)
(*-------------------------------------------*)

GenerateVEVs[type_] := Block[{i,j,i2,vev,pos,form,scalarform,alignment},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "GenerateVEVs";
SA`Doc`Info = "Responsible for re-writing (complex) scalars into CP-eigenstates and a VEV. Optionally, the VEV can be also complex or a phase can be included. Moreoever, in the case that the particle, which gets a VEV, is a multiplet, the VEVs can be aligned with a specific entry of the field. The following steps are performed: \n
1) Checking if an alignment or CP phases are defined \n
2) Creating lists to replace the complex field by the CP components and the VEV
3) Creating lists for the inverse replacement (needed for gauge fixing terms) \n
4) Checking the global and local charges of the CP eigenstates \n 
5) Storing all information about the replacements";
SA`Doc`Input={"type"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

title=ToString[type];

PrintAll["Parametrize Higgs Sector"];
newRealStates={};
tempVEVparameters={};
ScalarHiggsFields={};
PseudoScalarHiggsFields={};

tempVEVgenScalar = {};
tempVEVgenPseudoScalar ={};

vevSub={};
vevSubInverse={};
vev = DEFINITION[type][VEVs] /. Delta[a__]->1;

If[Head[Head[vev]]===DEFINITION,vev={}];



For[i=1,i<=Length[vev],
pos=Position[Transpose[ParameterDefinitions][[1]],vev[[i,2,1]]];
scalarform=False;
realVEV=True;vevPhase = 1;complexVEVs=False;


alignment=1;
If[Depth[vev[[i,2,1]]]>1,
(* alignment=Delta[x,vev[[i,2,1,1]]]; *)
alignment=Plus@@((Delta[x,#])&)/@vev[[i,2,1]];
vev[[i,2,1]]=vev[[i,2,1]] /. A_[b_Integer,c___]->A;
scalarform=True;
];

If[pos=!={},
If[(Form /.  ParameterDefinitions[[pos[[1,1]],2]])===Scalar,
vev[[i,2,1]][{x__}]=vev[[i,2,1]];
scalarform=True;
];
];


If[Length[vev[[i]]]==5,
realVEV=False;
SA`CPViolationHiggsSector=True;
If[Length[vev[[i,5]]]===2,
complexVEVs=True;
If[alignment=!=1,
vev[[i,3,1]]=vev[[i,3,1]] /. A_[b_Integer]->A;
];
vevPhase=vev[[i,3,1]];
vev[[i]]=Join[vev[[i]],{vev[[i,3]]}];
vev[[i]]=Delete[vev[[i]],3];,
vevPhase=vev[[i,5,1]];
];,
If[FreeQ[ParticlePhases,vev[[i,1]]]===False,
realVEV=True;
SA`CPViolationHiggsSector=True;
complexVEVs=False;
vevPhase=1;
];
];

pos=Position[Transpose[ParameterDefinitions][[1]],vev[[i,2,1]]];

If[pos=!={},
If[(Real/.ParameterDefinitions[[pos[[1,1]]]][[2]])===False,
SA`CPViolationHiggsSector=True;
realVEVexplizit=False;,
realVEVexplizit=True;];
];


If[realVEV==True,
vevSub = Join[vevSub,{vev[[i,1]][x_]->vev[[i,2,2]]*vev[[i,2,1]][x]*alignment+Sum[vev[[i,n,2]]*vev[[i,n,1]][x],{n,3,4}]}] /. 0[a__]->0;
vevSubInverse = Join[vevSubInverse,{vev[[i,3,1]][x_]-> 
- vev[[i,3,2]](vev[[i,1]][x]-conj[vev[[i,1]][x]]),vev[[i,4,1]][x_]-> 
vev[[i,4,2]](vev[[i,1]][x]+conj[vev[[i,1]][x]]-2 vev[[i,2,1]][x] )}]/. 0[a__]->0;,

If[complexVEVs===True,
vevSub = Join[vevSub,{vev[[i,1]][x_]->((vev[[i,2,2]]*vev[[i,2,1]][x]+vev[[i,5,2]]*vev[[i,5,1]][x])*alignment+Sum[vev[[i,n,2]]*vev[[i,n,1]][x],{n,3,4}])}]/. 0[a__]->0;
vevSubInverse = Join[vevSubInverse,{vev[[i,3,1]][x_]-> 
- vev[[i,3,2]](vev[[i,1]][x]-conj[vev[[i,1]][x]]),vev[[i,4,1]][x_]-> 
vev[[i,4,2]](vev[[i,1]][x]+conj[vev[[i,1]][x]]-2 vev[[i,2,1]][x] )}]/. 0[a__]->0;,
vevSub = Join[vevSub,{vev[[i,1]][x_]->Exp[I vevPhase[x]](vev[[i,2,2]]*vev[[i,2,1]][x]*alignment+Sum[vev[[i,n,2]]*vev[[i,n,1]][x],{n,3,4}])}]/. 0[a__]->0;
vevSubInverse = Join[vevSubInverse,{vev[[i,3,1]][x_]-> 
- vev[[i,3,2]](vev[[i,1]][x]-conj[vev[[i,1]][x]])Exp[-I vevPhase[x]],vev[[i,4,1]][x_]-> 
vev[[i,4,2]](vev[[i,1]][x]+conj[vev[[i,1]][x]]-2 vev[[i,2,1]][x] )Exp[-I vevPhase[x]]}]/. 0[a__]->0;
];
]; 

If[FreeQ[parameters,vev[[i,2,1]]] && vev[[i,2,1]]=!=0 && vev[[i,2,2]]=!=0,
tempVEVparameters = Join[tempVEVparameters,{vev[[i,2,1]]}];
If[realVEV==False,tempVEVparameters=Join[tempVEVparameters,{vevPhase}];
If[alignment===1,
tempVEVgenPseudoScalar=Join[tempVEVgenPseudoScalar,{{1,getGen[vev[[i,1]]]}}];
If[vevPhase=!=0,addParticle[vevPhase,getIndizesWI[vev[[i,1]]],getGen[vev[[i,1]]],VEV];];,
tempVEVgenPseudoScalar=Join[tempVEVgenPseudoScalar,{{Min[Flatten[alignment /. Plus->List /. Delta->List /.x->99]],Max[Flatten[alignment /. Plus->List /. Delta->List/.x->0]]}}];
addParticle[vevPhase,{{generation,Count[{alignment},Delta[a__],5]}},{Min[Flatten[alignment /. Plus->List /. Delta->List/.x->99]],Max[Flatten[alignment /. Plus->List /. Delta->List/.x->0]]},VEV];
];
];
If[alignment===1,
tempVEVgenScalar=Join[tempVEVgenScalar,{{1,getGen[vev[[i,1]]]}}];
addParticle[ vev[[i,2,1]],getIndizesWI[vev[[i,1]]],getGen[vev[[i,1]]],VEV];,
tempVEVgenScalar=Join[tempVEVgenScalar,{{Min[Flatten[alignment /. Plus->List /. Delta->List /.x->99]],Max[Flatten[alignment /. Plus->List /. Delta->List/.x->0]]}}];
addParticle[ vev[[i,2,1]],{{generation,Count[{alignment},Delta[a__],5]}},{Min[Flatten[alignment /. Plus->List /. Delta->List /.x->99]],Max[Flatten[alignment /. Plus->List /. Delta->List/.x->0]]},VEV];
];
If[getGen[vev[[i,1]]]=!=1 (* && scalarform\[Equal]False *),
If[realVEV==False,parameters = Join[parameters, {{ vevPhase, {generation}, {getGen[vev[[i,1]]]}}}];];
parameters = Join[parameters, {{ vev[[i,2,1]], {generation}, {getGen[vev[[i,1]]]}}}];,
parameters = Join[parameters, {{ vev[[i,2,1]], {}, {1}}}];
If[realVEV==False && vevPhase=!=0,parameters = Join[parameters, {{ vevPhase, {}, {1}}}];];
];,
tempVEVgenScalar=Join[tempVEVgenScalar,{{1,0}}];
tempVEVgenPseudoScalar=Join[tempVEVgenPseudoScalar,{{1,0}}];
];
If[vev[[i,3,1]]=!=0,addParticle[ vev[[i,3,1]],getIndizesWI[vev[[i,1]]],getGen[vev[[i,1]]],getType[vev[[i,1]]]];];
If[vev[[i,4,1]]=!=0,addParticle[ vev[[i,4,1]],getIndizesWI[vev[[i,1]]],getGen[vev[[i,1]]],getType[vev[[i,1]]]];];
If[vev[[i,4,1]]=!=0,ScalarHiggsFields = Join[ScalarHiggsFields,{vev[[i,4,1]]}];];
If[vev[[i,3,1]]=!=0,PseudoScalarHiggsFields = Join[PseudoScalarHiggsFields,{vev[[i,3,1]]}];];

For[i2=1,i2<=AnzahlGauge,
 If[FreeQ[BrokenSymmetries,i2]==True,
If[vev[[i,3,1]]=!=0,
SA`Casimir[vev[[i,3,1]],Gauge[[i2,3]]]=SA`Casimir[vev[[i,1]],Gauge[[i2,3]]];
SA`Dynkin[vev[[i,3,1]],Gauge[[i2,3]]]=SA`Dynkin[vev[[i,1]],Gauge[[i2,3]]];
MultiplicityFactor[vev[[i,3,1]],Gauge[[i2,3]]]=MultiplicityFactor[vev[[i,1]],Gauge[[i2,3]]];
SA`DimensionGG[vev[[i,3,1]],Gauge[[i2,3]]]=SA`DimensionGG[vev[[i,1]],Gauge[[i2,3]]];
SA`DynL[vev[[i,3,1]],Gauge[[i2,3]]]=SA`DynL[vev[[i,1]],Gauge[[i2,3]]];
];
If[vev[[i,4,1]]=!=0,
SA`Casimir[vev[[i,4,1]],Gauge[[i2,3]]]=SA`Casimir[vev[[i,1]],Gauge[[i2,3]]];
SA`Dynkin[vev[[i,4,1]],Gauge[[i2,3]]]=SA`Dynkin[vev[[i,1]],Gauge[[i2,3]]];
MultiplicityFactor[vev[[i,4,1]],Gauge[[i2,3]]]=MultiplicityFactor[vev[[i,1]],Gauge[[i2,3]]];
SA`DimensionGG[vev[[i,4,1]],Gauge[[i2,3]]]=SA`DimensionGG[vev[[i,1]],Gauge[[i2,3]]];
SA`DynL[vev[[i,4,1]],Gauge[[i2,3]]]=SA`DynL[vev[[i,1]],Gauge[[i2,3]]];
];
If[Gauge[[i2,2]]===U[1],
If[vev[[i,3,1]]=!=0,SA`ChargeGG[vev[[i,3,1]],Gauge[[i2,3]]]=SA`ChargeGG[vev[[i,1]],Gauge[[i2,3]]];];
If[vev[[i,4,1]]=!=0,SA`ChargeGG[vev[[i,4,1]],Gauge[[i2,3]]]=SA`ChargeGG[vev[[i,1]],Gauge[[i2,3]]];];
];
];
i2++;];

For[i2=1,i2<=Length[AuxGauge],
SA`Casimir[vev[[i,3,1]],AuxGauge[[i2,3]]]=SA`Casimir[vev[[i,1]],AuxGauge[[i2,3]]];
SA`Dynkin[vev[[i,3,1]],AuxGauge[[i2,3]]]=SA`Dynkin[vev[[i,1]],AuxGauge[[i2,3]]];
SA`DimensionGG[vev[[i,3,1]],AuxGauge[[i2,3]]]=SA`DimensionGG[vev[[i,1]],AuxGauge[[i2,3]]];
SA`DynL[vev[[i,3,1]],AuxGauge[[i2,3]]]=SA`DynL[vev[[i,1]],AuxGauge[[i2,3]]];
MultiplicityFactor[vev[[i,3,1]],AuxGauge[[i2,3]]]=MultiplicityFactor[vev[[i,1]],AuxGauge[[i2,3]]];
i2++;];
If[vev[[i,4,1]]=!=0,
For[i2=1,i2<=Length[AuxGauge],
SA`Casimir[vev[[i,4,1]],AuxGauge[[i2,3]]]=SA`Casimir[vev[[i,1]],AuxGauge[[i2,3]]];
SA`Dynkin[vev[[i,4,1]],AuxGauge[[i2,3]]]=SA`Dynkin[vev[[i,1]],AuxGauge[[i2,3]]];
SA`DimensionGG[vev[[i,4,1]],AuxGauge[[i2,3]]]=SA`DimensionGG[vev[[i,1]],AuxGauge[[i2,3]]];
SA`DynL[vev[[i,4,1]],AuxGauge[[i2,3]]]=SA`DynL[vev[[i,1]],AuxGauge[[i2,3]]];
MultiplicityFactor[vev[[i,4,1]],AuxGauge[[i2,3]]]=MultiplicityFactor[vev[[i,1]],AuxGauge[[i2,3]]];
i2++;];
];


For[i2=1,i2<=Length[Global],
If[vev[[i,3,1]]=!=0,
SA`ChargeGlobal[vev[[i,3,1]],Global[[i2,2]]] =SA`ChargeGlobal[vev[[i,1]],Global[[i2,2]]];
 ];
If[vev[[i,4,1]]=!=0,
SA`ChargeGlobal[vev[[i,4,1]],Global[[i2,2]]] =SA`ChargeGlobal[vev[[i,1]],Global[[i2,2]]];
];
i2++;];


If[vev[[i,3,1]]=!=0,realVar=Join[realVar,{vev[[i,3,1]]}];];
If[vev[[i,4,1]]=!=0,realVar=Join[realVar,{vev[[i,4,1]]}];];

(*
If[vev[[i,3,1]]=!=0,newRealStates=Join[newRealStates,{vev[[i,3,1]]}];];
If[vev[[i,4,1]]=!=0,newRealStates=Join[newRealStates,{vev[[i,4,1]]}];];
*)
If[realVEVexplizit===True,
realVar=Join[realVar,{vev[[i,2,1]]}];
];

If[realVEV==False, realVar=Join[realVar,{vevPhase}]];
If[complexVEVs===True,realVar=Join[realVar,{vev[[i,2,1]],vev[[i,5,1]]}];];
delParticle[vev[[i,1]]];
i++];

If[IgnoreGaugeFixing===True,
vevSubInverse={};
];

VevSub[type]=vevSub;
VevSubInverse[type]=vevSubInverse;

SA`VEVsAndPhases[type]=tempVEVparameters;
SA`VEVsGenScalar[type]=tempVEVgenScalar;
SA`VEVsGenPseudoScalar[type]=tempVEVgenPseudoScalar;
SA`ScalarHF[type] = ScalarHiggsFields;
SA`PseudoScalarHF[type] = PseudoScalarHiggsFields;

If[IgnoreGaugeFixing=!=True,
UpdateGaugeTransformations[vevSub,vevSubInverse,UGTvev[rotNr]];
];


SA`Doc`EndEntry[];
];



InitSMParameters[Eigenstates_] :=Block[{i,j,k,tempName},
SA`Doc`File = "Package/init.nb";
SA`Doc`Name = "InitSMParameters";
SA`Doc`Info = "Checks the definition in the parameters and particles file if the 'Description' statement refers to known parameters and particles. When this is the case it assign the internal SARAH name of the particle/parameter to  a new Symbol which can be used in the following to refer to that particle/parameter without the need to know how it is called in the model under consideration. In addition, special list are created to save the name of non-SM particles. That make life easier when the decay routine with SPheno are written. ";
SA`Doc`Input={"Eigenstates"->"The considered eigenstates"};
SA`Doc`GenerateEntry[];

(* *)

AllScalarNonSM={};
AllFermionNonSM={};
AllVectorNonSM={};
SMParticles={};
For[i=1,i<=Length[ParticleDefinitions[Eigenstates]],
Switch[getType[ParticleDefinitions[Eigenstates][[i,1]]],
S,AllScalarNonSM=Join[AllScalarNonSM,{ParticleDefinitions[Eigenstates][[i,1]]}];,
F,AllFermionNonSM=Join[AllFermionNonSM,{ParticleDefinitions[Eigenstates][[i,1]]}];,
V,AllVectorNonSM=Join[AllVectorNonSM,{ParticleDefinitions[Eigenstates][[i,1]]}];
];


AllScalarNonSM = Select[AllScalarNonSM,(FreeQ[Particles[Eigenstates],#]==False)&];
AllFermionNonSM = Select[AllFermionNonSM,(FreeQ[Particles[Eigenstates] /. diracSubBack[Eigenstates],#]==False)&];


Switch[Description /. ParticleDefinitions[Eigenstates][[i,2]],
"Leptons",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	Electron = ParticleDefinitions[Eigenstates][[i,1]];
	ChargedLepton = ParticleDefinitions[Eigenstates][[i,1]];
	UElectron = ToExpression["U"<>ToString[ParticleDefinitions[Eigenstates][[i,1]]]];,
"Sleptons",
	Selectron = ParticleDefinitions[Eigenstates][[i,1]];,
"Down-Quarks",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	BottomQuark = ParticleDefinitions[Eigenstates][[i,1]];
	DownQuark = ParticleDefinitions[Eigenstates][[i,1]];
	UBottom = ToExpression["U"<>ToString[ParticleDefinitions[Eigenstates][[i,1]]]];,
"Down-Squarks",
	BottomSquark = ParticleDefinitions[Eigenstates][[i,1]];,
"Up-Quarks",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	TopQuark = ParticleDefinitions[Eigenstates][[i,1]];
	UpQuark = ParticleDefinitions[Eigenstates][[i,1]];
	UTop = ToExpression["U"<>ToString[ParticleDefinitions[Eigenstates][[i,1]]]];,
"Up-Squarks",
	TopSquark = ParticleDefinitions[Eigenstates][[i,1]];,
"Photon",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	SMParticles=Join[SMParticles,{getGhost[ParticleDefinitions[Eigenstates][[i,1]]]}];
	Photon= ParticleDefinitions[Eigenstates][[i,1]];
	VectorP= ParticleDefinitions[Eigenstates][[i,1]];,
"Gluon",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	SMParticles=Join[SMParticles,{getGhost[ParticleDefinitions[Eigenstates][[i,1]]]}];
           VectorG= ParticleDefinitions[Eigenstates][[i,1]];
	Gluon= ParticleDefinitions[Eigenstates][[i,1]];,
"Gluino",
	Gluino= ParticleDefinitions[Eigenstates][[i,1]];,
"W-Boson",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	SMParticles=Join[SMParticles,{getGhost[ParticleDefinitions[Eigenstates][[i,1]]]}];
	SMParticles=Join[SMParticles,{getGhost[conj[ParticleDefinitions[Eigenstates][[i,1]]]]}];
	VectorW= ParticleDefinitions[Eigenstates][[i,1]];
	Wboson= ParticleDefinitions[Eigenstates][[i,1]];,
"W+ - Boson",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	SMParticles=Join[SMParticles,{getGhost[ParticleDefinitions[Eigenstates][[i,1]]]}];
	SMParticles=Join[SMParticles,{getGhost[conj[ParticleDefinitions[Eigenstates][[i,1]]]]}];
	VectorW= ParticleDefinitions[Eigenstates][[i,1]];,
"Z-Boson",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	SMParticles=Join[SMParticles,{getGhost[ParticleDefinitions[Eigenstates][[i,1]]]}];
	VectorZ= ParticleDefinitions[Eigenstates][[i,1]];
	Zboson= ParticleDefinitions[Eigenstates][[i,1]];,
"Up-Squarks",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	TopSquark= ParticleDefinitions[Eigenstates][[i,1]];,
"Higgs",
	HiggsBoson = ParticleDefinitions[Eigenstates][[i,1]];
	UnmixedHiggs = ToExpression["U"<>ToString[HiggsBoson]];
	HiggsBosonPresent=True;,
"Pseudo-Scalar Higgs",
	PseudoScalar= ParticleDefinitions[Eigenstates][[i,1]];
	PseudoScalarBoson= ParticleDefinitions[Eigenstates][[i,1]];
	PseudoScalarBosonPresent=True;,
"Neutrinos",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	Neutrino = ParticleDefinitions[Eigenstates][[i,1]];
	SA`NeutrinoPresent=True;,
"Charged Higgs",
	ChargedHiggs = ParticleDefinitions[Eigenstates][[i,1]];,
"Sneutrinos",
	Sneutrino = ParticleDefinitions[Eigenstates][[i,1]];,
"Down Quark",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	DownQuarkGen1 = ParticleDefinitions[Eigenstates][[i,1]];,
"Strange Quark",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	StrangeQuark = ParticleDefinitions[Eigenstates][[i,1]];,
"Bottom Quark",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	BottomQuarkGen3 = ParticleDefinitions[Eigenstates][[i,1]];,
"Up Quark",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	UpQuarkGen1 = ParticleDefinitions[Eigenstates][[i,1]];,
"Charmed Quark",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	CharmedQuark = ParticleDefinitions[Eigenstates][[i,1]];,
"Top Quark",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	TopQuarkGen3 = ParticleDefinitions[Eigenstates][[i,1]];,
"Electron",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	ElectronLepton= ParticleDefinitions[Eigenstates][[i,1]];,
"Muon",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	MuonLepoton= ParticleDefinitions[Eigenstates][[i,1]];,
"Tau",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	TauLepton= ParticleDefinitions[Eigenstates][[i,1]];,
"Electron Neutrino",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	ElectronNeutrino= ParticleDefinitions[Eigenstates][[i,1]];,
"Muon Neutrino",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	MuonNeutrino= ParticleDefinitions[Eigenstates][[i,1]];,
"Tau Neutrino",
	SMParticles=Join[SMParticles,{ParticleDefinitions[Eigenstates][[i,1]]}];
	TauNeutrino= ParticleDefinitions[Eigenstates][[i,1]];
   ];

i++;];

If[FreeQ[Global,RParity],
If[FreeQ[ParticleDefinitions[Eigenstates],"Sneutrinos"],
Sneutrino = HiggsBoson;
];

If[FreeQ[ParticleDefinitions[Eigenstates],"Sleptons"],
Selectron = ChargedHiggs;
];
];



For[i=1,i<=Length[ParameterDefinitions],
Switch[Description /. ParameterDefinitions[[i,2]],
"Neutrino-Mixing-Matrix",
	NeutrinoMM = ParameterDefinitions[[i,1]];,
"Up-Yukawa-Coupling",
	UpYukawa = ParameterDefinitions[[i,1]];,
"Down-Yukawa-Coupling",
	DownYukawa = ParameterDefinitions[[i,1]];,
"Lepton-Yukawa-Coupling",
	ElectronYukawa = ParameterDefinitions[[i,1]];,
"Offdiagonal Up-Yukawa Coupling",
	UpYukawaOff = ParameterDefinitions[[i,1]];,
"Offdiagonal Down-Yukawa Coupling",
	DownYukawaOff = ParameterDefinitions[[i,1]];,
"Offdiagonal Electron-Yukawa Coupling",
	ElectronYukawaOff = ParameterDefinitions[[i,1]];,
"Hypercharge-Coupling",
	hyperchargeCoupling =  ParameterDefinitions[[i,1]];,
"Left-Coupling",
	leftCoupling =  ParameterDefinitions[[i,1]];,
"Strong-Coupling",
	strongCoupling =  ParameterDefinitions[[i,1]];,
"electric charge",
	electricCharge =  ParameterDefinitions[[i,1]];,
"Up-Squark-Mixing-Matrix",
	UpSquarkMM = ParameterDefinitions[[i,1]];,
"Neutralino Mixing-Matrix",
	NeutralinoMM = ParameterDefinitions[[i,1]];,
"Chargino-plus Mixing-Matrix",
	CharginoPlusMM = ParameterDefinitions[[i,1]];,
"Chargino-minus Mixing-Matrix",
	CharginoMinusMM = ParameterDefinitions[[i,1]];,
"Slepton-Mixing-Matrix",
	SleptonMM = ParameterDefinitions[[i,1]];,
"Sneutrino Mixing-Matrix",
	SneutrinoMM = ParameterDefinitions[[i,1]];,
"Down-Squark-Mixing-Matrix",
	DownSquarkMM = ParameterDefinitions[[i,1]];,
"Left-Lepton-Mixing-Matrix",
	ElectronMatrixL =  ParameterDefinitions[[i,1]];,
"Right-Lepton-Mixing-Matrix",
	ElectronMatrixR =  ParameterDefinitions[[i,1]];,
"Left-Down-Mixing-Matrix",
	DownMatrixL =  ParameterDefinitions[[i,1]];,
"Right-Down-Mixing-Matrix",
	DownMatrixR =  ParameterDefinitions[[i,1]];,
"Left-Up-Mixing-Matrix",
	UpMatrixL =  ParameterDefinitions[[i,1]];,
"Right-Up-Mixing-Matrix",
	UpMatrixR =  ParameterDefinitions[[i,1]];,
"CKM Matrix",
	CKMmat =  ParameterDefinitions[[i,1]];,
"Weinberg-Angle",
	Weinberg = ParameterDefinitions[[i,1]];,
"Down-VEV",
	VEVSM1 = ParameterDefinitions[[i,1]];,
"Up-VEV",
	VEVSM2 = ParameterDefinitions[[i,1]];,
"EW-VEV",
	VEVSM = ParameterDefinitions[[i,1]];,
"Scalar mixing angle",
	alphaAngle = ParameterDefinitions[[i,1]];,
"Pseudo Scalar mixing angle",
	betaAngle = ParameterDefinitions[[i,1]];,
"Scalar-Mixing-Matrix",
	HiggsMixingMatrix = ParameterDefinitions[[i,1]];,
"Pseudo-Scalar-Mixing-Matrix",
	PseudoScalarMixingMatrix = ParameterDefinitions[[i,1]];,
"Softbreaking right Down-Squark Mass",
	SoftDown= ParameterDefinitions[[i,1]];,
"Softbreaking right Up-Squark Mass",
	SoftUp= ParameterDefinitions[[i,1]];,
"Softbreaking left Slepton Mass",
	SoftLeftLepton = ParameterDefinitions[[i,1]];,
"Softbreaking right Slepton Mass",
	SoftRightLepton = ParameterDefinitions[[i,1]];,
"Softbreaking left Squark Mass",
	SoftSquark = ParameterDefinitions[[i,1]];,
"Trilinear-Up-Coupling",
	TrilinearUp = ParameterDefinitions[[i,1]];,
"Trilinear-Down-Coupling",
	TrilinearDown= ParameterDefinitions[[i,1]];,
"Trilinear-Lepton-Coupling",
	TrilinearLepton= ParameterDefinitions[[i,1]];
];
i++;];

If[FreeQ[ParameterDefinitions,"Neutrino-Mixing-Matrix"],NeutrinoMM=Delta;];


(*
SMParticles={Electron, TopQuark,BottomQuark,VectorP,VectorZ,VectorG,VectorW,Neutrino, getGhost[VectorP], getGhost[VectorZ],getGhost[VectorW],getGhost[conj[VectorW]],DownQuarkGen1,StrangeQuark,UpQuarkGen1,CharmedQuark,BottomQuarkGen3,TopQuarkGen3,ElectronLepton,MuonLepoton,TauLepton,ElectronNeutrino,MuonNeutrino,TauNeutrino};
*)

SMParticlesAndHiggs=SMParticles;
SMParticlesAndHiggs=Join[SMParticlesAndHiggs,{HiggsBoson,PseudoScalar,ChargedHiggs}];

NonSMQ[x_]:=FreeQ[SMParticles,RE[x]];
SMQ[x_]:=If[FreeQ[SMParticles,RE[x]],Return[False];,Return[True];];
SMQHiggs[x_]:=If[FreeQ[SMParticlesAndHiggs,RE[x]],Return[False];,If[FreeQ[SMParticles,RE[x]]==False || getGenALL[RE[x]]==1,Return[True];,Return[False];];];
SMQ[x_,Higgs->False]:=SMQ[x];
SMQ[x_,Higgs->True]:=SMQHiggs[x];



AllFermionNonSM=DeleteCases[AllFermionNonSM,x_?SMQ,3];
AllScalarNonSM=DeleteCases[AllScalarNonSM,x_?SMQ,3];
AllVectorNonSM=DeleteCases[AllVectorNonSM,x_?SMQ,3];


SA`Doc`EndEntry[];
];





(* End[] *)


